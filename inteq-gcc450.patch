diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/c-common.c /home/haosun/intchecker/gcc-4.5.0/gcc/c-common.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/c-common.c	2010-04-02 15:54:46.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/c-common.c	2015-07-23 13:00:17.885599624 -0400
@@ -53,6 +53,9 @@
 #include "fixed-value.h"
 #include "libfuncs.h"
 
+/* added by intfns */
+extern void intfns_init (void);
+
 cpp_reader *parse_in;		/* Declared in c-pragma.h.  */
 
 /* The following symbols are subsumed in the c_global_trees array, and
@@ -4644,6 +4647,10 @@
 
   if (flag_mudflap)
     mudflap_init ();
+
+  /* added by intfns */
+  if(flag_intfns)
+  	intfns_init();
 }
 
 /* Like get_identifier, but avoid warnings about null arguments when
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/common.opt /home/haosun/intchecker/gcc-4.5.0/gcc/common.opt
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/common.opt	2010-03-17 23:01:09.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/common.opt	2015-03-13 10:30:51.847820084 -0400
@@ -681,6 +681,39 @@
 Common RejectNegative Joined
 -finstrument-functions-exclude-file-list=filename,...  Do not instrument functions listed in files
 
+;===================================
+;New options for intfns
+
+fintfns
+Common Report Var(flag_intfns) Init(0) Optimization
+ALL, default:Instrument-all intfns
+
+fintfns-checker
+Common Report Var(flag_intfns_checker) Init(0) Optimization
+IntChecker
+
+fintfns-sign
+Common Report Var(flag_intfns_sign) Init(0) Optimization
+IntChecker
+
+fintfns-sign-cst
+Common Report Var(flag_intfns_sign_cst) Init(0) Optimization
+IntChecker
+
+fintfns-sign-checker
+Common Report Var(flag_intfns_sign_checker) Init(0) Optimization
+IntChecker
+
+fintfns-handler-counter
+Common Report Var(flag_intfns_handler_counter) Init(0) Optimization
+Overflow handler counts the detailed location of overflow hanppening sites
+
+fintfns-handler-nop
+Common Report Var(flag_intfns_handler_nop) Init(0) Optimization
+Overflow handler do nothing for the overflow in order to compute the runtime overhead
+
+;===================================
+
 fipa-cp
 Common Report Var(flag_ipa_cp) Optimization
 Perform Interprocedural constant propagation
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/fold-const.c /home/haosun/intchecker/gcc-4.5.0/gcc/fold-const.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/fold-const.c	2010-04-06 06:36:57.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/fold-const.c	2015-01-16 17:13:25.431563212 -0500
@@ -10888,17 +10888,21 @@
 	  && operand_equal_p (arg0, arg1, 0))
 	return fold_convert_loc (loc, type, integer_zero_node);
 
+	/*modified by intfns*/
+	if(!flag_intfns)
+	{
       /* A - B -> A + (-B) if B is easily negatable.  */
       if (negate_expr_p (arg1)
 	  && ((FLOAT_TYPE_P (type)
                /* Avoid this transformation if B is a positive REAL_CST.  */
-	       && (TREE_CODE (arg1) != REAL_CST
-		   ||  REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1))))
+	      && (TREE_CODE (arg1) != REAL_CST
+		  ||  REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1))))
 	      || INTEGRAL_TYPE_P (type)))
 	return fold_build2_loc (loc, PLUS_EXPR, type,
 			    fold_convert_loc (loc, type, arg0),
 			    fold_convert_loc (loc, type,
 					      negate_expr (arg1)));
+	}	// modified by intfns
 
       /* Try folding difference of addresses.  */
       {
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/function.h /home/haosun/intchecker/gcc-4.5.0/gcc/function.h
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/function.h	2009-11-25 05:55:54.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/function.h	2014-12-17 22:50:39.436137434 -0500
@@ -527,6 +527,11 @@
      a string describing the reason for failure.  */
   const char * GTY((skip)) cannot_be_copied_reason;
 
+  /* added by intfns */
+  /* this ptr field is used to store stats obtained through intfns analysis.
+  converted to struct intfns_statistics * when necessary. */
+  char * intfns_info;
+
   /* Collected bit flags.  */
 
   /* Number of units of general registers that need saving in stdarg
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/gimple.h /home/haosun/intchecker/gcc-4.5.0/gcc/gimple.h
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/gimple.h	2010-04-02 15:54:46.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/gimple.h	2015-08-22 14:36:59.412276231 -0400
@@ -306,6 +306,31 @@
      in there.  */
   unsigned int subcode		: 16;
 
+  /* added by intfns */
+  unsigned int intfns_stmt_type_flag : 5;
+  unsigned int intfns_stmt_left_ssa_flag: 1;
+  unsigned int intfns_stmt_status_flag : 3;
+  
+  unsigned int intfns_stmt_exclude_flag : 1;
+  unsigned int intfns_stmt_exclude_cst_flag : 1;
+  unsigned int intfns_stmt_exclude_unuse_flag : 1;
+  unsigned int intfns_stmt_exclude_uncritical_use_flag : 1;
+  unsigned int intfns_stmt_exclude_santz_post_flag : 1;
+  unsigned int intfns_stmt_exclude_bit_flag : 1;
+  unsigned int intfns_stmt_exclude_narrow_flag : 1;
+
+  unsigned int intfns_intop_implicit_flag : 4;
+  unsigned int intfns_signcast_useless_flag : 1;
+  unsigned int intfns_stmt_sink_flag: 1;
+  unsigned int intfns_stmt_ret_flag: 1;
+  unsigned int intfns_stmt_being_analyzed_flag: 1;
+
+  unsigned int intfns_intop_equiv_pool_flag: 2;
+  unsigned int intfns_intop_equiv_tail_flag: 5;
+
+  unsigned int intfns_intop_ovf_flag: 1;
+  /*unsigned int spare : 1;*/
+
   /* UID of this statement.  This is used by passes that want to
      assign IDs to statements.  It must be assigned and used by each
      pass.  By default it should be assumed to contain garbage.  */
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns1.c /home/haosun/intchecker/gcc-4.5.0/gcc/intfns1.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns1.c	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns1.c	2015-01-15 14:13:27.161609479 -0500
@@ -0,0 +1,6907 @@
+/* Detailed Implementation of IntFNS.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "rtl.h"
+#include "tm_p.h"
+#include "hard-reg-set.h"
+#include "basic-block.h"
+#include "output.h"
+#include "flags.h"
+#include "function.h"
+#include "expr.h"
+#include "ggc.h"
+#include "langhooks.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "timevar.h"
+#include "tree-dump.h"
+#include "tree-pass.h"
+#include "toplev.h"
+#include "except.h"
+#include "cfgloop.h"
+#include "cfglayout.h"
+#include "tree-ssa-propagate.h"
+#include "value-prof.h"
+#include "pointer-set.h"
+#include "tree-inline.h"
+#include "gimple.h"
+
+#include "intfns.h"
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------basic helper functions-----------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+
+/* Build a reference to a literal string.  */
+static tree
+intfns_build_string (const char *string)
+{
+  	size_t len = strlen (string);
+  	tree result = build_string (len + 1, string);
+
+  	TREE_TYPE (result) = build_array_type
+    	(char_type_node, build_index_type (build_int_cst (NULL_TREE, len)));
+  	TREE_CONSTANT (result) = 1;
+  	TREE_READONLY (result) = 1;
+  	TREE_STATIC (result) = 1;
+
+  	result = build1 (ADDR_EXPR, build_pointer_type (char_type_node), result);
+
+  	return result;
+}
+
+/* And another friend, for producing a simpler message.  */
+static tree
+intfns_file_function_line_tree (location_t location)
+{
+  	expanded_location xloc = expand_location (location);
+  	const char *file = NULL, *colon, *line, *op, *name, *cp;
+  	char linecolbuf[30]; /* Enough for two decimal numbers plus a colon.  */
+  	char *string;
+  	tree result;
+
+  	/* Add FILENAME[:LINENUMBER[:COLUMNNUMBER]].  */
+  	file = xloc.file;
+  	if (file == NULL && current_function_decl != NULL_TREE)
+    	file = DECL_SOURCE_FILE (current_function_decl);
+  	if (file == NULL)
+    	file = "<unknown file>";
+
+  	if (xloc.line > 0)
+    {
+      	if (xloc.column > 0)
+        	sprintf (linecolbuf, "%d:%d", xloc.line, xloc.column);
+      	else
+        	sprintf (linecolbuf, "%d", xloc.line);
+      	colon = ":";
+      	line = linecolbuf;
+    }
+  	else
+   	 	colon = line = "";
+
+  	/* Add (FUNCTION).  */
+  	name = lang_hooks.decl_printable_name (current_function_decl, 1);
+  	if (name)
+    {
+      	op = " (";
+      	cp = ")";
+    }
+  	else
+    	op = name = cp = "";
+
+  	string = concat (file, colon, line, op, name, cp, NULL);
+  	result = intfns_build_string (string);
+  	free (string);
+
+  	return result;
+}
+
+/* Helper for intfns_init: construct a decl with the given category,
+   name, and type, mark it an external reference, and pushdecl it.  */
+static inline tree
+intfns_make_builtin (enum tree_code category, const char *name, tree type)
+{
+  	/* tree decl = intsortfns_mark (build_decl (UNKNOWN_LOCATION,
+				   category, get_identifier (name), type)); */
+  	tree decl = build_decl (UNKNOWN_LOCATION, category, get_identifier (name), type);
+  	TREE_PUBLIC (decl) = 1;
+  	DECL_EXTERNAL (decl) = 1;
+  	lang_hooks.decls.pushdecl (decl);
+  	/* The decl was declared by the compiler.  */
+  	DECL_ARTIFICIAL (decl) = 1;
+  	/* And we don't want debug info for it.  */
+  	DECL_IGNORED_P (decl) = 1;
+  	return decl;
+}
+
+/* a function to insert 2 handler call */
+void intfns_insert_main (void)
+{
+	tree ctor_statements = NULL_TREE;
+	tree dtor_statements = NULL_TREE;
+	tree call2_stmt;
+	
+  	/* Insert a call to intfns_insert_init().  */
+  	{
+    	call2_stmt = build_call_expr (intfns_insert_init_fndecl, 0);
+    	append_to_statement_list (call2_stmt, &ctor_statements);
+  	}
+
+  	cgraph_build_static_cdtor ('I', ctor_statements,
+                             MAX_RESERVED_INIT_PRIORITY-1);
+
+  	/* Insert a call to intfns_insert_finish().  */
+  	{
+    	call2_stmt = build_call_expr (intfns_insert_finish_fndecl, 0);
+    	append_to_statement_list (call2_stmt, &dtor_statements);
+  	}
+
+  	cgraph_build_static_cdtor ('D', dtor_statements,
+                             MAX_RESERVED_INIT_PRIORITY-1);
+}
+
+
+/*a function to initialize the global tree nodes
+that may be used when instrumentation.  */
+void intfns_init (void)
+{
+	/* const-string type */
+	tree intfns_const_string_type;
+	/* void intfns_io_printer(char* loc, rhs1, rhs2, print_type);  */
+	tree intfns_io_printer_8_fntype;
+	tree intfns_io_printer_16_fntype;
+	tree intfns_io_printer_32_fntype;
+	tree intfns_io_printer_64_fntype;
+	/* void intfns_io_counter(char* loc, print_type);  */
+	tree intfns_io_counter_fntype;
+	/* void function type, intfns_insert_init(void), intfns_insert_finish(void)*/
+	tree intfns_insert_void_fntype;
+	
+	/* const-string type */
+	intfns_const_string_type = build_pointer_type (build_qualified_type
+    	(char_type_node, TYPE_QUAL_CONST));
+	
+	/* void intfns_io_printer_xx(char* loc, rhs1, rhs2, print_type);  */
+	intfns_io_printer_8_fntype = build_function_type_list(void_type_node, intfns_const_string_type, char_type_node,
+	   	char_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_8_fndecl =
+	    intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_8",
+		         intfns_io_printer_8_fntype);
+	
+	intfns_io_printer_16_fntype = build_function_type_list(void_type_node, intfns_const_string_type, short_integer_type_node,
+	   	short_integer_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_16_fndecl =	
+	    intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_16",
+	         intfns_io_printer_16_fntype);
+	
+	intfns_io_printer_32_fntype = build_function_type_list(void_type_node, intfns_const_string_type, integer_type_node,
+       	integer_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_32_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_32",
+             intfns_io_printer_32_fntype);
+
+	intfns_io_printer_64_fntype = build_function_type_list(void_type_node, intfns_const_string_type, long_long_integer_type_node,
+       	long_long_integer_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_64_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_64",
+             intfns_io_printer_64_fntype);	
+
+	/* void intfns_io_counter(char* loc, print_type);  */
+	intfns_io_counter_fntype = build_function_type_list(void_type_node, intfns_const_string_type, integer_type_node, NULL_TREE);
+	intfns_io_counter_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_counter",intfns_io_counter_fntype);
+
+	/* void intfns_insert_init(void);  */
+	intfns_insert_void_fntype =	build_function_type_list(void_type_node, NULL_TREE);
+	intfns_insert_init_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_insert_init",
+             intfns_insert_void_fntype);
+
+	/* void intfns_insert_finish(void);  */
+	intfns_insert_finish_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_insert_finish",
+             intfns_insert_void_fntype);
+
+	/* void intfns_io_nop(void);  */
+	intfns_io_nop_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_nop",
+             intfns_insert_void_fntype);
+	
+	/* init the value of s-max, s-min and u-max, both in 8,16,32,64-bit. */
+	// refer to tree.h 3767 for integer_type_node and long_long_integer_type_node
+	intfns_smax_8 = build_int_cst (char_type_node, 0x7f);
+	intfns_smin_8 = build_int_cst (char_type_node, 0x80);
+	intfns_umax_8 = build_int_cstu (unsigned_char_type_node, 0xff);
+	
+	intfns_smax_16 = build_int_cst (short_integer_type_node, 0x7fff);
+	intfns_smin_16 = build_int_cst (short_integer_type_node, 0x8000);
+	intfns_umax_16 = build_int_cstu (short_unsigned_type_node, 0xffff);	
+	
+	intfns_smax_32 = build_int_cst (integer_type_node, 0x7fffffff);
+	intfns_smin_32 = build_int_cst (integer_type_node, 0x80000000);
+	intfns_umax_32 = build_int_cstu (unsigned_type_node, 0xffffffff);
+	
+	intfns_smax_64 = build_int_cst_wide (long_long_integer_type_node, 0xffffffff, 0x7fffffff);
+	intfns_smin_64 = build_int_cst_wide (long_long_integer_type_node, 0x00000000, 0x80000000);
+	intfns_umax_64 = build_int_cst_wide (long_long_unsigned_type_node, 0xffffffff, 0xffffffff);
+
+	/* for intfns-io2bo */
+	intfns_io2bo_dirty_s32 = build_int_cst (integer_type_node, 0x80100000);
+	intfns_io2bo_dirty_u32 = build_int_cstu (unsigned_type_node, 0x80100000);
+	
+	DIRTY_mask = build_int_cstu (unsigned_type_node, 0xc0000000);
+	DIRTY_data = build_int_cstu (unsigned_type_node, 0x80000000);
+
+	/* void intfns_io2bo_guard(char* loc);  */
+	tree intfns_io2bo_guarnd_fntype;
+	intfns_io2bo_guarnd_fntype = build_function_type_list(void_type_node, intfns_const_string_type, NULL_TREE);
+	intfns_io2bo_guard_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io2bo_guard",intfns_io2bo_guarnd_fntype);	
+}
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------------- intfns-insert-----------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/**********************************************
+insert check code to detect integer overflows at runtime.
+
+default: instrument-all, invoked by -fintfns
+for each stmt in current func:	
+	if stmt is add, sub, mul and shl
+		if the operands are of integer type
+			insert check code for them.//intfns-instrument-intop
+
+invoked by -fintfns-intra or -fintfns-inter
+for all the stmts in the waitlist of current func:
+	// waitlist is generated by pass-intfns-intra or pass-intfns-inter
+	for each stmt in the waitlish
+		this stmt is selected as potential intop
+			insert check code for them.//intfns-instrument-intop
+	
+//intfns-instrument-intop:
+such process of instrumentation is executed using basic block information at the ipa analysis phase.
+therefore, the code instrumentation will break the CFG and 
+we do have to consider how to operate the Basic Block.
+
+we implement this function by learning the pass-mudflap-2 in tree-mudflap.c.
+the execution trace for pass-mudflap-2 is like:
+	execute_mudflap_function_ops -> mf_xform_statements -> mf_xform_derefs_1 
+	-> mf_build_check_statement_for
+and mf_build_check_statement_for() is the very function where we learn most.
+
+at the same time, we could also produce some statistics about integer operations.
+num_stmt: the number of all the stmt for current function
+num_sign_op_N: the number of integer operations which need instrumentation
+	here, op enums add/sub/mul/shl
+		sign enums signed and unsigned
+		and N enums 8 (char), 16 (short), 32 (int) and 64 (long long)
+**********************************************/
+
+/* insert check code before add, sub, in both signed and unsigned forms. */
+static unsigned int
+intfns_pre_instrument_intop_add_sub(FILE * file, gimple_stmt_iterator *instr_gsi,
+							location_t location, tree lhs, tree rhs1, tree rhs2, 
+							enum INTOP_TYPE type, int width)
+{
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u, v, w, m, n;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree smax, smin, umax;
+
+	// current we focus on8,16,32,64-bit, and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme
+		smax = intfns_smax_8;
+		smin = intfns_smin_8;
+		umax = intfns_umax_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		smax = intfns_smax_16;
+		smin = intfns_smin_16;
+		umax = intfns_umax_16;
+	}
+	else if(width == 32)
+	{	
+		smax = intfns_smax_32;
+		smin = intfns_smin_32;
+		umax = intfns_umax_32;
+	}
+	else if(width == 64)
+	{
+		smax = intfns_smax_64;
+		smin = intfns_smin_64;
+		umax = intfns_umax_64;
+	}
+	else
+		return;
+	
+	tree print_type = build_int_cst (integer_type_node, type);
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block (intfns-io-printer).	*/
+	then_bb = create_empty_bb (cond_bb);
+	make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+	}
+
+	/*-------------------2. create the io-check-cond and insert them into cond-bb---------------*/
+	seq = gimple_seq_alloc ();
+	/* 2.1 create the io-check-code for different intop, add/sub/mul/shl, in either sign/unsign.*/
+	if(type == FNS_UADD)
+	{	/*unsigned add c = a + b;, trigger cond is (a > umax -b)*/
+   		/*build tmp = umax - b */
+		if(width == 8)
+			u = build2 (MINUS_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			u = build2 (MINUS_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			u = build2 (MINUS_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			u = build2 (MINUS_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		/* build a > umax - b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_add_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SADD)
+	{	/*signed add c = a + b;, trigger cond is (a>0&&b>0&&a>smax-b)||(a<0&&b<0&&a<smin-b)*/
+ 		/* build a > 0*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b > 0 */
+		v = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a > smax - b*/
+		if(width == 8)
+			w = build2 (MINUS_EXPR, char_type_node, smax, rhs2);
+		else if (width == 16)
+			w = build2 (MINUS_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width == 32)
+			w = build2 (MINUS_EXPR, integer_type_node, smax, rhs2);
+		else
+			w = build2 (MINUS_EXPR, long_long_integer_type_node, smax, rhs2);
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a>0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b>0'&&'a>smax-b''******************/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, v);
+
+		/* build a < 0*/
+		u = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b < 0 */
+		v = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a < smin - b*/
+		if(width == 8)
+			w = build2 (MINUS_EXPR, char_type_node, smin, rhs2);
+		else if(width == 16)
+			w = build2 (MINUS_EXPR, short_integer_type_node, smin, rhs2);
+		else if(width == 32)
+			w = build2 (MINUS_EXPR, integer_type_node, smin, rhs2);
+		else
+			w = build2 (MINUS_EXPR, long_long_integer_type_node, smin, rhs2);
+		m = build2 (LT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a<0 && b < 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b>0'&&'a>smax-b''*******************/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, m, v);
+
+		/*build ---||---*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, n);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_add_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+		
+	}
+	else if(type == FNS_USUB)
+	{	/*unsigned sub: c = a - b;, trigger cond is if(a<b)*/
+		t = build2 (LT_EXPR, boolean_type_node, rhs1, rhs2);		
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_sub_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SSUB)
+	{	/*signed sub: c = a - b;, trigger cond is (a<0&&b>0&&a<smin+b)||(a>0&&b<0&&a>smax+b)*/
+		/* build a < 0*/
+		u = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b > 0 */
+		v = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a < smin + b*/
+		if(width == 8)
+			w = build2 (PLUS_EXPR, char_type_node, smin, rhs2);
+		else if(width == 16)
+			w = build2 (PLUS_EXPR, short_integer_type_node, smin, rhs2);
+		else if(width == 32)
+			w = build2 (PLUS_EXPR, integer_type_node, smin, rhs2);
+		else
+			w = build2 (PLUS_EXPR, long_long_integer_type_node, smin, rhs2);
+		t = build2 (LT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a<0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a<0'&&'b>0'&&'a<smin+b''******************/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, v);
+
+		/* build a > 0*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b < 0 */
+		v = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a > smax + b*/
+		if(width == 8)
+			w = build2 (PLUS_EXPR, char_type_node, smax, rhs2);
+		else if(width == 16)
+			w = build2 (PLUS_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width == 32)
+			w = build2 (PLUS_EXPR, integer_type_node, smax, rhs2);
+		else
+			w = build2 (PLUS_EXPR, long_long_integer_type_node, smax, rhs2);
+		m = build2 (GT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a>0 && b < 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b<0'&&'a>smax+b''*******************/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, m, v);
+
+		/*build ---||---*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, n);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_sub_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else
+		return 0;	// error
+
+	/* 2.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 2.3 insert these code into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------3. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_io_counter_fndecl, 2, 
+			intfns_file_function_line_tree (location), print_type);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();	// it is a 'nop' to calculate the overhead
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_io_printer_8_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else if(width == 16)
+			gg = gimple_build_call (intfns_io_printer_16_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+		else if(width == 32)
+			gg = gimple_build_call (intfns_io_printer_32_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else
+			gg = gimple_build_call (intfns_io_printer_64_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------4. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* insert check code before mul, in both signed and unsigned forms. */
+static unsigned int
+intfns_pre_instrument_intop_mul_shl(FILE * file, gimple_stmt_iterator *instr_gsi,
+							location_t location, tree lhs, tree rhs1, tree rhs2, 
+							enum INTOP_TYPE type, int width)
+{		
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, cond_nonzero_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u, v, w, m, n;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree smax, smin, umax;
+
+	// current we only focus on 32-bit and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme
+		smax = intfns_smax_8;
+		smin = intfns_smin_8;
+		umax = intfns_umax_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		smax = intfns_smax_16;
+		smin = intfns_smin_16;
+		umax = intfns_umax_16;
+	}
+	else if(width == 32)
+	{	
+		smax = intfns_smax_32;
+		smin = intfns_smin_32;
+		umax = intfns_umax_32;
+	}
+	else if(width == 64)
+	{
+		smax = intfns_smax_64;
+		smin = intfns_smin_64;
+		umax = intfns_umax_64;
+	}
+	else
+		return;
+	
+	tree print_type = build_int_cst (integer_type_node, type);
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block */
+	cond_nonzero_bb = create_empty_bb (cond_bb);
+	then_bb = create_empty_bb (cond_nonzero_bb);
+	make_edge (cond_bb, cond_nonzero_bb, EDGE_TRUE_VALUE);
+	make_edge (cond_nonzero_bb, then_bb, EDGE_TRUE_VALUE);
+	make_edge (cond_nonzero_bb, join_bb, EDGE_FALSE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, cond_nonzero_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_nonzero_bb);
+	}
+
+	/*-------------------2. create the (b!=0) && (b!=-1) and insert it into cond-bb---------------*/
+	/*fixme: b!=-1 would bypass the overflow (smin*(-1)), we would handle it when free.*/
+	seq = gimple_seq_alloc ();
+	if(type == FNS_SMUL)
+	{
+		/* build b!=0*/
+		u = build2 (NE_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build b!=-1*/
+		v = build2 (NE_EXPR, boolean_type_node, rhs2, integer_minus_one_node);	
+		/*build b!=0 && b!=-1*/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+	}
+	else
+	{
+		/* build b!=0*/
+		t = build2 (NE_EXPR, boolean_type_node, rhs2, integer_zero_node);
+	}	
+	t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+ 	gimple_seq_add_seq (&seq, stmts);
+ 	cond = make_rename_temp (boolean_type_node, "__intfns_mul_cond_nonzero");
+ 	gg = gimple_build_assign  (cond, t);
+	gimple_set_location (gg, location);
+  	gimple_seq_add_stmt (&seq, gg);
+
+	/* build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* insert it into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+	
+
+	/*-------------------3. create mul-io check code and insert them into cond-nonzero-bb---------------*/
+	seq = gimple_seq_alloc ();
+	
+	/* 3.1 create the io-check-code for different intop, add/sub/mul/shl, in either sign/unsign.*/
+	if(type == FNS_UMUL)
+	{	/*unsigned mul: c = a * b;, trigger cond is (a > umax/b)*/		
+		/* build a > umax/b*/
+		if(width == 8)
+			v = build2 (TRUNC_DIV_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			v = build2 (TRUNC_DIV_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			v = build2 (TRUNC_DIV_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			v = build2 (TRUNC_DIV_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, v);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_mul_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SMUL)
+	{	/*signed mul: c = a * b;, trigger cond is
+			(a>0&&b>0&&a>smax/b)||(a<0&&b<0&&a<smax/b)
+				||(a>0&&b<0&&a>smin/b)||(a<0&&b>0&&a<smin/b)*/
+		tree uu, vv, ww, mm, nn, tt;
+		
+		/*build a > 0*/
+		uu = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/*build a < 0*/
+		vv = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/*build b > 0*/
+		ww = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/*build b < 0*/
+		mm = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/*build smax/b*/
+		if(width == 8)
+			nn = build2 (TRUNC_DIV_EXPR, char_type_node, smax, rhs2);
+		else if(width ==16)
+			nn = build2 (TRUNC_DIV_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width == 32)
+			nn = build2 (TRUNC_DIV_EXPR, integer_type_node, smax, rhs2);
+		else
+			nn = build2 (TRUNC_DIV_EXPR, long_long_integer_type_node, smax, rhs2);
+		/*build smin/b*/
+		if(width == 8)
+			tt = build2 (TRUNC_DIV_EXPR, char_type_node, smin, rhs2);
+		else if(width == 16)
+			tt = build2 (TRUNC_DIV_EXPR, short_integer_type_node, smin, rhs2);
+		else if(width == 32)
+			tt = build2 (TRUNC_DIV_EXPR, integer_type_node, smin, rhs2);
+		else
+			tt = build2 (TRUNC_DIV_EXPR, long_long_integer_type_node, smin, rhs2);
+
+		/*build a>smax/b*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, nn);
+		/*build a>0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, uu, ww);
+		/*build 1':(a>0&&b>0&&a>smax/b)*******************/
+		u = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+
+		/*build a<smax/b*/
+		v = build2 (LT_EXPR, boolean_type_node, rhs1, nn);
+		/*build a<0 && b < 0*/
+		w = build2 (TRUTH_AND_EXPR, boolean_type_node, vv, mm);
+		/*build 2':(a<0&&b<0&&a<smax/b)*******************/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, v, w);
+
+		/*build a>smin/b*/
+		w = build2 (GT_EXPR, boolean_type_node, rhs1, tt);
+		/*build a>0 && b < 0*/
+		m = build2 (TRUTH_AND_EXPR, boolean_type_node, uu, mm);
+		/*build 3':(a>0&&b<0&&a>smin/b)*******************/
+		w = build2 (TRUTH_AND_EXPR, boolean_type_node, w, m);
+
+		/*build a<smin/b*/
+		m = build2 (LT_EXPR, boolean_type_node, rhs1, tt);
+		/*build a<0 && b > 0*/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, vv, ww);
+		/*build 4':(a<0&&b>0&&a<smin/b)*******************/
+		m = build2 (TRUTH_AND_EXPR, boolean_type_node, m, n);
+
+		/*build 1' || 2' || 3' || 4'*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, u, v);
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, w);
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, m);	
+		
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_mul_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);	
+	}
+	else if(type == FNS_USHL)
+	{	/*left shift: c = a << b;, trigger cond is a > umax>>b)*/
+		/*build umax>>b*/
+		if(width == 8)
+			u = build2 (RSHIFT_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			u = build2 (RSHIFT_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			u = build2 (RSHIFT_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			u = build2 (RSHIFT_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		/*build a > umax>>b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_shl_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SSHL)
+	{	/*left shift: c = a << b;, trigger cond is a > smax>>b)*/
+		/*build smax>>b*/
+		if(width == 8)
+			u = build2 (RSHIFT_EXPR, char_type_node, smax, rhs2);
+		else if(width == 16)
+			u = build2 (RSHIFT_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width ==32)
+			u = build2 (RSHIFT_EXPR, integer_type_node, smax, rhs2);
+		else
+			u = build2 (RSHIFT_EXPR, long_long_integer_type_node, smax, rhs2);
+		/*build a > smax>>b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_shl_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else
+		return 0;
+
+	/* 3.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 3.3 insert these code into cond-nonzero-bb */
+	gsi = gsi_start_bb (cond_nonzero_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------4. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_io_counter_fndecl, 2, 
+			intfns_file_function_line_tree (location), print_type);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_io_printer_8_fndecl, 4, 	
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+		else if(width == 16)
+			gg = gimple_build_call (intfns_io_printer_16_fndecl, 4, 
+					intfns_file_function_line_tree (location), rhs1, rhs2, print_type);	
+		else if(width == 32)
+			gg = gimple_build_call (intfns_io_printer_32_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else
+			gg = gimple_build_call (intfns_io_printer_64_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------5. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+
+/* insert pre-condition test for intop */
+void intfns_insert_pre_test (void)
+{
+	/* a file used to log this process */
+	FILE * file_intfns_print = fopen("/tmp/log_intfns_insert_pre_test.txt", "a");
+	if(file_intfns_print == NULL)
+	{
+		printf("ERROR: fail to open file - log_intfns_insert.txt\n");
+		return 0;
+	}
+	fprintf(file_intfns_print, "$intfns-insert %s():\n",
+		lang_hooks.decl_printable_name(current_function_decl, 2));
+	if(DECL_STRUCT_FUNCTION(current_function_decl) == NULL)
+	{
+		fprintf(file_intfns_print, "$NO function* field.\n");
+		fprintf(file_intfns_print, "$intfns-insert ends here.\n\n");
+		fclose(file_intfns_print);
+		return 0;
+	}
+
+	/* to record the number of sign-op-N */
+	int num_stmt = 0;
+	int num_intop_instrument = 0;
+	int num_sign_add = 0;
+	int num_unsign_add = 0;
+	int num_sign_sub = 0;
+	int num_unsign_sub = 0;
+	int num_sign_mul = 0;
+	int num_unsign_mul = 0;
+	int num_sign_shl = 0;
+	int num_unsign_shl = 0;
+
+	/* insert checks code for each integer operations */
+	basic_block bb, next;
+	int saved_last_basic_block = last_basic_block;
+	gimple_stmt_iterator gsi;
+	tree lhs, rhs1, rhs2;
+	gimple stmt;
+	int width;							/* to get the bits number for certain type */
+	int stmt_type;						/* to indicate the type of stmt*/
+
+	bb = ENTRY_BLOCK_PTR ->next_bb;
+  	do
+	{
+      	next = bb->next_bb;
+		for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi)){
+			num_stmt ++;
+			stmt = gsi_stmt (gsi);
+			
+			switch (gimple_code (stmt))	/* to check the type of stmt */
+			{
+				case GIMPLE_ASSIGN:
+
+				// filter the intop: FNS_UADD~FNS_SSHL, mul-offset and shl-const
+				stmt_type = INTFNS_STMT_TYPE(stmt);
+				if((stmt_type >= FNS_UADD)
+					&&(stmt_type <= FNS_SSHL))
+					;
+				else if((stmt_type == INTFNS_STMT_UMUL_OFFSET)
+					|| (stmt_type == INTFNS_STMT_SMUL_OFFSET))
+				{
+					//if(flag_intfns_insert_omit_mul_offset)
+						break;
+				}
+				else if(stmt_type == INTFNS_STMT_SHL_CONST)
+					;
+				else
+					break;
+
+				// check whether this stmt is selected by intfns-intra/intfns-inter
+				// for inter-p, we only insert those intop->sink
+				// for intra-p, we insert those intop->sink, intop->func and intop->ret
+				if(flag_intfns_inter)
+				{
+					if((INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						&&((INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_CLEAN)
+						||(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_FUNC)))
+						break;
+				}
+				else if(flag_intfns_intra)
+				{
+					if((INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						&&(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_CLEAN))
+						break;
+				}
+				else if(flag_intfns_io2bo)
+				{
+					if(INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						break;
+				}
+				else if(flag_intfns_santz)
+				{
+					//if(INTFNS_INTOP_SANTZD_TYPE(stmt) != INTFNS_INTOP_SANTZD_FAIL)
+					if((INTFNS_INTOP_SANTZD_TYPE(stmt) >= INTFNS_INTOP_SANTZD_UNUSED)
+						&& (INTFNS_INTOP_SANTZD_TYPE(stmt) <= INTFNS_INTOP_SANTZD_HYBRID))
+						break;
+				}
+				else
+					;
+				
+				lhs = gimple_assign_lhs (stmt);
+				rhs1 = gimple_assign_rhs1(stmt);
+				rhs2 = gimple_assign_rhs2(stmt);	/* get the two operands */
+
+				/* get the width info for this computation. */					
+				width =  TREE_INT_CST_LOW(TYPE_SIZE(TREE_TYPE(lhs)));
+				
+				// FIXME: a static verifying process would reduce the number of instrumentations.
+				// maybe, we could exploit some Range Analysis here to exclude some unnecessary checks
+
+				/* insert check code for the filtered intop */
+				if(stmt_type == FNS_UADD)
+				{
+					/* c = a + b; */
+					/*trigger: (a > umax -b)*/
+					intfns_pre_instrument_intop_add_sub(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_UADD, width);
+					num_intop_instrument ++;
+					num_unsign_add ++;
+				}
+				else if(stmt_type == FNS_SADD)
+				{	/* c = a + b; */
+					/*trigger: (a>0&&b>0&&a>smax-b)||(a<0&&b<0&&a<smin-b)*/
+					intfns_pre_instrument_intop_add_sub(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SADD, width);
+					num_intop_instrument ++;
+					num_sign_add ++;
+				}
+				else if(stmt_type == FNS_USUB)
+				{	/*c = a - b;*/
+					/*trigger:  a < b*/
+					intfns_pre_instrument_intop_add_sub(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_USUB, width);
+					num_intop_instrument ++;
+					num_unsign_sub ++;
+				}
+				else if(stmt_type == FNS_SSUB)
+				{	/*c = a - b;*/
+					/*trigger: (a<0&&b>0&&a<smin+b)||(a>0&&b<0&&a>smax+b)*/
+					intfns_pre_instrument_intop_add_sub(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SSUB, width);
+					num_intop_instrument ++;
+					num_sign_sub ++;
+				}
+				else if((stmt_type == FNS_UMUL) || (stmt_type == INTFNS_STMT_UMUL_OFFSET))
+				{	/*c = a * b;*/
+					/*trigger: (b!=0 && a > umax/b)*/
+					intfns_pre_instrument_intop_mul_shl(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_UMUL, width);
+					num_intop_instrument ++;
+					num_unsign_mul ++;
+				}
+				else if((stmt_type == FNS_SMUL) || (stmt_type == INTFNS_STMT_SMUL_OFFSET))
+				{	/*c = a * b;*/
+					/*trigger:(b!=0) &&
+								( (a>0&&b>0&&a>smax/b)||(a<0&&b<0&&a<smax/b)
+								||(a>0&&b<0&&a>smin/b)||(a<0&&b>0&&a<smin/b))*/
+					intfns_pre_instrument_intop_mul_shl(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SMUL, width);
+					num_intop_instrument ++;
+					num_sign_mul ++;
+				}
+				else if((stmt_type == FNS_USHL) || (stmt_type == INTFNS_STMT_SHL_CONST))
+				{	/*c = a << b;*/
+					/*trigger: a > umax>>b)*/
+					intfns_pre_instrument_intop_mul_shl(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_USHL, width);
+					num_intop_instrument ++;
+					num_unsign_shl ++;
+				}
+				else if(stmt_type == FNS_SSHL)
+				{	/*c = a << b;*/
+					/*trigger: a > smax>>b)*/
+					intfns_pre_instrument_intop_mul_shl(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SSHL, width);
+					num_intop_instrument ++;
+					num_sign_shl ++;
+				}
+				else
+					;
+				break;
+			default:
+				;
+			}
+    	}
+		bb = next;
+  	}
+	while(bb && bb->index <= saved_last_basic_block);
+	
+	fprintf (file_intfns_print, "\ttotal %d stmts, and %d io-checks are inserted.\n", num_stmt, num_intop_instrument);
+	fprintf(file_intfns_print, "\tsadd:%d\tuadd:%d\tssub:%d\tusub:%d\tsmul:%d\tumul:%d\tsshl:%d\tushl:%d\n",
+		num_sign_add, num_unsign_add, num_sign_sub, num_unsign_sub,
+		num_sign_mul, num_unsign_mul, num_sign_shl, num_unsign_shl);
+	fprintf (file_intfns_print, "$intfns-insert ends here.\n\n");
+	fclose (file_intfns_print);
+	
+	if(num_intop_instrument > 0)
+	{
+		FILE * file = fopen("/tmp/log_intfns_insert_pre_num.txt", "a");
+		fprintf(file, "%d\n", num_intop_instrument);
+		fclose(file);
+	}
+	return 1;
+
+}
+
+
+/* insert check code after add, sub, and left shift, in both signed and unsigned forms. */
+static unsigned int
+intfns_post_instrument_intop_non_mul(FILE * file, gimple_stmt_iterator *instr_gsi,
+							location_t location, tree lhs, tree rhs1, tree rhs2, 
+							enum INTOP_TYPE type, int width)
+{
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u, v, w, m, n;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree smax, smin, umax;
+
+	// current we focus on8,16,32,64-bit, and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme
+		smax = intfns_smax_8;
+		smin = intfns_smin_8;
+		umax = intfns_umax_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		smax = intfns_smax_16;
+		smin = intfns_smin_16;
+		umax = intfns_umax_16;
+	}
+	else if(width == 32)
+	{	
+		smax = intfns_smax_32;
+		smin = intfns_smin_32;
+		umax = intfns_umax_32;
+	}
+	else if(width == 64)
+	{
+		smax = intfns_smax_64;
+		smin = intfns_smin_64;
+		umax = intfns_umax_64;
+	}
+	else
+		return;
+	
+	tree print_type = build_int_cst (integer_type_node, type);
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block (intfns-io-printer).	*/
+	then_bb = create_empty_bb (cond_bb);
+	make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+	}
+
+	/*-------------------2. create the io-check-cond and insert them into cond-bb---------------*/
+	seq = gimple_seq_alloc ();
+	/* 2.1 create the io-check-code for different intop, add/sub/shl, in either sign/unsign.*/
+	if(type == FNS_UADD)
+	{	/*unsigned add c = a + b;, trigger cond is (c<a)*/	
+		/* build c < a */
+		t = build2 (LT_EXPR, boolean_type_node, lhs, rhs1);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_add_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SADD)
+	{	/*signed add c = a + b;, trigger cond is (a>0&&b>0&&c<0)||(a<0&&b<0&&c>0)*/
+ 		/* build a > 0*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b > 0 */
+		v = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build c < 0*/
+		t = build2 (LT_EXPR, boolean_type_node, lhs, integer_zero_node);
+
+		/*build a>0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b>0'&&'c<0''******************/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, v);
+
+		/* build a < 0*/
+		u = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b < 0 */
+		v = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build c > 0 */		
+		m = build2 (GT_EXPR, boolean_type_node, lhs, integer_zero_node);
+
+		/*build a<0 && b < 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b>0'&&'c>0''*******************/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, m, v);
+
+		/*build ---||---*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, n);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_add_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+		
+	}
+	else if(type == FNS_USUB)
+	{	/*unsigned sub: c = a - b;, trigger cond is if(a<b)*/
+		t = build2 (LT_EXPR, boolean_type_node, rhs1, rhs2);		
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_sub_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SSUB)
+	{	/*signed sub: c = a - b;, trigger cond is (a<0&&b>0&&c>0)||(a>0&&b<0&&c<0)*/
+		/* build a < 0*/
+		u = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b > 0 */
+		v = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build c > 0 */
+		t = build2 (GT_EXPR, boolean_type_node, lhs, integer_zero_node);
+
+		/*build a<0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a<0'&&'b>0'&&'c>0''******************/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, v);
+
+		/* build a > 0*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b < 0 */
+		v = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build c < 0*/
+		m = build2 (LT_EXPR, boolean_type_node, lhs, integer_zero_node);
+
+		/*build a>0 && b < 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b<0'&&'c<0''*******************/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, m, v);
+
+		/*build ---||---*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, n);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_sub_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_USHL)
+	{	/*left shift: c = a << b;, trigger cond is a > umax>>b)*/
+		/*build umax>>b*/
+		if(width == 8)
+			u = build2 (RSHIFT_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			u = build2 (RSHIFT_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			u = build2 (RSHIFT_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			u = build2 (RSHIFT_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		/*build a > umax>>b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_shl_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SSHL)
+	{	/*left shift: c = a << b;, trigger cond is a > smax>>b)*/
+		/*build smax>>b*/
+		if(width == 8)
+			u = build2 (RSHIFT_EXPR, char_type_node, smax, rhs2);
+		else if(width == 16)
+			u = build2 (RSHIFT_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width ==32)
+			u = build2 (RSHIFT_EXPR, integer_type_node, smax, rhs2);
+		else
+			u = build2 (RSHIFT_EXPR, long_long_integer_type_node, smax, rhs2);
+		/*build a > smax>>b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_shl_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else
+		return 0;	// error
+
+	/* 2.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 2.3 insert these code into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------3. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_io_counter_fndecl, 2, 
+			intfns_file_function_line_tree (location), print_type);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();	// it is a 'nop' to calculate the overhead
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else if (flag_intfns_io2bo)
+	{
+		// here, we only focus on 32 bits
+		if(width == 32)
+		{
+			if((type == FNS_UADD) || (type == FNS_USUB) || (type == FNS_USHL))
+				gg = gimple_build_assign (lhs, intfns_io2bo_dirty_u32);
+			else
+				gg = gimple_build_assign (lhs, intfns_io2bo_dirty_s32);
+		}
+	}
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_io_printer_8_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else if(width == 16)
+			gg = gimple_build_call (intfns_io_printer_16_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+		else if(width == 32)
+			gg = gimple_build_call (intfns_io_printer_32_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else
+			gg = gimple_build_call (intfns_io_printer_64_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------4. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* insert check code before mul, in both signed and unsigned forms. */
+static unsigned int
+intfns_post_instrument_intop_mul(FILE * file, gimple_stmt_iterator *instr_gsi,
+							location_t location, tree lhs, tree rhs1, tree rhs2, 
+							enum INTOP_TYPE type, int width)
+{		
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, cond_nonzero_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, v, u;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree smax, smin, umax;
+
+	// current we only focus on 32-bit and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme
+		smax = intfns_smax_8;
+		smin = intfns_smin_8;
+		umax = intfns_umax_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		smax = intfns_smax_16;
+		smin = intfns_smin_16;
+		umax = intfns_umax_16;
+	}
+	else if(width == 32)
+	{	
+		smax = intfns_smax_32;
+		smin = intfns_smin_32;
+		umax = intfns_umax_32;
+	}
+	else if(width == 64)
+	{
+		smax = intfns_smax_64;
+		smin = intfns_smin_64;
+		umax = intfns_umax_64;
+	}
+	else
+		return;
+	
+	tree print_type = build_int_cst (integer_type_node, type);
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block.	*/
+	cond_nonzero_bb = create_empty_bb (cond_bb);
+	then_bb = create_empty_bb (cond_nonzero_bb);
+	make_edge (cond_bb, cond_nonzero_bb, EDGE_TRUE_VALUE);
+	make_edge (cond_nonzero_bb, then_bb, EDGE_TRUE_VALUE);
+	make_edge (cond_nonzero_bb, join_bb, EDGE_FALSE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, cond_nonzero_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_nonzero_bb);
+	}
+
+	/*-------------------2. create the (c!=0)  and insert it into cond-bb---------------*/
+	seq = gimple_seq_alloc ();
+	/* build c != 0*/
+	t = build2 (NE_EXPR, boolean_type_node, lhs, integer_zero_node);	
+	t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+ 	gimple_seq_add_seq (&seq, stmts);
+ 	cond = make_rename_temp (boolean_type_node, "__intfns_mul_cond_nonzero");
+ 	gg = gimple_build_assign  (cond, t);
+	gimple_set_location (gg, location);
+  	gimple_seq_add_stmt (&seq, gg);
+
+	/* build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* insert it into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+	
+
+	/*-------------------3. create mul-io check code and insert them into cond-nonzero-bb---------------*/
+	seq = gimple_seq_alloc ();
+	/* build c/a != b*/
+	if(type == FNS_UMUL)
+	{	/*unsigned mul: c = a * b;*/
+		if(width == 8)
+			v = build2 (TRUNC_DIV_EXPR, unsigned_char_type_node, lhs, rhs1);
+		else if(width == 16)
+			v = build2 (TRUNC_DIV_EXPR, short_unsigned_type_node, lhs, rhs1);
+		else if(width == 32)
+			v = build2 (TRUNC_DIV_EXPR, unsigned_type_node, lhs, rhs1);
+		else
+			v = build2 (TRUNC_DIV_EXPR, long_long_unsigned_type_node, lhs, rhs1);
+		t = build2 (NE_EXPR, boolean_type_node, v, rhs2);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_mul_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == FNS_SMUL)
+	{	/*signed mul: c = a * b;*/
+		if(width == 8)
+			v = build2 (TRUNC_DIV_EXPR, char_type_node, lhs, rhs1);
+		else if(width == 16)
+			v = build2 (TRUNC_DIV_EXPR, short_integer_type_node, lhs, rhs1);
+		else if(width == 32)
+			v = build2 (TRUNC_DIV_EXPR, integer_type_node, lhs, rhs1);
+		else
+			v = build2 (TRUNC_DIV_EXPR, long_long_integer_type_node, lhs, rhs1);
+		t = build2 (NE_EXPR, boolean_type_node, v, rhs2);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_mul_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);	
+	}
+	else
+		;	
+
+	/* 3.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 3.3 insert these code into cond-nonzero-bb */
+	gsi = gsi_start_bb (cond_nonzero_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------4. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_io_counter_fndecl, 2, 
+			intfns_file_function_line_tree (location), print_type);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else if (flag_intfns_io2bo)
+	{
+		// here, we only focus on 32 bits
+		if(width == 32)
+		{
+			if(type == FNS_UMUL)
+				gg = gimple_build_assign (lhs, intfns_io2bo_dirty_u32);
+			else
+				gg = gimple_build_assign (lhs, intfns_io2bo_dirty_s32);
+		}
+	}
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_io_printer_8_fndecl, 4, 	
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+		else if(width == 16)
+			gg = gimple_build_call (intfns_io_printer_16_fndecl, 4, 
+					intfns_file_function_line_tree (location), rhs1, rhs2, print_type);	
+		else if(width == 32)
+			gg = gimple_build_call (intfns_io_printer_32_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else
+			gg = gimple_build_call (intfns_io_printer_64_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------5. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* insert pre-condition test for intop */
+void intfns_insert_post_test (void)
+{
+	/* a file used to log this process */
+	FILE * file_intfns_print = fopen("/tmp/log_intfns_insert_post_test.txt", "a");
+	if(file_intfns_print == NULL)
+	{
+		printf("ERROR: fail to open file - log_intfns_insert.txt\n");
+		return 0;
+	}
+	fprintf(file_intfns_print, "$intfns-insert %s():\n",
+		lang_hooks.decl_printable_name(current_function_decl, 2));
+	if(DECL_STRUCT_FUNCTION(current_function_decl) == NULL)
+	{
+		fprintf(file_intfns_print, "$NO function* field.\n");
+		fprintf(file_intfns_print, "$intfns-insert ends here.\n\n");
+		fclose(file_intfns_print);
+		return 0;
+	}
+
+	fprintf(file_intfns_print, "begin >> \n");
+
+	/* to record the number of sign-op-N */
+	int num_stmt = 0;
+	int num_intop_instrument = 0;
+	int num_sign_add = 0;
+	int num_unsign_add = 0;
+	int num_sign_sub = 0;
+	int num_unsign_sub = 0;
+	int num_sign_mul = 0;
+	int num_unsign_mul = 0;
+	int num_sign_shl = 0;
+	int num_unsign_shl = 0;
+
+	/* insert checks code for each integer operations */
+	basic_block bb, next;
+	int saved_last_basic_block = last_basic_block;
+	gimple_stmt_iterator gsi;
+	tree lhs, rhs1, rhs2;
+	gimple stmt;
+	int width;							/* to get the bits number for certain type */
+	int stmt_type;						/* to indicate the type of stmt*/
+	int is_inserted;					/* to tell whether check code is inserted */
+
+	bb = ENTRY_BLOCK_PTR ->next_bb;
+  	do
+	{
+      	next = bb->next_bb;
+		gsi = gsi_start_bb (bb);
+		while(!gsi_end_p (gsi)){
+			is_inserted = 0;
+			num_stmt ++;
+			stmt = gsi_stmt (gsi);
+			
+			switch (gimple_code (stmt))	/* to check the type of stmt */
+			{
+				case GIMPLE_ASSIGN:
+
+				// filter the intop: FNS_UADD~FNS_SSHL, mul-offset and shl-const
+				stmt_type = INTFNS_STMT_TYPE(stmt);
+				if((stmt_type >= FNS_UADD)
+					&&(stmt_type <= FNS_SSHL))
+					;
+				else if((stmt_type == INTFNS_STMT_UMUL_OFFSET)
+					|| (stmt_type == INTFNS_STMT_SMUL_OFFSET))
+				{
+					if(flag_intfns_insert_omit_mul_offset)
+						break;
+				}
+				else if(stmt_type == INTFNS_STMT_SHL_CONST)
+					;
+				else
+					break;
+
+				// check whether this stmt is selected by intfns-intra/intfns-inter
+				// for inter-p, we only insert those intop->sink
+				// for intra-p, we insert those intop->sink, intop->func and intop->ret
+				if(flag_intfns_inter)
+				{
+					if((INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						&&((INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_CLEAN)
+						||(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_FUNC)))
+						break;
+				}
+				else if(flag_intfns_intra)
+				{
+					if((INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						&&(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_CLEAN))
+						break;
+				}
+				else if(flag_intfns_io2bo)
+				{
+					if(INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						break;
+				}
+				else
+					;
+		if(flag_intfns_io2bo){
+		/* to profile the distance for each selected intop */
+		FILE * file = fopen("/tmp/log_intfns_selected_intop_distance.txt", "a");
+		fprintf(file, "%d\n", INTFNS_INTOP_STEPS(stmt));
+		fclose(file);}
+
+				
+				lhs = gimple_assign_lhs (stmt);
+				rhs1 = gimple_assign_rhs1(stmt);
+				rhs2 = gimple_assign_rhs2(stmt);	/* get the two operands */
+
+				/* get the width info for this computation. */					
+				width =  TREE_INT_CST_LOW(TYPE_SIZE(TREE_TYPE(lhs)));
+
+				/* for intfns-io2bo, we only focus on 32 bits */
+				if(flag_intfns_io2bo)
+				{
+					if(width != 32)
+						break;
+				}
+				
+				// FIXME: a static verifying process would reduce the number of instrumentations.
+				// maybe, we could exploit some Range Analysis here to exclude some unnecessary checks
+
+				/* insert check code for the filtered intop */
+				if(stmt_type == FNS_UADD)
+				{
+					is_inserted = 1;
+					gsi_next (&gsi);
+					/* c = a + b; */
+					/*trigger: (c<a)*/
+					if(gsi_end_p (gsi))
+						break;
+					intfns_post_instrument_intop_non_mul(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_UADD, width);
+					num_intop_instrument ++;
+					num_unsign_add ++;
+				}
+				else if(stmt_type == FNS_SADD)
+				{
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/* c = a + b; */
+					/* trigger: (a>0&&b>0&&c<0)||(a<0&&b<0&&c>0) */
+					intfns_post_instrument_intop_non_mul(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SADD, width);
+					num_intop_instrument ++;
+					num_sign_add ++;
+				}
+				else if(stmt_type == FNS_USUB)
+				{	
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/*c = a - b;*/
+					/*trigger:  a < b*/
+					if(gsi_end_p (gsi))
+						break;
+					intfns_post_instrument_intop_non_mul(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_USUB, width);
+					num_intop_instrument ++;
+					num_unsign_sub ++;
+				}
+				else if(stmt_type == FNS_SSUB)
+				{	
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/*c = a - b;*/
+					/*trigger: (a>0&&b<0&&c<0)||(a<0&&b>0&&c>0)*/
+					intfns_post_instrument_intop_non_mul(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SSUB, width);
+					num_intop_instrument ++;
+					num_sign_sub ++;
+				}
+				else if((stmt_type == FNS_UMUL) || (stmt_type == INTFNS_STMT_UMUL_OFFSET))
+				{	
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/*c = a * b;*/
+					/*trigger: (c != 0) && (c/a != b)*/
+					intfns_post_instrument_intop_mul(file_intfns_print, &gsi, 
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_UMUL, width);
+					num_intop_instrument ++;
+					num_unsign_mul ++;
+				}
+				else if((stmt_type == FNS_SMUL) || (stmt_type == INTFNS_STMT_SMUL_OFFSET))
+				{	
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/*c = a * b;*/
+					/*trigger:(c != 0) && (c/a != b)*/
+					intfns_post_instrument_intop_mul(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SMUL, width);
+					num_intop_instrument ++;
+					num_sign_mul ++;
+				}
+				else if((stmt_type == FNS_USHL) || (stmt_type == INTFNS_STMT_SHL_CONST))
+				{	
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/*c = a << b;*/
+					/*trigger: a > umax>>b)*/
+					/* or (a > 0) && (b >0) && (c>>b != a) */
+					intfns_post_instrument_intop_non_mul(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_USHL, width);
+					num_intop_instrument ++;
+					num_unsign_shl ++;
+				}
+				else if(stmt_type == FNS_SSHL)
+				{	
+					is_inserted = 1;
+					gsi_next (&gsi);
+					if(gsi_end_p (gsi))
+						break;
+					/*c = a << b;*/
+					/*trigger: a > smax>>b)*/
+					intfns_post_instrument_intop_non_mul(file_intfns_print, &gsi,
+						gimple_location(stmt), lhs, rhs1, rhs2, FNS_SSHL, width);
+					num_intop_instrument ++;
+					num_sign_shl ++;
+				}
+				else
+					;
+				break;
+			default:
+				;
+			}
+
+			if(is_inserted == 0)
+				gsi_next (&gsi);
+    	}
+		bb = next;
+  	}
+	while(bb && bb->index <= saved_last_basic_block);
+	
+	fprintf (file_intfns_print, "\ttotal %d stmts, and %d io-checks are inserted.\n", num_stmt, num_intop_instrument);
+	fprintf(file_intfns_print, "\tsadd:%d\tuadd:%d\tssub:%d\tusub:%d\tsmul:%d\tumul:%d\tsshl:%d\tushl:%d\n",
+		num_sign_add, num_unsign_add, num_sign_sub, num_unsign_sub,
+		num_sign_mul, num_unsign_mul, num_sign_shl, num_unsign_shl);
+	fprintf (file_intfns_print, "$intfns-insert ends here.\n\n");
+	fclose (file_intfns_print);
+
+	if(num_intop_instrument > 0)
+	{
+		FILE * file = fopen("/tmp/log_intfns_insert_post_num.txt", "a");
+		fprintf(file, "%d\n", num_intop_instrument);
+		fclose(file);
+	}
+	
+	return 1;
+}
+
+/* execution function for pass_intfns_insert */
+static unsigned int
+execute_intfns_insert (void)
+{
+	if(flag_intfns_insert_post_test)
+		intfns_insert_post_test();
+	else
+		intfns_insert_pre_test();
+}
+/* gate for pass_intfns_insert, invoked by -fintfns */
+static bool
+gate_intfns_insert (void)
+{
+	return flag_intfns && (! flag_intfns_no_inserts);
+}
+
+/* pass_intfns_insert definition */
+struct gimple_opt_pass pass_intfns_insert =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_insert",			/* name */
+  		gate_intfns_insert,			/* gate */
+  		execute_intfns_insert,		/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_INSERT,			/* tv_id */
+  		PROP_ssa, 					/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		TODO_update_ssa 			/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------------- intfns-profile-----------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* statistics: the integer operations at runtime.
+	1. type: add, sub, mul, shl
+	2. location
+	3. executing time.
+
+	this pass is triggered by intra/inter and no-inserts
+*/
+
+/* execution function for pass_intfns_profile */
+static unsigned int
+execute_intfns_profile (void)
+{
+	
+	if(DECL_STRUCT_FUNCTION(current_function_decl) == NULL)
+		return 0;
+
+	/* insert checks code for each integer operations */
+	basic_block bb, next;
+	int saved_last_basic_block = last_basic_block;
+	gimple_stmt_iterator gsi;
+	tree lhs;
+	gimple stmt;
+	int width;							/* to get the bits number for certain type */
+	gimple gg;
+	gimple_seq seq;
+	tree print_type;
+	gimple_stmt_iterator instr_gsi;
+
+	bb = ENTRY_BLOCK_PTR ->next_bb;
+  	do
+	{
+      	next = bb->next_bb;
+		for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi)){
+			stmt = gsi_stmt (gsi);
+			
+			switch (gimple_code (stmt))	/* to check the type of stmt */
+			{
+				case GIMPLE_ASSIGN:
+				lhs = gimple_assign_lhs (stmt);
+
+				if((INTFNS_STMT_TYPE(stmt)>=FNS_UADD)
+					&& (INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+					;
+				else
+					break;
+
+				// check whether this stmt is selected by intfns-intra/intfns-inter
+				// for inter-p, we only insert those intop->sink
+				// for intra-p, we insert those intop->sink, intop->func and intop->ret
+				if(flag_intfns_inter)
+				{
+					if((INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						&&((INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_CLEAN)
+						||(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_FUNC)))
+						break;
+				}
+				else if(flag_intfns_intra)
+				{
+					if((INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_CLEAN)
+						&&(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_CLEAN))
+						break;
+				}
+				else
+					return;				
+				
+				/* get the width info for this computation. */					
+				width =  TREE_INT_CST_LOW(TYPE_SIZE(TREE_TYPE(lhs)));
+
+				if((width == 32) || (width == 64))
+					;
+				else
+					break;
+
+				// insert the intfns-io-counter(STMT-TYPE) before stmt
+				instr_gsi = gsi;
+				seq = gimple_seq_alloc ();
+				print_type = build_int_cst (integer_type_node,
+					INTFNS_STMT_TYPE(stmt));
+				
+				gg = gimple_build_call (intfns_io_counter_fndecl, 2,
+					intfns_file_function_line_tree (gimple_location(stmt)), print_type);
+				gimple_set_location (gg, gimple_location(stmt));
+			 	gimple_seq_add_stmt (&seq, gg);
+			  	gsi_insert_seq_before (&gsi, seq, GSI_CONTINUE_LINKING);
+
+				gsi = instr_gsi;
+				
+				break;
+			default:
+				;
+			}
+    	}
+		bb = next;
+  	}
+	while(bb && bb->index <= saved_last_basic_block);
+	return 1;
+}
+
+/* gate for pass_intfns_profile, invoked by -fintfns */
+static bool
+gate_intfns_profile (void)
+{
+	return flag_intfns && flag_intfns_intra
+		&& flag_intfns_inter && flag_intfns_no_inserts
+		&& flag_intfns_profile;
+}
+
+/* pass_intfns_profile definition */
+struct gimple_opt_pass pass_intfns_profile =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_insert",			/* name */
+  		gate_intfns_profile,			/* gate */
+  		execute_intfns_profile,		/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_PROFILE,			/* tv_id */
+  		PROP_ssa, 					/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		TODO_update_ssa 			/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*-------------------------------intfns-mark-stmt------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/*this pass is a helper pass for the whole INTFNS.
+its goal is to tag all the stmt in a function.
+this is accomplished through setting INTFNS_STMT_TYPE(NODE) defined in intfns.h
+
+basically, we want to mark:
+	each int-op;
+	each sink: if/stmt/array-index/sink(lib-call, extern)/ptr-offset
+	each propagate(a = b; a = (cast)b; a = b/c;)
+	each narrow-op, denied-op(>>)
+	each relation-op.
+
+then, we want to update the info:
+	if the first operand of shl is a const, then update it as shl-const
+	if a mul is used at ptr-offset, then update it as mul-offset.
+	if a relation is used at if/while, then update it as if/while.
+
+at the phase of intra and inter.
+	we will not anazlye shl-const and mul-offset.
+	we treate mul-offset as sink.
+	
+however, at the phase of insert,
+	if it is the instrument-all version,
+		we will still insert check code for shl-const and mul-offset.
+*/
+
+/* return the next stmt after stmt. */
+gimple gimple_next(gimple stmt)
+{
+	// find the gsi for current stmt
+	gimple_stmt_iterator gsi = gsi_for_stmt(stmt);
+	gimple stmt_next;
+
+	gsi_next(&gsi);
+	if(!gsi_end_p(gsi))
+		return (gsi_stmt(gsi));
+	
+	return NULL;
+}
+
+/* mark stmt */
+void intfns_mark_stmt(gimple stmt)
+{	
+	tree lhs, rhs1, rhs2;
+	basic_block bb, then_bb, else_bb;
+	edge e;
+	enum gimple_rhs_class grhs_class;	/* class of rhs-expr */
+	enum tree_code rhs_code;			/* code for rhs-expr */
+	bool is_unsign = false;				/* to indicate the signedness of operations */
+	int htab_result;
+	
+	switch (gimple_code (stmt))	/* to check the type of stmt */
+	{	// ref to dump_gimple_stmt() in gimple.c
+	
+	case GIMPLE_ASSIGN:
+		grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));
+		rhs_code = gimple_assign_rhs_code(stmt);
+		lhs = gimple_assign_lhs (stmt);		
+		
+		if (grhs_class == GIMPLE_BINARY_RHS) /* binary operation, c = a op b; */
+		{
+			// pointer-offset stmt
+			if(rhs_code == POINTER_PLUS_EXPR)
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PTR_PLUS;
+				break;
+			}
+
+			if(TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+				break;
+
+			// lhs is not a SSA-NAME node
+			if(TREE_CODE(lhs) != SSA_NAME)
+			{
+				// if lhs is a global var
+				//if(is_global_var(lhs))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_ADDRESS_GLOBAL;
+				break;
+			}
+
+			// intop: +, -, *, <<
+			if((rhs_code == PLUS_EXPR) || (rhs_code == MINUS_EXPR)
+ 				|| (rhs_code == MULT_EXPR) || (rhs_code == LSHIFT_EXPR))
+			{	/* potential intop: c = a op b*/
+				rhs1 = gimple_assign_rhs1(stmt);
+				rhs2 = gimple_assign_rhs2(stmt);
+
+				/* a, b and c are all of integer-type */
+				if ((TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+					||(TREE_CODE (TREE_TYPE(rhs1)) != INTEGER_TYPE)
+					||(TREE_CODE (TREE_TYPE(rhs2)) != INTEGER_TYPE))
+					break;
+
+				/* a and b are both XX_CST, just pass. caz such cases can not be exploited by attackers.  */
+				if(((TREE_CODE(rhs1) == INTEGER_CST)||(TREE_CODE(rhs1) == REAL_CST))
+					&& ((TREE_CODE(rhs2) == INTEGER_CST)||(TREE_CODE(rhs2) == REAL_CST)))
+					break;
+
+				// FIXME: it is an optimization here.
+				// based on our observation, 1 << bits is not used by attackers
+				// therefore, we un-select these lshft with the first operand as const
+				// FIXME: when doing the intfns-santz, we ignore such optimization.
+				if((!flag_intfns_santz)
+					&&(rhs_code == LSHIFT_EXPR)
+					&&(TREE_CODE(rhs1) == INTEGER_CST))
+				{
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SHL_CONST;
+					break;
+				}
+
+				/* get the sign-info for a, b and c. */
+				is_unsign = TYPE_UNSIGNED(TREE_TYPE(rhs1))
+					&& TYPE_UNSIGNED(TREE_TYPE(rhs2));
+
+				if(rhs_code == PLUS_EXPR)
+					INTFNS_STMT_TYPE(stmt) = is_unsign ? FNS_UADD: FNS_SADD;
+				else if(rhs_code == MINUS_EXPR)
+					INTFNS_STMT_TYPE(stmt) = is_unsign ? FNS_USUB: FNS_SSUB;
+				else if(rhs_code == MULT_EXPR)
+					INTFNS_STMT_TYPE(stmt) = is_unsign ? FNS_UMUL: FNS_SMUL;
+				else
+					INTFNS_STMT_TYPE(stmt) = TYPE_UNSIGNED(TREE_TYPE(rhs1))? FNS_USHL: FNS_SSHL;
+			}
+			
+			// narrow-op: |, &, %
+			else if((rhs_code == BIT_IOR_EXPR) || (rhs_code == BIT_AND_EXPR)
+				|| (rhs_code == TRUNC_MOD_EXPR)
+				|| (rhs_code == FLOOR_MOD_EXPR) || (rhs_code == CEIL_MOD_EXPR)
+				|| (rhs_code == ROUND_MOD_EXPR))
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NARROW;
+			
+			// relation-op: <, >, ==, &&, ||
+			else if((rhs_code == LT_EXPR) || (rhs_code == GT_EXPR)
+				|| (rhs_code == LE_EXPR) || (rhs_code == GE_EXPR)
+				|| (rhs_code == EQ_EXPR) || (rhs_code == NE_EXPR)
+				|| (rhs_code == TRUTH_AND_EXPR)|| (rhs_code == TRUTH_OR_EXPR)
+				|| (rhs_code == TRUTH_XOR_EXPR)
+				)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_RELATION;
+
+			// based on our observation, /, ^, >> might be used as propagate-op
+			else if((rhs_code == TRUNC_DIV_EXPR) || (rhs_code == FLOOR_DIV_EXPR)
+				|| (rhs_code == CEIL_DIV_EXPR) || (rhs_code == ROUND_DIV_EXPR)
+				|| (rhs_code == BIT_XOR_EXPR) || (rhs_code == RSHIFT_EXPR))
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PROPAGATE;
+			
+			// based on our observation, >> is seldom used in the ovf path
+			// therefore, we define >> as 'denied' op.
+			//else if (rhs_code == RSHIFT_EXPR)
+			//	INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_DENIED;				
+			else
+				;			
+		}
+		else if(grhs_class == GIMPLE_UNARY_RHS)
+		{	// cast
+			/* lhs must be of ssa-name. */
+			if(TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+				break;
+			
+			if(TREE_CODE(lhs) != SSA_NAME)
+			{
+				// if lhs is a global var
+				//if(is_global_var(lhs))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_ADDRESS_GLOBAL;
+				break;
+			}
+			
+			if(rhs_code == TRUTH_NOT_EXPR)		//!a
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_RELATION;	
+			else if ((rhs_code == CONVERT_EXPR)
+				|| (rhs_code == NOP_EXPR)
+				|| (rhs_code == BIT_NOT_EXPR))
+			{
+				rhs1 = gimple_assign_rhs1(stmt);
+				if ((TREE_CODE (TREE_TYPE(lhs)) == INTEGER_TYPE)
+					||(TREE_CODE (TREE_TYPE(rhs1)) == INTEGER_TYPE))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PROPAGATE;
+				else
+					;
+			}
+			else
+				;
+		}
+		else //GIMPLE_SINGLE_RHS or GIMPLE_INVALID_RHS
+		{
+			if(rhs_code == ARRAY_REF)	// temp = array[index];
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_ARRAY_REF;
+			else
+			{	
+				if(TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+					break;
+				
+				rhs1 = gimple_assign_rhs1(stmt);
+				// D.temp = RHS.temp
+				if ((TREE_CODE(lhs) == SSA_NAME)
+					&& (TREE_CODE (TREE_TYPE(lhs)) == INTEGER_TYPE)
+					&& (TREE_CODE(rhs1) != INTEGER_CST))
+				{
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PROPAGATE;
+					break;
+				}
+				// VAR-DECL = SSA-NAME
+				else if((TREE_CODE(lhs) == VAR_DECL)
+					&& (TREE_CODE(rhs1) == SSA_NAME))
+				{
+					// we should propagate the following stmt
+					// var-decl = ssa-name;
+					// ssa-name = var-decl;
+					gimple next_stmt = gimple_next(stmt);
+					if((next_stmt != NULL)
+						&&(gimple_code(next_stmt) == GIMPLE_ASSIGN)
+						&&(get_gimple_rhs_class (gimple_assign_rhs_code (next_stmt))== GIMPLE_SINGLE_RHS))
+					{
+						tree next_lhs = gimple_assign_lhs(next_stmt);
+						tree next_rhs = gimple_assign_rhs1(next_stmt);
+						if((TREE_CODE(next_lhs) == SSA_NAME)
+							&& (TREE_CODE(next_rhs) == VAR_DECL)
+							&& (next_rhs == lhs))
+						{
+							INTFNS_STMT_TYPE(stmt)= INTFNS_STMT_VAR_PROPAGATE;
+							break;
+						}
+					}					
+				}
+
+				// lhs is a global var
+				//if(is_global_var(lhs))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_ADDRESS_GLOBAL;
+				break;				
+			}			
+		}
+		
+		break;
+	case GIMPLE_CALL:
+		if(gimple_call_fndecl(stmt) == NULL)
+			break;
+		
+		/*DECL_BUILT_IN(NODE): lib-call. */
+		if(DECL_BUILT_IN(gimple_call_fndecl(stmt)))
+		{
+			if(find_sink_lib_arg(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt)))) >= 0)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SINK_LIB;
+			else
+			{
+				// otherwise, if this call has integer-type argument, then set it as uncritical lib call
+				/*int ix;
+				tree arg;
+				for (ix = 0; ix < gimple_call_num_args (stmt); ix++)
+				{
+					arg = gimple_call_arg(stmt, ix);
+					if((TREE_CODE(arg) != INTEGER_CST)
+						&&(TREE_CODE (TREE_TYPE(arg)) == INTEGER_TYPE))
+					{
+						INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_UNCRITICAL_LIB;
+						break;
+					}
+				}*/
+				if((strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "printf") == 0)
+					|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "fprintf") == 0)
+					|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "sprintf") == 0))
+				{
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_UNCRITICAL_LIB;
+					break;
+				}
+			}
+			break;
+		}
+
+		/* user supplied function. */
+		if(DECL_EXTERNAL(gimple_call_fndecl(stmt)))		
+		{
+			/* for intfns-io2bo*/
+			if(flag_intfns_io2bo)
+			{
+				if((strstr(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "alloc") != NULL)
+					|| (strstr(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "Alloc") != NULL))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_EXTERNAL_SINK;
+				break;
+			}
+			if(flag_intfns_santz)
+			{
+				if(strstr(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "print") != NULL)
+				{
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_EXTERNAL_UNCRITICAL;
+					break;
+				}
+			}
+			
+			/* external function */
+			htab_result = find_extern_func_sink(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))));
+			if( htab_result == 1)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_EXTERNAL_SINK;
+			else if(htab_result == 0)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_EXTERNAL_UNCRITICAL;
+			else
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_EXTERNAL_FUNC;
+			break;
+		}
+		else
+			INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NORMAL_FUNC;
+		
+		/*if(DECL_STRUCT_FUNCTION(gimple_call_fndecl(stmt)) == NULL)
+		{
+			if(find_sink_lib_arg(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt)))) >= 0)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SINK_LIB;
+			else
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_UNCRITICAL_LIB;
+		}			
+		else
+			INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NORMAL_FUNC;*/
+		
+		break;
+	case GIMPLE_COND:
+		/* fixme: it is too simple to idefntify IF and WHILE. */
+		if(EDGE_COUNT (bb->succs) == 2)
+		{
+			e = EDGE_SUCC(bb,0);
+			then_bb = e->dest;
+			e = EDGE_SUCC(bb,1);
+			else_bb = e->dest;
+			if((then_bb == bb)||(else_bb == bb))
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_WHILE;
+			else
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_IF;
+		}
+		else
+			INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_IF;
+		
+		break;
+	case GIMPLE_RETURN:
+		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_RET;
+		break;
+	case GIMPLE_PHI:
+		// propagae-op in intfns
+		break;
+	default:
+		// non-sense?
+		break;
+	}
+}
+
+/* return TRUE if this stmt is if-cond, while-stmt or a relation-smt*/
+bool gimple_is_if_while_relation(gimple stmt)
+{
+	if(gimple_code(stmt) == GIMPLE_ASSIGN)
+	{
+		if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)
+			||(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_IF)
+			||(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_WHILE))
+			return true;
+		else
+			return false;
+	}
+	else if(gimple_code(stmt) == GIMPLE_COND)
+		return true;
+	else
+		return false;
+}
+
+/* mark all the relation stmt for if/while, and mul stmt for ptr-offset through a backward analysis */
+void intfns_backward_mark_cond_offset(gimple stmt)
+{	
+	/* refer to tree-flow.h, gimple.h and tree-flow-inline.h */	
+	tree lhs = gimple_assign_lhs (stmt);
+	gimple use;
+	use_operand_p use_p;
+
+	// a mul stmt would trun ino mul-offset if its only use is for ptr-offset
+	// at the intfns-intra/inter phase, we could treat mul-offset as sinks while treating ptr-offset as unciritcal
+	if((INTFNS_STMT_TYPE(stmt) == FNS_UMUL)
+		||(INTFNS_STMT_TYPE(stmt) == FNS_SMUL))
+	{		
+		if(single_imm_use(lhs, &use_p, &use))
+		{
+			if((gimple_code(use) == GIMPLE_ASSIGN)
+				&&(INTFNS_STMT_TYPE(use) == INTFNS_STMT_PTR_PLUS))
+			{
+				if(INTFNS_STMT_TYPE(stmt) == FNS_UMUL)
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_UMUL_OFFSET;
+				else
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SMUL_OFFSET;
+			}
+		}
+	}
+	/* stmt is relation-op. it would turn into if/while if any of its use is for if/while. */
+	else if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)
+	{				
+		// c = a relation-op b;
+		if(single_imm_use(lhs, &use_p, &use))
+		{
+			if((gimple_code(use) == GIMPLE_ASSIGN)
+				||(gimple_code(use) == GIMPLE_COND))
+			{
+				if((INTFNS_STMT_TYPE(use) == INTFNS_STMT_IF)
+					||(INTFNS_STMT_TYPE(use) == INTFNS_STMT_WHILE))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_TYPE(use);
+			}
+		}
+	}
+	else
+		return;
+}
+
+/* we only consider the following forms of |, & and % as potential sanitization ops.
+form1: 	'x & const', 'y % const', 'x & const-ops', 'y % const-op';
+		'x & var' and 'y % var', where 'var' can be determined as const or const-range.
+form2: if(x|y), if(x&y)
+form3: 'x & array[inx]' and 'x % array[inx]', where 'array' is a const array
+form4: 'x & (1 << N - 1)'
+form5: 'x % (table-size / sizeof)'
+
+as for the form3, we can take the code from 164.gzip:inflate.c:516 as an example.
+	ml = mask_bits[xx];
+	x & ml;
+the corresponding ssa code is :
+	D.tmp = mask_bits[xx]; (rhs is a array-ref node)
+	ml_53 = D.tmp;
+	x_yyy = x & ml_53;
+
+as for the form5, we can take the code from 254.gap:idents.c:166 as an example.
+	k%(table_size / sizeof(xxx))
+the corresponding ssa code is :
+	D_1 = table_size;
+	D_2 = D_1 / 4; (here, sizeof(xx) is a constant)
+	k_4 = k_3 % D_2;
+*/
+void intfns_mark_sanitizations(gimple stmt)
+{	
+	/* refer to tree-flow.h, gimple.h and tree-flow-inline.h */	
+	tree lhs = gimple_assign_lhs (stmt);
+	enum tree_code rhs_code = gimple_assign_rhs_code(stmt);
+
+	if((rhs_code == BIT_IOR_EXPR)
+		|| (rhs_code == BIT_AND_EXPR)
+		|| (rhs_code == TRUNC_MOD_EXPR))
+		;
+	else
+		return;
+	
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	tree rhs2 = gimple_assign_rhs2(stmt);
+	
+	gimple use;
+	use_operand_p use_p;
+	gimple def;
+	tree def_rhs;
+
+	// for | stmt, we only check if(x|y)
+	if(rhs_code == BIT_IOR_EXPR)
+	{
+		// if(x|y)
+		if(single_imm_use(lhs, &use_p, &use))
+		{
+			if((gimple_code(use) == GIMPLE_ASSIGN)
+				||(gimple_code(use) == GIMPLE_COND))
+			{
+				if((INTFNS_STMT_TYPE(use) == INTFNS_STMT_IF)
+					||(INTFNS_STMT_TYPE(use) == INTFNS_STMT_WHILE))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_OR_IF;
+			}
+		}
+	}
+	// for & stmt, we check x&const, x&array, if(x&y), x&1<<n-1
+	else if(rhs_code == BIT_AND_EXPR)
+	{
+		if((TREE_CODE(rhs1) == INTEGER_CST)
+			||(TREE_CODE(rhs2) == INTEGER_CST))
+			INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_CONST;
+		else
+		{
+			//------------------------------x&array
+			// check the rhs2 first
+			def = SSA_NAME_DEF_STMT(rhs2);
+			if(gimple_code(def)== GIMPLE_ASSIGN)
+			{
+				if(gimple_assign_rhs_code(def) == ARRAY_REF)
+				{	
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_ARRAY;
+					return;
+				}
+				else if((gimple_assign_rhs_code(def) == SSA_NAME)
+					|| (gimple_assign_rhs_code(def) == NOP_EXPR))
+				{
+					def_rhs = gimple_assign_rhs1(def);
+					def = SSA_NAME_DEF_STMT(def_rhs);
+					if((gimple_code(def)== GIMPLE_ASSIGN)
+						&& (gimple_assign_rhs_code(def) == ARRAY_REF))
+					{
+						INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_ARRAY;
+						return;
+					}
+				}
+				else
+					;
+			}
+			
+			// check the rhs1 first
+			def = SSA_NAME_DEF_STMT(rhs1);
+			if(gimple_code(def)== GIMPLE_ASSIGN)
+			{
+				if(gimple_assign_rhs_code(def) == ARRAY_REF)
+				{	
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_ARRAY;
+					return;
+				}
+				else if((gimple_assign_rhs_code(def) == SSA_NAME)
+					|| (gimple_assign_rhs_code(def) == NOP_EXPR))
+				{
+					def_rhs = gimple_assign_rhs1(def);
+					def = SSA_NAME_DEF_STMT(def_rhs);
+					if((gimple_code(def)== GIMPLE_ASSIGN)
+						&& (gimple_assign_rhs_code(def) == ARRAY_REF))
+					{
+						INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_ARRAY;
+						return;
+					}
+				}
+				else
+					;
+			}
+
+			//------------------------------if(x&y)
+			if(single_imm_use(lhs, &use_p, &use))
+			{
+				if((gimple_code(use) == GIMPLE_ASSIGN)
+					||(gimple_code(use) == GIMPLE_COND))
+				{
+					if((INTFNS_STMT_TYPE(use) == INTFNS_STMT_IF)
+						||(INTFNS_STMT_TYPE(use) == INTFNS_STMT_WHILE))
+					{
+						INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_IF;
+						return;
+					}
+				}
+			}
+
+			//------------------------------x& 1<<N -1
+			// usually, we only check rhs2
+			def = SSA_NAME_DEF_STMT(rhs2);
+			if(gimple_code(def)== GIMPLE_ASSIGN)
+			{
+				if(gimple_assign_rhs_code(def) == LSHIFT_EXPR)
+				{	// def = 1 << N
+					def_rhs = gimple_assign_rhs1(def);
+					if(TREE_CODE(def_rhs) == INTEGER_CST)
+					{
+						INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_MASK;
+						return;
+					}
+				}
+				else if(gimple_assign_rhs_code(def) == MINUS_EXPR)
+				{	// def = D.tmp - 1
+					def_rhs = gimple_assign_rhs2(def);
+					if(TREE_CODE(def_rhs) == INTEGER_CST)
+					{
+						// find the DEF of D.tmp
+						def_rhs = gimple_assign_rhs1(def);
+						def = SSA_NAME_DEF_STMT(def_rhs);
+						if((gimple_code(def)== GIMPLE_ASSIGN)
+							&& (gimple_assign_rhs_code(def) == LSHIFT_EXPR))
+						{
+							INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_AND_MASK;
+							return;
+						}
+					}					
+				}
+				else
+					;
+			}			
+		}
+	}
+	// for % stmt, we check x%const, x%array, x%table-size/sizeof
+	else
+	{	
+		// x % const
+		if(TREE_CODE(rhs2) == INTEGER_CST)
+			INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_MOD_CONST;
+		else
+		{
+			// x % array
+			def = SSA_NAME_DEF_STMT(rhs2);
+			if(gimple_code(def)== GIMPLE_ASSIGN)
+			{
+				if(gimple_assign_rhs_code(def) == ARRAY_REF)
+				{	
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_MOD_ARRAY;
+					return;
+				}
+				else if((gimple_assign_rhs_code(def) == SSA_NAME)
+					|| (gimple_assign_rhs_code(def) == NOP_EXPR))
+				{
+					def_rhs = gimple_assign_rhs1(def);
+					def = SSA_NAME_DEF_STMT(def_rhs);
+					if((gimple_code(def)== GIMPLE_ASSIGN)
+						&& (gimple_assign_rhs_code(def) == ARRAY_REF))
+					{
+						INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_MOD_ARRAY;
+						return;
+					}
+				}
+				else
+					;
+			}
+
+			// x % table-size/sizeof
+			def = SSA_NAME_DEF_STMT(rhs2);
+			if((gimple_code(def)== GIMPLE_ASSIGN)
+				&& (gimple_assign_rhs_code(def) == TRUNC_DIV_EXPR))
+			{
+				def_rhs = gimple_assign_rhs2(def);
+				if(TREE_CODE(def_rhs) == INTEGER_CST)
+				{
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SANTZ_MOD_SIZEOF;
+					return;
+				}
+			}		
+		}
+	}
+}
+
+/* to select the unused op and reverse op, here, stmt is +, -, * and <<.
+c = a op b.
+1. if c has no use,
+	we select this stmt as unused op.
+
+2. for c = a * b, or c = a << b;
+if c has several use points, and one use is 'c/a != b' or 'c>>a != b'
+	we select this stmt as reverse op.	*/
+void intfns_mark_universal_santz(gimple stmt)
+{	
+	/* refer to tree-flow.h, gimple.h and tree-flow-inline.h */	
+	tree lhs = gimple_assign_lhs (stmt);
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	tree rhs2 = gimple_assign_rhs2(stmt);
+	
+	gimple use;
+	tree use_rhs1, use_rhs2;
+	imm_use_iterator iter;
+
+	/* c = a arith-op b;
+	if c has no imm-use*/
+	if(has_zero_uses(lhs))
+	{
+		INTFNS_INTOP_SANTZD_TYPE(stmt) = INTFNS_INTOP_SANTZD_UNUSED;
+		INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+		return;
+	}
+
+	/* for c = a * b or c = a << b */
+	if((INTFNS_STMT_TYPE(stmt) >= FNS_UMUL)
+		&& (INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+	{
+		// traversal each use of lhs
+		FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+			if((gimple_code(use)== GIMPLE_ASSIGN)
+				&& ((gimple_assign_rhs_code(use) == TRUNC_DIV_EXPR) 
+				|| (gimple_assign_rhs_code(use) == RSHIFT_EXPR)))
+			{
+				use_rhs1 = gimple_assign_rhs1(use);
+				use_rhs2 = gimple_assign_rhs2(use);
+				
+				// for c = a * b, we should check whether the 'use' is c/a or c/b
+				if(((INTFNS_STMT_TYPE(stmt) == FNS_UMUL)
+					|| (INTFNS_STMT_TYPE(stmt) == FNS_SMUL))
+					&& (gimple_assign_rhs_code(use) == TRUNC_DIV_EXPR))
+				{	
+					if((use_rhs1 == lhs)
+						&& ((use_rhs2 == rhs1)
+						|| (use_rhs2 == rhs2)))
+					{
+						INTFNS_INTOP_SANTZD_TYPE(stmt) = INTFNS_INTOP_SANTZD_REVERSE;
+						INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+						BREAK_FROM_IMM_USE_STMT (iter)
+					}
+				}
+				
+				// for c = a << b; we should check whether the 'use' is c >> b
+				if(((INTFNS_STMT_TYPE(stmt) == FNS_USHL)
+					|| (INTFNS_STMT_TYPE(stmt) == FNS_SSHL))
+					&& (gimple_assign_rhs_code(use) == RSHIFT_EXPR))
+				{
+					if((use_rhs1 == lhs)
+						&& (use_rhs2 == rhs2))
+					{
+						INTFNS_INTOP_SANTZD_TYPE(stmt) = INTFNS_INTOP_SANTZD_REVERSE;
+						BREAK_FROM_IMM_USE_STMT (iter)
+					}
+				}					
+			}
+
+		return;
+	}
+}
+
+/* to identify potential Santz-postcond,
+i.e., those integer operations where postconditon tests follow them.
+	S1. c = a +s b;
+		a>0 && b>0 && c<0 or a<0 && b<0 && c>0
+	S2. c= a +u b;
+		c<a or c<b
+	S3. c = a -s b
+		a<0 && b>0 && c>0 or a>0 && b<0 && c<0
+	S4. c = a -u b
+		a<b
+	S5. c = a * b
+		x!=0 && c/a != b
+	S6. c = a << b
+		c >> b != a
+
+To be honest, we pay a lot of attention on S2, S4 and S5, as they are much more common.
+	for S1, S3, their postcondtion test are very complicated.
+	In real world, such complicated check are rarely utilized by programmers.
+	Besides, S6 is also rare in the context of IO2BO.
+
+If we identify such integer operations, we mark them 
+by setting INTFNS_INTOP_IO2BO_SANTZ_POSTCOND. */
+void intfns_mark_io2bo_identify_santz_postcond(gimple stmt)
+{	
+	/* refer to tree-flow.h, gimple.h and tree-flow-inline.h */	
+	tree lhs = gimple_assign_lhs (stmt);
+	tree rhs1 = gimple_assign_rhs1(stmt);
+	tree rhs2 = gimple_assign_rhs2(stmt);
+	
+	gimple use;
+	tree use_rhs1, use_rhs2;
+	imm_use_iterator iter;
+
+	/* c = a arith-op b;
+	if c has no imm-use*/
+	if(has_zero_uses(lhs))
+	{
+		INTFNS_INTOP_SANTZD_TYPE(stmt) = INTFNS_INTOP_SANTZD_UNUSED;
+		INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+		return;
+	}
+
+	/* for c = a * b or c = a << b */
+	if((INTFNS_STMT_TYPE(stmt) >= FNS_UMUL)
+		&& (INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+	{
+		// traversal each use of lhs
+		FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+			if((gimple_code(use)== GIMPLE_ASSIGN)
+				&& ((gimple_assign_rhs_code(use) == TRUNC_DIV_EXPR) 
+				|| (gimple_assign_rhs_code(use) == RSHIFT_EXPR)))
+			{
+				use_rhs1 = gimple_assign_rhs1(use);
+				use_rhs2 = gimple_assign_rhs2(use);
+				
+				// for c = a * b, we should check whether the 'use' is c/a or c/b
+				if(((INTFNS_STMT_TYPE(stmt) == FNS_UMUL)
+					|| (INTFNS_STMT_TYPE(stmt) == FNS_SMUL))
+					&& (gimple_assign_rhs_code(use) == TRUNC_DIV_EXPR))
+				{	
+					if((use_rhs1 == lhs)
+						&& ((use_rhs2 == rhs1)
+						|| (use_rhs2 == rhs2)))
+					{
+						INTFNS_INTOP_SANTZD_TYPE(stmt) = INTFNS_INTOP_SANTZD_REVERSE;
+						INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+						BREAK_FROM_IMM_USE_STMT (iter)
+					}
+				}
+				
+				// for c = a << b; we should check whether the 'use' is c >> b
+				if(((INTFNS_STMT_TYPE(stmt) == FNS_USHL)
+					|| (INTFNS_STMT_TYPE(stmt) == FNS_SSHL))
+					&& (gimple_assign_rhs_code(use) == RSHIFT_EXPR))
+				{
+					if((use_rhs1 == lhs)
+						&& (use_rhs2 == rhs2))
+					{
+						INTFNS_INTOP_SANTZD_TYPE(stmt) = INTFNS_INTOP_SANTZD_REVERSE;
+						BREAK_FROM_IMM_USE_STMT (iter)
+					}
+				}					
+			}
+
+		return;
+	}
+}
+
+
+/* do statistics for santization ops */
+void intfns_sanitization_count(struct intfns_static_facts * sta)
+{
+	if(sta == NULL)
+		return;
+
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt;
+
+	FOR_EACH_BB(bb)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		stmt = gsi_stmt(gsi);
+  		if(stmt != NULL)
+  		{
+			if(gimple_code(stmt)== GIMPLE_ASSIGN)
+			{
+				if((INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+					&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+				{
+					if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_UNUSED)
+						sta->intop_santz_unused ++;
+
+					if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_REVERSE)
+						sta->intop_santz_reverse ++;
+				}
+
+				if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_NARROW)
+					sta->intop_narrow ++;
+
+				
+				if((INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_SANTZ_AND_CONST)
+				&&(INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SANTZ_MOD_VAR_CONST))
+				{
+					sta->intop_narrow ++;
+					sta->intop_santz_const_narrow ++;
+
+					if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_AND_CONST)
+						sta->intop_santz_and_const ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_MOD_CONST)
+						sta->intop_santz_mod_const ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_AND_ARRAY)
+						sta->intop_santz_and_array ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_MOD_ARRAY)
+						sta->intop_santz_mod_array ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_AND_IF)
+						sta->intop_santz_and_if ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_OR_IF)
+						sta->intop_santz_or_if ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_AND_MASK)
+						sta->intop_santz_and_mask ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_MOD_SIZEOF)
+						sta->intop_santz_mod_sizeof ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_AND_VAR_CONST)
+						sta->intop_santz_and_var_const ++;
+					else if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SANTZ_MOD_VAR_CONST)
+						sta->intop_santz_mod_var_const ++;
+					else
+						;
+				}
+			}
+			else if(gimple_code(stmt) == GIMPLE_CALL)
+			{
+				if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UNCRITICAL_LIB)
+					|| (INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_EXTERNAL_UNCRITICAL))
+					sta->intop_santz_uncritical ++;
+			}
+			else
+				;
+  		}
+	}
+}
+
+/* dump the location and stmt-type of the stmts marked by intfns. */
+void dump_marked_stmt(void)
+{
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt;
+	FILE* file;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_marked_stmt.txt", "a");
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+
+	/* travesal each stmt in current func. */	
+	FOR_EACH_BB(bb)
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+    	{    	
+    		stmt = gsi_stmt(gsi);
+	  		if(stmt != NULL)
+	  		{
+	  			switch (gimple_code (stmt))	/* to check the type of stmt */
+	  			{
+	  			case GIMPLE_ASSIGN:
+				case GIMPLE_COND:
+				case GIMPLE_CALL:
+				case GIMPLE_RETURN:
+					switch(INTFNS_STMT_TYPE(stmt))
+					{
+					case FNS_UADD:
+						fprintf(file, "\tunsigned add at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_SADD:
+						fprintf(file, "\tsigned add at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_USUB:
+						fprintf(file, "\tunsigned sub at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_SSUB:
+						fprintf(file, "\tsigned sub at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_UMUL:
+						fprintf(file, "\tunsigned mul at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_SMUL:
+						fprintf(file, "\tsigned mul at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_USHL:
+						fprintf(file, "\tunsigned shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case FNS_SSHL:
+						fprintf(file, "\tsigned shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_UMUL_OFFSET:
+						fprintf(file, "\tumult-offset at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SMUL_OFFSET:
+						fprintf(file, "\tsmult-offset at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SHL_CONST:
+						fprintf(file, "\tconst shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_PTR_PLUS:
+						fprintf(file, "\tpointer plus at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SINK_LIB:
+						fprintf(file, "\tsink lib call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_UNCRITICAL_LIB:
+						fprintf(file, "\tuncritical lib call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_NORMAL_FUNC:
+						fprintf(file, "\tnormal func call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_EXTERNAL_FUNC:
+						fprintf(file, "\texternal func call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_EXTERNAL_SINK:
+						fprintf(file, "\texternal sink at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_EXTERNAL_UNCRITICAL:
+						fprintf(file, "\texternal uncritical call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_IF:
+						fprintf(file, "\tif-cond at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));
+						//fprintf(file, "\t\tgimple-code:%s, tree-code:%s\n", gimple_code_name[gimple_code (stmt)],tree_code_name[gimple_cond_code(stmt)]);
+						break;
+					case INTFNS_STMT_WHILE:
+						fprintf(file, "\twhile-cond at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_NARROW:
+						fprintf(file, "\tnarrow-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_DENIED:
+						fprintf(file, "\tdenied-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_RET:
+						fprintf(file, "\tret-stmt at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_PROPAGATE:
+						fprintf(file, "\tpropagate-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_ARRAY_REF:
+						fprintf(file, "\tarray-ref at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_RELATION:
+						fprintf(file, "\trelation-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_VAR_PROPAGATE:
+						fprintf(file, "\tvar-propagate-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_AND_CONST:						 
+						fprintf(file, "\tsanitization-and-const at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_MOD_CONST:
+						fprintf(file, "\tsanitization-mod-const at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_AND_ARRAY:
+						fprintf(file, "\tsanitization-and-array at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_MOD_ARRAY:
+						fprintf(file, "\tsanitization-mod-array at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_AND_IF:
+						fprintf(file, "\tsanitization-and-if at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_OR_IF:
+						fprintf(file, "\tsanitization-or-if at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_AND_MASK:
+						fprintf(file, "\tsanitization-and-mask at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_MOD_SIZEOF:
+						fprintf(file, "\tsanitization-mod-sizeof at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_AND_VAR_CONST:
+						fprintf(file, "\tsanitization-and-var-const at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_SANTZ_MOD_VAR_CONST:
+						fprintf(file, "\tsanitization-mod-var-const at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					case INTFNS_STMT_ADDRESS_GLOBAL:
+						fprintf(file, "\tlhs is global var at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+					default:
+						break;
+					}
+					break;
+				case GIMPLE_PHI:
+					fprintf(file, "\phi-stmt at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));
+					break;	
+				default:
+					break;
+	  			}
+	  		}
+		}
+
+	fprintf(file, "-------------------------------------\n\n");
+	fclose(file);
+	return;
+}
+
+/* execution function for our pass */
+static unsigned int
+execute_intfns_mark_stmt (void)
+{
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	FILE* file;
+	int ix, iy;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_mark_stmt.txt", "a");
+	fprintf(file,"INTFNS-mark-stmt for %s(): \n", 
+		lang_hooks.decl_printable_name(current_function_decl, 2));
+	if((DECL_STRUCT_FUNCTION(current_function_decl) == NULL) || (cfun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}
+
+	// to analyze the designated function particularly.
+	// spec2000 164.gzip: fill_window, inflate_codes
+	// sepc2000 175.vpr: my_irand, my_frand, get_serial_num
+	// spec2000 176.gcc:get_identifier, make_signed_type, exact_log2_wide, const_hash, integer_ok_for_set,
+					// canon_hash, nonzero_bits, synth_mult, invert_mod2n, lex,
+					//integer_pow2p, rtvec_alloc
+	// spec2000 186.crafty: Iterate, Evaluate, Random32
+	// spec2000 197.parser: initialize_memory, and_connector_hash, andable_hash, hash_S, string_hash
+					//connector_hash, power_hash, fast_match_hash, hash
+	// spec2000 253.perlbmk: Perl_hv_fetch, Perl_hv_fetch_ent, Perl_hv_store, Perl_hv_delete, 
+					//Perl_hv_delete_ent, Perl_hv_exists_ent, MD5Transform
+	// spec2000 254.gap: FindIdent, FindRecname
+	// spec2000 255.vortex: Ut_Random
+	//if((strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "simplify_comparison") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "inflate_codes") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "Perl_hv_fetch") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "FindIdent") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "andable_hash") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "Perl_hv_exists_ent") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "MD5Transform") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "lex") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "integer_pow2p") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "rtvec_alloc") == 0)
+	/*	)
+		;
+	else
+	{
+		fprintf(file, " PASS!!!\n");
+		fclose(file);
+		return 0;
+	}*/
+	
+	fprintf(file, "\t>>begin\t");
+
+	/* 1. mark the stmt-type through a forward-analysis for the first time. */
+	gimple stmt, stmt_start;
+	
+	FOR_EACH_BB(bb)
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+    	{    	
+    		stmt = gsi_stmt(gsi);
+	  		if(stmt != NULL)
+				intfns_mark_stmt(stmt);
+		}
+	
+	fprintf(file, ">>forward mark\t");
+	
+	/* 2 mark the if/while/mul-offset through a backward-analysis. */
+	FOR_EACH_BB_REVERSE(bb)
+	{
+		// get the first stmt in bb
+		gsi = gsi_start_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt_start = gsi_stmt(gsi);
+
+		// get the last stmt in bb
+		gsi = gsi_last_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt = gsi_stmt(gsi);
+		
+		// travesal the stmt in bb backward.
+		while(stmt != stmt_start)
+		{
+			/* filter all the relation/mul stmt*/
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+				&&((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)
+				||(INTFNS_STMT_TYPE(stmt) == FNS_SMUL)
+				||(INTFNS_STMT_TYPE(stmt) == FNS_UMUL)))
+				intfns_backward_mark_cond_offset(stmt);
+			gsi_prev(&gsi);
+			stmt = gsi_stmt(gsi);
+		}
+		// here, stmt is stmt-start
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+			&&((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)
+			||(INTFNS_STMT_TYPE(stmt) == FNS_SMUL)
+			||(INTFNS_STMT_TYPE(stmt) == FNS_UMUL)))
+			intfns_backward_mark_cond_offset(stmt);
+	}
+
+	fprintf(file, ">>backward mark\t");
+
+	/* 3. to identify all the sanitization ops.
+	for normal intfns: these sanitization ops are selected from narrow-op.
+	while for intfns-santz, we will do more 2 things.
+		1. unused op
+		2. reverse op */
+	FOR_EACH_BB(bb)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{    	
+		stmt = gsi_stmt(gsi);
+  		if((stmt != NULL)
+			&& (gimple_code (stmt) == GIMPLE_ASSIGN))
+  		{
+			if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_NARROW)
+				intfns_mark_sanitizations(stmt);
+
+			if((flag_intfns_santz)
+				&& (INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&& (INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+				intfns_mark_universal_santz(stmt);
+
+			// for io2bo detection, we wanna identify all santz-postcond
+			if((flag_intfns_io2bo)
+				&& (INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&& (INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+				;//intfns_mark_io2bo_identify_santz_postcond(stmt);
+  		}
+	}
+
+	/* count all the sanitizations */
+	struct intfns_static_facts * sta;
+	sta = INTFNS_INFO_STA_FUN(cfun);
+	intfns_sanitization_count(sta);
+	fprintf(file, ">>sanitization mark\t");
+	
+	/* 4. helper: dump all the noted stmt. */
+	dump_marked_stmt();
+	
+	// dump each stmt code for cfun.
+	/*fprintf(file, "\n");
+	FOR_EACH_BB(bb)
+	{	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+    	{    	
+    		stmt = gsi_stmt(gsi);
+	  		if(stmt != NULL)
+				{
+					print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+					fprintf(file, "gimple-code: %s", gimple_code_name[gimple_code(stmt)]);
+
+					if(gimple_code(stmt) == GIMPLE_ASSIGN)
+						fprintf(file, "\tlhs: %s, rhs: %s",
+							tree_code_name[TREE_CODE(gimple_assign_lhs(stmt))],
+							tree_code_name[gimple_assign_rhs_code(stmt)]);
+					/*if((gimple_code(stmt) == GIMPLE_ASSIGN)
+						&&(TREE_CODE(gimple_assign_lhs(stmt)) != SSA_NAME))
+					{	
+						fprintf(file, "\n\tvdef:");
+						imm_use_iterator iter;
+						gimple use_stmt;
+						tree vdef = gimple_vdef (stmt);
+
+						if (!vdef|| TREE_CODE (vdef) != SSA_NAME)
+						    fprintf(file, "\t no sense.\n");
+						else
+						{
+							fprintf(file, "\t to list all the use\n");
+							FOR_EACH_IMM_USE_STMT (use_stmt, iter, gimple_vdef (stmt))
+							if(use_stmt != NULL)
+							{	
+								fprintf(file, "\tvuse:");
+								print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+							}
+						}
+					}
+					if((gimple_code(stmt) == GIMPLE_ASSIGN)
+						&& (gimple_assign_rhs_code(stmt) == TRUNC_MOD_EXPR))
+					{
+						fprintf(file, "\trhs1: %s, rhs2: %s",
+							tree_code_name[TREE_CODE(gimple_assign_rhs1(stmt))],
+							tree_code_name[TREE_CODE(gimple_assign_rhs2(stmt))]);
+						if(TREE_CONSTANT(gimple_assign_rhs2(stmt)))
+							fprintf(file, " const\t");
+						else
+							fprintf(file, " not const\t");
+					}*/
+	//				fprintf(file, "\n\n");
+	//			}
+	//	}
+	//}
+		
+	/* dump all the lib-sinks for intfns-io2bo*/
+	if(flag_intfns_io2bo)
+	{
+		int count = 0;
+		FOR_EACH_BB(bb)
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+    	{
+    		stmt = gsi_stmt(gsi);
+	  		if((stmt != NULL)
+				&& (gimple_code(stmt) == GIMPLE_CALL)
+				&& ((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SINK_LIB)
+				|| (INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_EXTERNAL_SINK)))
+			count ++;
+		}
+
+		if(count > 0)
+		{
+			FILE * file_dump = fopen("/tmp/log_intfns_io2bo_marked_sink.txt", "a");
+			fprintf(file_dump, "%d\n", count);
+			fclose(file_dump);
+		}
+	}
+		
+	/*-----------------------------------------------------------------------------*/	
+	fprintf(file, ">>finish\n");
+	fclose(file);	
+	return 1;
+}
+
+/* gate for our pass, invoked by -fintfns */
+static bool
+gate_intfns_mark_stmt (void)
+{
+	return flag_intfns;
+}
+
+/* pass_intfns_mark_stmt definition */
+struct gimple_opt_pass pass_intfns_mark_stmt =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_mark_stmt",					/* name */
+  		gate_intfns_mark_stmt,				/* gate */
+  		execute_intfns_mark_stmt,			/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_MARK_STMT,		/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*-----------------------------------intfns-santz------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* the key process of intfns santz: 
+	to santz all the integer ops, which can be post-dominated by santization ops. */
+void intfns_santz_intop(FILE * file, gimple propagate, gimple src)
+{
+	tree lhs;
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	/* if src can flow into critical use points, return. */
+	if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_FAIL)
+		return;
+	
+	// src is an being-analyzed int-op, and progate is an convert-op, casting-op or phi-node
+	if(gimple_code(propagate) == GIMPLE_PHI)
+		lhs = gimple_phi_result(propagate);
+	else if(gimple_code(propagate) == GIMPLE_ASSIGN)
+		lhs = gimple_assign_lhs (propagate);
+	else
+		return;
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{	
+			// check whether use-stmt is array[lhs] = xxxx.
+			use_lhs= gimple_assign_lhs(use_stmt);		
+			if((TREE_CODE(use_lhs) == ARRAY_REF)
+				&&(TREE_OPERAND(use_lhs, 1) == lhs))
+			{	// src is used at array-index, FAIL
+				INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+				BREAK_FROM_IMM_USE_STMT (iter)				
+			}
+
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);
+
+			// for critical use point, set the santzd type as FAIL
+			if((stmt_type == INTFNS_STMT_ADDRESS_GLOBAL)
+				||(stmt_type == INTFNS_STMT_SMUL_OFFSET)
+				||(stmt_type == INTFNS_STMT_UMUL_OFFSET)
+				||(stmt_type == INTFNS_STMT_PTR_PLUS)
+				||(stmt_type == INTFNS_STMT_IF)
+				||(stmt_type == INTFNS_STMT_WHILE)
+				||(stmt_type == INTFNS_STMT_ARRAY_REF)
+				)			
+			{	// src is used at global var, FAIL				
+				INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+				BREAK_FROM_IMM_USE_STMT (iter)				
+			}
+			// for prop-op or narrow-op, we recursively call our santz-function
+			else if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_NARROW))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+				
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_santz_intop(file, use_stmt, src);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+
+					// check the result of propagate. 
+					// if src has been analyzed as flowing into critical use points, return
+					if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_FAIL)
+						BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			// for intop, we should update our santzd-type			
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// check been-analyzed
+				if((INTFNS_INTOP_STATUS(use_stmt) == INTFNS_INTOP_BEEN_ANALYZED)
+					&&(INTFNS_INTOP_SANTZD_TYPE(use_stmt)!= INTFNS_INTOP_SANTZD_INIT))
+				{
+					if(INTFNS_INTOP_SANTZD_TYPE(use_stmt) == INTFNS_INTOP_SANTZD_FAIL)
+					{
+						INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+						BREAK_FROM_IMM_USE_STMT (iter)	
+					}
+					else if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_INIT)
+						INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_TYPE(use_stmt);
+					else
+					{
+						if((INTFNS_INTOP_SANTZD_TYPE(use_stmt) == INTFNS_INTOP_SANTZD_INIT)
+							||(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_TYPE(use_stmt)))
+							;
+						else
+							INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_HYBRID;
+					}					
+				}
+			}
+			// santz-const-narrow
+			else if((stmt_type >= INTFNS_STMT_SANTZ_AND_CONST)
+				&& (stmt_type <= INTFNS_STMT_SANTZ_MOD_VAR_CONST))
+			{
+				if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_INIT)
+					INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_CONST_NARROW;
+				else if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_CONST_NARROW)
+					;
+				else
+					INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_HYBRID;
+			}
+			// FIXME: here
+			else
+			{
+				//INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+				//BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_COND)
+		{
+			INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{			
+			// uncritical call
+			if((INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_UNCRITICAL_LIB)
+				||(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_UNCRITICAL))
+			{
+				if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_INIT)
+					INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_UNCRITICAL;
+				else if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_UNCRITICAL)
+					;
+				else
+					INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_HYBRID;
+			}
+			else
+			{
+				INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_RETURN)
+		{
+			INTFNS_INTOP_SANTZD_TYPE(src) = INTFNS_INTOP_SANTZD_FAIL;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_santz_intop(file, use_stmt, src);
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+
+				// check the result of propagate. 
+				// if src has been analyzed as flow into critical use points, return
+				if(INTFNS_INTOP_SANTZD_TYPE(src) == INTFNS_INTOP_SANTZD_FAIL)
+					BREAK_FROM_IMM_USE_STMT (iter)		
+			}
+			else
+				;
+		}
+		else
+			;
+	}
+	return;
+}
+
+// do statistics
+void intfns_santz_count(struct intfns_static_facts * sta)
+{
+	if(sta == NULL)
+		return;
+
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt;
+
+	FOR_EACH_BB(bb)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		stmt = gsi_stmt(gsi);
+  		if(stmt != NULL)
+  		{
+  			sta->stmt_total ++;
+			if((gimple_code(stmt)== GIMPLE_ASSIGN)
+				&&
+				(((INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+				||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_UMUL_OFFSET)
+				||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SMUL_OFFSET)))
+			{
+				sta->intop_total ++;
+
+				if((INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_UMUL_OFFSET)
+					||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SMUL_OFFSET))
+				{
+					sta->intop_mul_offset ++;
+					continue;
+				}
+				
+				if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_UNUSED)
+					sta->intop_santzd_unused ++;
+				else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_UNCRITICAL)
+					sta->intop_santzd_uncritical ++;
+				else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_CONST_NARROW)
+					sta->intop_santzd_const_narrow ++;
+				else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_REVERSE)
+					sta->intop_santzd_reverse ++;
+				else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_HYBRID)
+					sta->intop_santzd_hybrid ++;
+				else
+					;
+			}
+  		}
+	}
+}
+
+/* dump all the santzd intop into fliles. */
+void dump_santzd_intop()
+{
+	// open a file
+	FILE * file = fopen("/tmp/log_intfns_santzd_intop.txt", "a");
+
+	// give the name of current func
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt;
+
+	FOR_EACH_BB(bb)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		stmt = gsi_stmt(gsi);
+  		if((stmt != NULL)
+			&& (gimple_code(stmt)== GIMPLE_ASSIGN)
+			&& (INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+			&& (INTFNS_STMT_TYPE(stmt) <= FNS_SSHL)
+			&& (INTFNS_INTOP_SANTZD_TYPE(stmt) >= INTFNS_INTOP_SANTZD_UNUSED)
+			&& (INTFNS_INTOP_SANTZD_TYPE(stmt) <= INTFNS_INTOP_SANTZD_HYBRID)
+			)
+		{
+			// print the arith-TYPE of stmt
+			if(INTFNS_STMT_TYPE(stmt) == FNS_UADD)
+				fprintf(file, "\tunsigned add ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_SADD)
+				fprintf(file, "\tsigned add ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_USUB)
+				fprintf(file, "\tunsigned sub ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_SSUB)
+				fprintf(file, "\tsigned sub ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_UMUL)
+				fprintf(file, "\tunsigned mul ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_SMUL)
+				fprintf(file, "\tsigned mul ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_USHL)
+				fprintf(file, "\tunsigned shl ");
+			else if(INTFNS_STMT_TYPE(stmt) == FNS_SSHL)
+				fprintf(file, "\tsigned add ");
+			else
+			{
+				fprintf(file, "\tERROR\n");
+				return;
+			}
+
+			// print the location of stmt
+			fprintf(file, "@%s:%d -->> santzd by ", gimple_filename(stmt), gimple_lineno(stmt));
+
+			if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_UNUSED)
+				fprintf(file, "unused\n");
+			else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_UNCRITICAL)
+				fprintf(file, "uncritical\n");
+			else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_CONST_NARROW)
+				fprintf(file, "const narrow\n");
+			else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_REVERSE)
+				fprintf(file, "reverse\n");
+			else if(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_HYBRID)
+				fprintf(file, "hybrid\n");
+			else
+				;			
+  		}  		
+	}
+	
+	// finish the dump
+	fprintf(file, "\n\n");
+	fclose(file);
+	return;	
+}
+
+
+/* execution function for pass-intfns-santz */
+static unsigned int
+execute_intfns_santz (void)
+{
+	/* local vars*/	
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	struct intfns_static_facts * sta;
+	FILE* file;
+	int ix, iy;
+	gimple stmt, stmt_start;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_santz.txt", "a");
+	fprintf(file,"INTFNS-santz for %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+	if((DECL_STRUCT_FUNCTION(current_function_decl) == NULL) || (cfun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}
+
+	/* do some initialization */
+	sta = INTFNS_INFO_STA_FUN(cfun);							// point to the struct to store statistics info
+	strncpy(sta->func_name, lang_hooks.decl_printable_name(current_function_decl, 2), 128);	
+	fprintf(file, "\t>>begin\t");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 1. santz the intop which could flow into our pre-defined santization ops.*/
+	/* this process is a backward analysis. */
+	FOR_EACH_BB_REVERSE(bb)
+	{
+		// get the first stmt in bb
+		gsi = gsi_start_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt_start = gsi_stmt(gsi);
+
+		// get the last stmt in bb
+		gsi = gsi_last_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt = gsi_stmt(gsi);
+		
+		// travesal the stmt in bb backward.
+		while(stmt != stmt_start)
+		{	
+			/* filter all the intop stmt*/
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+				&&(INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL)
+				&&(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_INIT))
+			{
+				if(INTFNS_INTOP_STATUS(stmt) == INTFNS_INTOP_UN_ANALYZED)
+				{
+					INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEING_ANALYZED;
+					intfns_santz_intop(file, stmt, stmt);
+					INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+				}
+			}
+			gsi_prev(&gsi);
+			stmt = gsi_stmt(gsi);
+		}
+		
+		// here, stmt is stmt-start
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+			&&(INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+			&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL)
+			&&(INTFNS_INTOP_SANTZD_TYPE(stmt) == INTFNS_INTOP_SANTZD_INIT))
+		{
+			if(INTFNS_INTOP_STATUS(stmt) == INTFNS_INTOP_UN_ANALYZED)
+			{
+				INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEING_ANALYZED;
+				intfns_santz_intop(file, stmt, stmt);
+				INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+			}
+		}
+	}
+	fprintf(file, ">>santz\t");
+
+	// counter the insn
+	intfns_santz_count(sta);
+	
+	/* dump the santzd intops */
+	dump_santzd_intop();
+	
+	/*-----------------------------------------------------------------------------*/	
+	fprintf(file, ">>finish\n");
+	fclose(file);	
+	return 1;
+}
+
+
+/* gate for our pass, invoked by -fintfns and -fintfns-santz */
+static bool
+gate_intfns_santz (void)
+{
+	return (flag_intfns && flag_intfns_santz);
+}
+
+
+/* pass_intfns_santz definition */
+struct gimple_opt_pass pass_intfns_santz =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_santz",					/* name */
+  		gate_intfns_santz,				/* gate */
+  		execute_intfns_santz,			/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_SANTZ,			/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------intfns-selective and intra-p------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/*this pass is to select some integer operations as potential overflowing sites through a intra-p analysis.
+these integer operations have the feature of fllowing into sinks in less than limited steps.
+
+we exploit a back-forward to select those integer operations which could flow into sinks in limited steps.
+these flows are defined and structed as intfns-flow (defined in intfns.h),and stored in the pools. */
+
+/* dump one intfns-flow into the file */
+void dump_intfns_flow(FILE * file, intfns_flow flow)
+{
+	if(flow == NULL)
+		return;
+	gimple src = INTFNS_FLOW_SRC(flow);
+	gimple dest = INTFNS_FLOW_DEST(flow);
+
+	// at first, dump the src
+	if((IS_INTOP_SINK_FLOW(flow))
+		||(IS_INTOP_FUNC_FLOW(flow))
+		||(IS_INTOP_RET_FLOW(flow)))
+	{
+		if(INTFNS_STMT_TYPE(src) == FNS_UADD)
+			fprintf(file, "\tunsigned add ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_SADD)
+			fprintf(file, "\tsigned add ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_USUB)
+			fprintf(file, "\tunsigned sub ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_SSUB)
+			fprintf(file, "\tsigned sub ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_UMUL)
+			fprintf(file, "\tunsigned mul ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_SMUL)
+			fprintf(file, "\tsigned mul ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_USHL)
+			fprintf(file, "\tunsigned shl ");
+		else if(INTFNS_STMT_TYPE(src) == FNS_SSHL)
+			fprintf(file, "\tsigned add ");
+		else
+		{
+			fprintf(file, "\tERROR\n");
+			return;
+		}
+
+		fprintf(file, "@%s:%d --%d->>> ", gimple_filename(src), gimple_lineno(src), INTFNS_FLOW_STEPS(flow));
+	}
+	else	// param->sink flow
+		fprintf(file, "\t%d parameter->>> ", INTFNS_FLOW_PARAM_INDEX(flow));
+
+	// then, dump the dest
+	if((IS_INTOP_SINK_FLOW(flow))
+		|| (IS_PARAM_SINK_FLOW(flow)))
+	{
+		if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_IF)
+			fprintf(file, "if-stmt ");
+		else if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_WHILE)
+			fprintf(file, "while-stmt ");
+		else if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_LIB)
+			fprintf(file, "lib-call ");
+		else if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_ARRAY)
+			fprintf(file, "array-index ");
+		else if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_PTR)
+			fprintf(file, "ptr-offset ");
+		else if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_EXTERN_FUNC)
+			fprintf(file, "external func ");
+		else if(INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_ADDRESS_GLOBAL)
+			fprintf(file, "global var ");
+		else
+		{
+			fprintf(file, "ERROR\n");
+			return;
+		}
+	}
+	else if(IS_INTOP_FUNC_FLOW(flow))
+	{
+		fprintf(file, "%d|normal-func ", INTFNS_FLOW_PARAM_INDEX(flow));
+	}
+	else if(IS_INTOP_RET_FLOW(flow))
+	{
+		fprintf(file, "return ");
+	}
+	else
+		;
+	
+	fprintf(file, "@%s:%d\n", gimple_filename(dest), gimple_lineno(dest));
+
+	return;
+	
+}
+
+
+/* dump all the selected intop into fliles. */
+void dump_selected_intop(VEC(intfns_flow, gc) ** intop_sink_pool, VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool, VEC(intfns_flow, gc) ** param_sink_pool, unsigned int type)
+{
+	// open a file
+	FILE * file;
+	if(type == INTFNS_INTRA)
+		file =	fopen("/tmp/log_intfns_intra_selected_intop.txt", "a");
+	else if(type == INTFNS_INTER)
+		file =	fopen("/tmp/log_intfns_inter_selected_intop.txt", "a");
+	else
+		return;
+
+	// give the name of current func
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+
+	int ix;
+	intfns_flow flow;
+
+	fprintf(file, "intop->sink: %d flows:\n", VEC_length(intfns_flow, (*intop_sink_pool)));
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), ix, flow); ix ++)
+		dump_intfns_flow(file, flow);
+
+	fprintf(file, "intop->func: %d flows:\n", VEC_length(intfns_flow, (*intop_func_pool)));
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow); ix ++)
+		dump_intfns_flow(file, flow);
+
+	fprintf(file, "intop->ret: %d flows:\n", VEC_length(intfns_flow, (*intop_ret_pool)));
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_ret_pool), ix, flow); ix ++)
+		dump_intfns_flow(file, flow);
+
+	if(type == INTFNS_INTER)
+	{
+		fprintf(file, "param->sink: %d flows:\n", VEC_length(intfns_flow, (*param_sink_pool)));
+		for(ix = 0; VEC_iterate(intfns_flow, (*param_sink_pool), ix, flow); ix ++)
+			dump_intfns_flow(file, flow);
+	}
+	
+	// finish the dump
+	fprintf(file, "\n\n");
+	fclose(file);
+	return;	
+}
+
+// do statistics
+void intfns_intra_count(struct intfns_static_facts * sta)
+{
+	if(sta == NULL)
+		return;
+
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt;
+
+	FOR_EACH_BB(bb)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		stmt = gsi_stmt(gsi);
+  		if(stmt != NULL)
+  		{
+  			sta->stmt_total ++;
+			if((gimple_code(stmt)== GIMPLE_ASSIGN)
+				&&
+				(((INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+				||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_UMUL_OFFSET)
+				||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SMUL_OFFSET)
+				||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SHL_CONST)))
+			{
+				sta->intop_total ++;
+
+				if((INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_UMUL_OFFSET)
+				||(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SMUL_OFFSET))
+					sta->intop_mul_offset ++;
+
+				if(INTFNS_STMT_TYPE(stmt)== INTFNS_STMT_SHL_CONST)
+					sta->intop_shl_const ++;
+				
+				if(INTFNS_INTOP_SINK(stmt) == INTFNS_INTOP_TO_SINK)
+					sta->intop_sink_intra ++;
+				else
+				{
+					if((INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_FUNC)
+						||(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_FUNC_AND_RET))
+						sta->intop_func_intra ++;
+					else if((INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_RET)
+						||(INTFNS_INTOP_FUNC_RET(stmt) == INTFNS_INTOP_TO_FUNC_AND_RET))
+						sta->intop_ret_intra ++;
+					else
+						;
+				}
+			}
+  		}
+	}
+}
+
+
+/* build a new intfns-flow with (src, dest, steps, type, src_type, dest_type), and register it
+into the flow-pool*/
+bool intfns_build_flow(VEC(intfns_flow, gc) ** pool, gimple src, gimple dest, unsigned int steps,
+	unsigned int type, unsigned int src_type, unsigned int dest_type)
+{
+	// at first, apply memory space for this intfns-flow
+	intfns_flow flow;
+	flow = (intfns_flow)xmalloc(sizeof(struct intfns_flow_def));
+	if(flow == NULL)
+	{
+		FILE * file_warn = fopen("/tmp/log_intfns_warning.txt", "a");
+		fprintf(file_warn, "malloc error for intfns: build_flow.\n");
+		fclose(file_warn);
+		return false;
+	}
+
+	// register this flow into the pool
+	VEC_safe_push(intfns_flow, gc, (*pool), flow);
+
+	// set all the field of this flow
+	SET_INTFNS_FLOW(flow, src, dest, steps, type, src_type, dest_type);
+
+	return true;
+}
+
+/* eliminate those src->func/ret flows if there is src->sink flow */
+void intfns_cleanup_func_ret_pool(VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool, gimple src)
+{
+	// the premise is that INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK;
+	// and there exist src->func/ret.
+	// these have been ensured before invoking this process
+
+	int ix;
+	intfns_flow flow;
+
+	// src->func
+	if((INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC)
+		||((INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC_AND_RET)))
+	{
+		// find these flows, and exclude them from func-pool, and free them at last.
+		for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow); ix ++)
+			if(INTFNS_FLOW_SRC(flow) == src)
+			{
+				VEC_ordered_remove(intfns_flow, (*intop_func_pool), ix);
+				free(flow);
+				ix --;
+			}
+	}
+	// src->ret
+	if((INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_RET)
+		||((INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC_AND_RET)))
+	{
+		// find the flow, and exclude it from ret-pool, and free it at last.
+		for(ix = 0; VEC_iterate(intfns_flow, (*intop_ret_pool), ix, flow); ix ++)
+			if(INTFNS_FLOW_SRC(flow) == src)
+			{
+				VEC_ordered_remove(intfns_flow, (*intop_ret_pool), ix);
+				free(flow);
+				break;
+			}
+	}
+	else
+		;
+}
+
+
+/* create the imm-sink-flow: intop flows into sinks directly. */
+void intfns_create_imm_sink_flow(VEC(intfns_flow, gc) ** intop_sink_pool, VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool,gimple src, gimple dest, unsigned int dest_type)
+{	// steps = 0, src-type = STMT-TYPE(src), flow-type = intop->sink
+
+	bool found, build_succeed;
+	int ix;
+	intfns_flow flow;
+
+	// at first, check the sink-status of src. if src has imm sink flow already, return.
+	if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+		&&(INTFNS_INTOP_STEPS(src) == 0))
+		return;
+
+	// if there exists no flow: src->sink
+	if(INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_CLEAN)
+	{
+		// create a new src->sink flow
+		build_succeed = intfns_build_flow(intop_sink_pool, src, dest, 0, 
+			INTFNS_FLOW_INTOP_TO_SINK, INTFNS_STMT_TYPE(src), dest_type);
+
+		if(build_succeed)
+		{
+			// update the sink-status and steps-status of src
+			INTFNS_INTOP_STEPS(src) = 0;
+			INTFNS_INTOP_SINK(src) = INTFNS_INTOP_TO_SINK;
+			
+			// at last, cleanup-pools
+			// if there exist flows: src->func/ret, eliminate them
+			if(INTFNS_INTOP_FUNC_RET(src) != INTFNS_INTOP_TO_CLEAN)
+			{
+				intfns_cleanup_func_ret_pool(intop_func_pool, intop_ret_pool, src);
+				INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_CLEAN;
+			}
+		}
+	}
+	// if there exists a flow: src->sink, we just need to find it and reset it.
+	else
+	{
+		// find the sink flow of src
+		found = false;
+		for(ix = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), ix, flow); ix ++)
+			if(INTFNS_FLOW_SRC(flow) == src)
+			{
+				found = true;
+				break;
+			}
+
+		if(found)
+		{
+			
// update this sink flow
+			SET_INTFNS_FLOW(flow, src, dest, 0, INTFNS_FLOW_INTOP_TO_SINK,
+				INTFNS_STMT_TYPE(src), dest_type);
+			
+			// update the steps-status for src
+			INTFNS_INTOP_STEPS(src) = 0;
+		}
+	}
+}
+
+/* create the imm-ret-flow: intop flows into ret directly. */
+void intfns_create_imm_ret_flow(VEC(intfns_flow, gc) ** intop_ret_pool, gimple src, gimple dest)
+{	// steps = 0, src-type = STMT-TYPE(src), flow-type = intop->ret
+	bool build_succeed;
+
+	// the premis is that src has no flow into sink. this has been checked before invoking this process.
+	// at first, check the func-ret-status of src
+	if((INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_CLEAN)
+		|| (INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC))
+	{	// currently there is no src->ret flow, so apply space for an intnfs-flow
+		build_succeed = intfns_build_flow(intop_ret_pool, src, dest, 0,
+			INTFNS_FLOW_INTOP_TO_RET, INTFNS_STMT_TYPE(src), 0);
+
+		if(build_succeed)	// build the flow successfully
+		{
+			INTFNS_INTOP_STEPS(src) = 0;	// modify the status of src
+
+			// update the func-ret status
+			if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_CLEAN)
+				INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_RET;
+			else
+				INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_FUNC_AND_RET;
+		}
+		else
+			return;	
+	}
+	else
+	{	// currently, there has been an src->ret flow.
+		// for intop->ret, the shorter, the better.
+		// as only one intop->ret is needed actuallys
+
+		// if this intop->ret flows into ret within 0 step, pass.
+		if(INTFNS_INTOP_STEPS(src) == 0)	// err, src has imm sink flow already
+			return;
+		else	// find this flow, and modify basic info of it into imm-ret
+		{

+			int ix;
+			intfns_flow flow;
+
+			for(ix = 0; VEC_iterate(intfns_flow, (*intop_ret_pool), ix, flow); ix ++)
+				if(INTFNS_FLOW_SRC(flow) == src)
+				{
+					// modify the info of intfns-flow
+					SET_INTFNS_FLOW(flow, src, dest, 0, INTFNS_FLOW_INTOP_TO_RET,
+						INTFNS_STMT_TYPE(src), 0);
+
+					// modify the info of src
+					INTFNS_INTOP_STEPS(src) = 0;
+					break;
+				}
+		}
+	}
+}
+
+/* create the imm-func-flow: intop flows into func directly. */
+void intfns_create_imm_func_flow(VEC(intfns_flow, gc) ** intop_func_pool, gimple src, gimple dest, unsigned int param_ix)
+{	// steps = 0, src-type = param-ix, flow-type = intop->func
+	bool build_succeed;
+
+	// the premis is that src has no flow into sink. this has been checked before invoking this process.s
+	// at first, we should check whether there exists duplicate flow in current pool
+	// if so, pass. otherwise, create a new one.
+
+	if((INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC)
+		||(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC_AND_RET))
+	{
+		// travesal the intop-fun-pool to check the duplicate one
+		int ix;
+		intfns_flow flow;
+
+		for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow); ix ++)
+			if((INTFNS_FLOW_SRC(flow) == src)
+				&&(INTFNS_FLOW_DEST(flow) == dest)
+				&&(INTFNS_FLOW_SRC_TYPE(flow) == param_ix))
+				{
+					INTFNS_FLOW_STEPS(flow) = 0;	// ensure that src->dest in the least steps
+					return;
+				}
+	}
+
+	// if not found, create a new one and insert it into the pool
+	build_succeed = intfns_build_flow(intop_func_pool, src, dest, 0,
+			INTFNS_FLOW_INTOP_TO_FUNC, param_ix, 0);
+
+	if(build_succeed)	// build the flow successfully
+	{
+		// update the func-ret status
+		if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_CLEAN)
+			INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_FUNC;
+		else if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_RET)
+			INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_FUNC_AND_RET;
+		else
+			;
+		return;
+	}
+	else
+		return;	
+}
+
+/* transit the flows when encountering an analyzed intop. */
+void intfns_transit_flow(VEC(intfns_flow, gc) ** intop_sink_pool, VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool, gimple src, gimple use_stmt)
+{	
+	// we should consider the sink-status and func-ret-status respectivley for both src and use-stmt
+	int ix, iy;
+	intfns_flow flow, flow_src;
+	bool found, found_src, build_succeed;
+	
+	if(INTFNS_INTOP_SINK(use_stmt) == INTFNS_INTOP_TO_SINK)
+	{	// there exist  flows: use_stmt -> sink			
+		// check steps + 1 is within INTFNS-STEPS-MAX
+		if((INTFNS_INTOP_STEPS(use_stmt)+ 1) > INTFNS_STEPS_MAX)
+			return;
+		
+		// at first, check the sink-status of src
+		if(INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+		{
+			// check the steps-info of src and compare it with <use-stmt`s steps + 1>
+			if(INTFNS_INTOP_STEPS(src) <= (INTFNS_INTOP_STEPS(use_stmt)+ 1))
+				return;
+		}
+
+		// find the sink flow of use-stmt <dest, steps, dest-type>
+		found = false;
+		for(ix = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), ix, flow); ix ++)
+			if(INTFNS_FLOW_SRC(flow) == use_stmt)
+			{
+				found = true;
+				break;
+			}
+
+		// find the sink flow of src
+		found_src = false;
+		if(INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+			for(ix = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), ix, flow_src); ix ++)
+				if(INTFNS_FLOW_SRC(flow) == src)
+				{
+					found_src = true;
+					break;
+				}
+		
+		if(found)
+		{
+			// based on our observation, shift can only be exploited at MEM.
+			// therefore, if the use-stmt flows into critical places other than MEM,
+			// we might stop this transit.
+			if((INTFNS_STMT_TYPE(src) == FNS_USHL)
+				|| (INTFNS_STMT_TYPE(src) == FNS_SSHL))
+			{
+				if((INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_LIB)
+					|| (INTFNS_FLOW_DEST_TYPE(flow) == INTFNS_SINK_EXTERN_FUNC))
+					;
+				else
+					return;
+			}
+		
+			if(found_src)
+			{
+				// update flow_src
+				SET_INTFNS_FLOW(flow_src, src, INTFNS_FLOW_DEST(flow), (INTFNS_INTOP_STEPS(use_stmt)+ 1),
+					INTFNS_FLOW_INTOP_TO_SINK,INTFNS_STMT_TYPE(src), INTFNS_FLOW_DEST_TYPE(flow));
+				// update the steps-status for src
+				INTFNS_INTOP_STEPS(src) = INTFNS_INTOP_STEPS(use_stmt) + 1;
+			}
+			else
+			{
+				// otherwise, create a new intop-sink-flow <src, dest, steps+1, dest-type>
+				build_succeed = intfns_build_flow(intop_sink_pool, src, INTFNS_FLOW_DEST(flow),
+					INTFNS_INTOP_STEPS(use_stmt) + 1, INTFNS_FLOW_INTOP_TO_SINK,
+					INTFNS_STMT_TYPE(src), INTFNS_FLOW_DEST_TYPE(flow));
+
+				// build the flow successfully
+				if(build_succeed)
+				{
+					// update the sink-status and steps-status of src				
+					INTFNS_INTOP_STEPS(src) = INTFNS_INTOP_STEPS(use_stmt) + 1;
+					INTFNS_INTOP_SINK(src) = INTFNS_INTOP_TO_SINK;
+
+					// if there exist flows: src->func/ret, eliminate them
+					if(INTFNS_INTOP_FUNC_RET(src) != INTFNS_INTOP_TO_CLEAN)
+					{	
+						intfns_cleanup_func_ret_pool(intop_func_pool, intop_ret_pool, src);
+						INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_CLEAN;
+					}
+				}
+			}
+		}
+	}
+	else
+	{	// there do not exist flows from use-stmt to sinks.
+	
+		// at first, check the sink-status of src.
+		// if there exist flows: src->sink, no need for transit
+		if(INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+			return;
+
+		// now, there do not exist flows: src->sinks
+		// if there do not exist flows from use-stmt to func/ret either, pass!
+		if(INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_CLEAN)
+			return;
+
+		// now, there exist flows from use-stmt to func/ret
+		// and src is eager to transit such flows.
+		
+		// if there exist flows from use-stmt to func
+		if((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_FUNC)
+			||((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_FUNC_AND_RET)))
+		{
+			for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow); ix ++)
+				if(INTFNS_FLOW_SRC(flow) == use_stmt)
+				{	// use-stmt -> func is found
+					if(INTFNS_FLOW_STEPS(flow) == INTFNS_STEPS_MAX)
+						continue;
+
+					// if there exists src-> func already
+					found = false;
+					if((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_FUNC)
+						||((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_FUNC_AND_RET)))
+					{
+						for(iy = 0; VEC_iterate(intfns_flow, (*intop_func_pool), iy, flow_src); iy ++)
+							if((INTFNS_FLOW_SRC(flow_src)== src)
+								&&(INTFNS_FLOW_DEST(flow_src)== INTFNS_FLOW_DEST(flow))
+								&&(INTFNS_FLOW_SRC_TYPE(flow_src) == INTFNS_FLOW_SRC_TYPE(flow)))
+							{
+								// update the flow`s steps-status, fix the least one.
+								if(INTFNS_FLOW_STEPS(flow_src) > (INTFNS_FLOW_STEPS(flow) + 1))
+									INTFNS_FLOW_STEPS(flow_src) = INTFNS_FLOW_STEPS(flow) + 1;
+								found = true;
+								break;
+							}
+					}
+			
+					if(found)
+						continue;
+
+					// if not found, create a new one: src->func
+					build_succeed = intfns_build_flow(intop_func_pool, src, INTFNS_FLOW_DEST(flow),
+						INTFNS_FLOW_STEPS(flow) + 1, INTFNS_FLOW_INTOP_TO_FUNC,
+						INTFNS_FLOW_SRC_TYPE(flow), INTFNS_FLOW_DEST_TYPE(flow));
+
+					// build the flow successfully
+					if(build_succeed)
+					{
+						// update the func/ret status for src
+						if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_CLEAN)
+							INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_FUNC;
+						else if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_RET)
+							INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_FUNC_AND_RET;
+						else
+							;										
+					}					
+				}			
+		}
+		// if there exist flows from use-stmt to ret
+		else if((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_RET)
+			||((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_FUNC_AND_RET)))
+		{
+			for(ix = 0; VEC_iterate(intfns_flow, (*intop_ret_pool), ix, flow); ix ++)
+				if(INTFNS_FLOW_SRC(flow) == use_stmt)
+				{	// use-stmt -> ret is found
+					if(INTFNS_FLOW_STEPS(flow) == INTFNS_STEPS_MAX)
+						break;
+
+					// if there exists src->ret already
+					found = false;
+					if((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_RET)
+						||((INTFNS_INTOP_FUNC_RET(use_stmt) == INTFNS_INTOP_TO_FUNC_AND_RET)))
+					{
+						for(iy = 0; VEC_iterate(intfns_flow, (*intop_ret_pool), iy, flow_src); iy ++)
+							if(INTFNS_FLOW_SRC(flow_src)== src)
+							{
+								// update the flow`s steps-status, fix the least one.
+								if(INTFNS_FLOW_STEPS(flow_src) > (INTFNS_FLOW_STEPS(flow) + 1))
+								{
+									INTFNS_FLOW_STEPS(flow_src) = INTFNS_FLOW_STEPS(flow) + 1;
+									INTFNS_FLOW_DEST(flow_src) = INTFNS_FLOW_DEST(flow);
+								}	
+								found = true;
+								break;
+							}
+					}
+			
+					if(found)
+						break;
+
+					// if not found, create a new one: src->ret
+					build_succeed = intfns_build_flow(intop_ret_pool, src, INTFNS_FLOW_DEST(flow),
+						INTFNS_FLOW_STEPS(flow) + 1, INTFNS_FLOW_INTOP_TO_RET,
+						INTFNS_FLOW_SRC_TYPE(flow), INTFNS_FLOW_DEST_TYPE(flow));
+
+					// build the flow successfully
+					if(build_succeed)
+					{
+						// update the func/ret status for src
+						if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_CLEAN)
+							INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_RET;
+						else if(INTFNS_INTOP_FUNC_RET(src) == INTFNS_INTOP_TO_FUNC)
+							INTFNS_INTOP_FUNC_RET(src) = INTFNS_INTOP_TO_FUNC_AND_RET;
+						else
+							;										
+					}
+					break;
+				}
+		}
+		else
+			;
+	}
+}
+
+
+/* the key process of intfns: select those intop as potential overflowing sites, which could flow into sinks
+within limited steps. */
+void intfns_select_intop(FILE * file, gimple propagate, gimple src, VEC(intfns_flow, gc)** intop_sink_pool,
+	VEC(intfns_flow, gc)** intop_func_pool, VEC(intfns_flow, gc)** intop_ret_pool)
+{
+	tree lhs;
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	// FIXME: it is an optimization here
+	// based on our observation, almost all lshfts are exploited at MEM
+	// therefore, we could eliminate the checks for lshft where they flow into
+	// critical places other than MEM.
+	unsigned int src_is_shl = 0;
+	if((INTFNS_STMT_TYPE(src) == FNS_USHL)
+		|| (INTFNS_STMT_TYPE(src) == FNS_SSHL))
+		src_is_shl = 1;
+
+	/* if src has already been analyzed as flowing into sink immediately, return. */
+	if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+		&& (INTFNS_INTOP_STEPS(src) == 0))
+		return;
+	
+	// src is an being-analyzed int-op, and progate is an convert-op, casting-op or phi-node
+	if(gimple_code(propagate) == GIMPLE_PHI)
+		lhs = gimple_phi_result(propagate);
+	else if(gimple_code(propagate) == GIMPLE_ASSIGN)
+		lhs = gimple_assign_lhs (propagate);
+	else
+		return;
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{	
+			// check whether use-stmt is array[lhs] = xxxx.
+			use_lhs= gimple_assign_lhs(use_stmt);		
+			if((TREE_CODE(use_lhs) == ARRAY_REF)
+				&&(TREE_OPERAND(use_lhs, 1) == lhs))
+			{	// src is used at array-index, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool, 
+						src, use_stmt,INTFNS_SINK_ARRAY);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);
+			if(stmt_type == INTFNS_STMT_ADDRESS_GLOBAL)
+			{	// src is used at global var, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+						src, use_stmt,INTFNS_SINK_ADDRESS_GLOBAL);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if((stmt_type == INTFNS_STMT_SMUL_OFFSET)
+				||(stmt_type == INTFNS_STMT_UMUL_OFFSET))
+			{	// src is used at mul-offset, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+						src, use_stmt,INTFNS_SINK_ARRAY);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if(stmt_type == INTFNS_STMT_PTR_PLUS)
+			{	// src is used at ptr-offset, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+						src, use_stmt,INTFNS_SINK_PTR);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if(stmt_type == INTFNS_STMT_IF)
+			{	// src is used at relation->if, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+						src, use_stmt,INTFNS_SINK_IF);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if(stmt_type == INTFNS_STMT_WHILE)
+			{	// src is used at relation->while, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+						src, use_stmt,INTFNS_SINK_WHILE);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if(stmt_type == INTFNS_STMT_ARRAY_REF)
+			{	// src is used at array-index, create imm-sink intfns-flow
+				if(!src_is_shl)
+				{
+					intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+						src, use_stmt,INTFNS_SINK_ARRAY);
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_NARROW))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+				
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_select_intop(file, use_stmt, src, intop_sink_pool,
+						intop_func_pool, intop_ret_pool);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+					// check the result of propagate. 
+					// if src has been analyzed as flowing into sink immediately, return
+					if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+						&& (INTFNS_INTOP_STEPS(src) == 0))
+						BREAK_FROM_IMM_USE_STMT (iter)				
+				}
+				else
+					;
+			}
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// steps + 1, check been-analyzed
+				if(INTFNS_INTOP_STATUS(use_stmt) == INTFNS_INTOP_BEEN_ANALYZED)
+					intfns_transit_flow(intop_sink_pool, intop_func_pool, intop_ret_pool,
+						src, use_stmt);
+			}
+			//narrow-op
+			//else if(stmt_type == INTFNS_STMT_NARROW)
+			// sanitization ops
+			else if((stmt_type >= INTFNS_STMT_SANTZ_AND_CONST)
+				&& (stmt_type <= INTFNS_STMT_SANTZ_MOD_VAR_CONST))
+			{	// narrow-op, if we do not consider narrow-op, we treat it as propagate-op
+				if(flag_intfns_omit_narrow)
+				{
+					if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+					{
+						INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+						// propagate, recursive call
+						intfns_select_intop(file, use_stmt, src, intop_sink_pool,
+							intop_func_pool, intop_ret_pool);
+						INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+						// check the result of propagate. 
+						// if src has been analyzed as flowing into sink immediately, return
+						if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+							&& (INTFNS_INTOP_STEPS(src) == 0))
+							BREAK_FROM_IMM_USE_STMT (iter)				
+					}
+				}
+			}
+			else
+				;	// continue
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_COND)
+		{
+			if(src_is_shl)
+				;
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_IF)
+			{	// src is used at if, create imm-sink intfns-flow
+				intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+					src, use_stmt,INTFNS_SINK_IF);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else
+			{	// src is used at while, create imm-sink intfns-flow
+				intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+					src, use_stmt,INTFNS_SINK_WHILE);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_SINK_LIB)
+			{	// src is used at sink-lib, create imm-sink intfns-flow
+				intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+					src, use_stmt,INTFNS_SINK_LIB);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			if((INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_FUNC)
+				||(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_SINK))
+			{	// src is used at sink-extern-func, create imm-sink intfns-flow
+				intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+					src, use_stmt,INTFNS_SINK_EXTERN_FUNC);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_NORMAL_FUNC)
+			{	// create intop->func flow,
+				//  at first, check whether src can flow into sink
+				if(INTFNS_INTOP_SINK(src)== INTFNS_INTOP_TO_CLEAN)
+				{
+					// then, get the param-index, find lhs in the call-arg-list
+					// param-index max is 16
+					int ix;
+					tree arg;
+					for (ix = 0; ix < gimple_call_num_args (use_stmt); ix++)
+					{
+						if(ix == INTFNS_PARAM_NUM_MAX)
+							break;
+						arg = gimple_call_arg(use_stmt, ix);
+
+						// the param-index is ix now.
+						// create intop->func, steps = 0, and src-type indicates the param-index
+						if(arg == lhs)						
+						{
+							intfns_create_imm_func_flow(intop_func_pool, src, use_stmt, ix);	
+							break;
+						}
+					}
+				}
+				else
+					;	
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_RETURN)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_RET)
+			{	// create intop->ret flow, at first, check whether src is single-sink or mult sinks
+				//  at first, check whether src can flow into sink
+				if(INTFNS_INTOP_SINK(src)== INTFNS_INTOP_TO_CLEAN)
+					// create intop->ret, steps = 0
+					intfns_create_imm_ret_flow(intop_ret_pool, src, use_stmt);					
+				else
+					;
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_select_intop(file, use_stmt, src, intop_sink_pool,
+					intop_func_pool, intop_ret_pool);
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+
+				// check the result of propagate. 
+				// if src has been analyzed as flowing into sink immediately, return
+				if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+					&& (INTFNS_INTOP_STEPS(src) == 0))
+					BREAK_FROM_IMM_USE_STMT (iter)					
+			}
+			else
+				;			
+		}	
+		else
+			;
+	}
+	return;
+}
+
+/* execution function for our pass */
+static unsigned int
+execute_intfns_intra (void)
+{
+	/* local vars*/	
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	VEC(intfns_flow, gc)** intop_sink_pool, **intop_func_pool, **intop_ret_pool, **param_sink_pool;
+	struct intfns_static_facts * sta;
+	FILE* file;
+	int ix, iy;
+	gimple stmt, stmt_start;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_intra.txt", "a");
+	fprintf(file,"INTFNS-intra for %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+	if((DECL_STRUCT_FUNCTION(current_function_decl) == NULL) || (cfun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}
+
+	/* do some initialization */
+	intop_sink_pool = &(INTFNS_INFO_INTOP_SINK_POOL_FUN(cfun));	// to get the addr of current-func`s intfns-flow-pool		
+	intop_func_pool = &(INTFNS_INFO_INTOP_FUNC_POOL_FUN(cfun));			
+	intop_ret_pool = &(INTFNS_INFO_INTOP_RET_POOL_FUN(cfun));	
+	param_sink_pool = &(INTFNS_INFO_PARAM_SINK_POOL_FUN(cfun));
+	sta = INTFNS_INFO_STA_FUN(cfun);							// point to the struct to store statistics info
+	
+	strncpy(sta->func_name, lang_hooks.decl_printable_name(current_function_decl, 2), 128);	
+	fprintf(file, "\t>>begin\t");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 1. select the intop which could flow into sinks within limited steps.*/
+	/* this process is a backward analysis. */
+	FOR_EACH_BB_REVERSE(bb)
+	{
+		// get the first stmt in bb
+		gsi = gsi_start_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt_start = gsi_stmt(gsi);
+
+		// get the last stmt in bb
+		gsi = gsi_last_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt = gsi_stmt(gsi);
+		
+		// travesal the stmt in bb backward.
+		while(stmt != stmt_start)
+		{	
+			/* filter all the intop stmt*/
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+				&&(INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+			{
+				if(INTFNS_INTOP_STATUS(stmt) == INTFNS_INTOP_UN_ANALYZED)
+				{
+					INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEING_ANALYZED;
+					intfns_select_intop(file, stmt, stmt, intop_sink_pool, intop_func_pool,
+						intop_ret_pool);
+					INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+				}
+			}
+			gsi_prev(&gsi);
+			stmt = gsi_stmt(gsi);
+		}
+		
+		// here, stmt is stmt-start
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+			&&(INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+			&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+		{
+			if(INTFNS_INTOP_STATUS(stmt) == INTFNS_INTOP_UN_ANALYZED)
+			{
+				INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEING_ANALYZED;
+				intfns_select_intop(file, stmt, stmt, intop_sink_pool, intop_func_pool,
+					intop_ret_pool);
+				INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+			}
+		}
+	}
+	fprintf(file, ">>select\t");
+	
+	/* dump the selected intops */
+	dump_selected_intop(intop_sink_pool, intop_func_pool, 
+		intop_ret_pool, param_sink_pool, INTFNS_INTRA);
+
+	// counter the insn
+	intfns_intra_count(sta);
+	
+	/*-----------------------------------------------------------------------------*/	
+	fprintf(file, ">>finish\n");
+	fclose(file);	
+	return 1;
+}
+
+
+/* gate for our pass, invoked by -fintfns and -fintfns-intra/-fintfns-inter */
+static bool
+gate_intfns_intra (void)
+{
+	return (flag_intfns && (flag_intfns_intra || flag_intfns_inter));
+}
+
+
+/* pass_intfns_intra definition */
+struct gimple_opt_pass pass_intfns_intra =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_intra",					/* name */
+  		gate_intfns_intra,				/* gate */
+  		execute_intfns_intra,			/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_INTRA,			/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------intfns-io2bo and intra-p------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/*this pass is to select some integer operations as potential overflowing sites through a intra-p analysis.
+these integer operations have the feature of fllowing into lib-sinks within limited steps.
+
+we exploit a back-forward to select those integer operations which could flow into sinks in limited steps.
+these flows are defined and structed as intfns-flow (defined in intfns.h),and stored in the pools. */
+
+/* the key process of intfns-io2bo: select those intop as potential overflowing sites, which could flow into 
+lib-sinks within limited steps. */
+void intfns_io2bo_select_intop(FILE * file, gimple propagate, gimple src, VEC(intfns_flow, gc)** intop_sink_pool,
+	VEC(intfns_flow, gc)** intop_func_pool, VEC(intfns_flow, gc)** intop_ret_pool)
+{
+	tree lhs;
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	// based on our observation, almost all lshfts are exploited at MEM
+	// therefore, we could eliminate the checks for lshft where they flow into
+	// critical places other than MEM.
+	unsigned int src_is_shl = 0;
+	if((INTFNS_STMT_TYPE(src) == FNS_USHL)
+		|| (INTFNS_STMT_TYPE(src) == FNS_SSHL))
+		src_is_shl = 1;
+
+	/* if src has already been analyzed as flowing into sink immediately, return. */
+	if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+		&& (INTFNS_INTOP_STEPS(src) == 0))
+		return;
+	
+	// src is an being-analyzed int-op, and progate is an convert-op, casting-op or phi-node
+	if(gimple_code(propagate) == GIMPLE_PHI)
+		lhs = gimple_phi_result(propagate);
+	else if(gimple_code(propagate) == GIMPLE_ASSIGN)
+		lhs = gimple_assign_lhs (propagate);
+	else
+		return;
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);			
+			if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+				
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_io2bo_select_intop(file, use_stmt, src, intop_sink_pool,
+						intop_func_pool, intop_ret_pool);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+					// check the result of propagate. 
+					// if src has been analyzed as flowing into sink immediately, return
+					if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+						&& (INTFNS_INTOP_STEPS(src) == 0))
+						BREAK_FROM_IMM_USE_STMT (iter)				
+				}
+				else
+					;
+			}
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// steps + 1, check been-analyzed
+				if(INTFNS_INTOP_STATUS(use_stmt) == INTFNS_INTOP_BEEN_ANALYZED)
+					intfns_transit_flow(intop_sink_pool, intop_func_pool, intop_ret_pool,
+						src, use_stmt);
+			}
+			else
+				;	// continue
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_SINK_LIB)
+			{	// src is used at sink-lib, create imm-sink intfns-flow
+				intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+					src, use_stmt,INTFNS_SINK_LIB);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_SINK)
+			{	// src is used at sink-extern-func, create imm-sink intfns-flow
+				intfns_create_imm_sink_flow(intop_sink_pool, intop_func_pool,intop_ret_pool,
+					src, use_stmt,INTFNS_SINK_EXTERN_FUNC);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_NORMAL_FUNC)
+			{	// create intop->func flow,
+				//  at first, check whether src can flow into sink
+				if(INTFNS_INTOP_SINK(src)== INTFNS_INTOP_TO_CLEAN)
+				{
+					// then, get the param-index, find lhs in the call-arg-list
+					// param-index max is 16
+					int ix;
+					tree arg;
+					for (ix = 0; ix < gimple_call_num_args (use_stmt); ix++)
+					{
+						if(ix == INTFNS_PARAM_NUM_MAX)
+							break;
+						arg = gimple_call_arg(use_stmt, ix);
+
+						// the param-index is ix now.
+						// create intop->func, steps = 0, and src-type indicates the param-index
+						if(arg == lhs)						
+						{
+							intfns_create_imm_func_flow(intop_func_pool, src, use_stmt, ix);	
+							break;
+						}
+					}
+				}
+				else
+					;	
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_RETURN)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_RET)
+			{	// create intop->ret flow, at first, check whether src is single-sink or mult sinks
+				//  at first, check whether src can flow into sink
+				if(INTFNS_INTOP_SINK(src)== INTFNS_INTOP_TO_CLEAN)
+					// create intop->ret, steps = 0
+					intfns_create_imm_ret_flow(intop_ret_pool, src, use_stmt);					
+				else
+					;
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_io2bo_select_intop(file, use_stmt, src, intop_sink_pool,
+					intop_func_pool, intop_ret_pool);
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+
+				// check the result of propagate. 
+				// if src has been analyzed as flowing into sink immediately, return
+				if((INTFNS_INTOP_SINK(src) == INTFNS_INTOP_TO_SINK)
+					&& (INTFNS_INTOP_STEPS(src) == 0))
+					BREAK_FROM_IMM_USE_STMT (iter)					
+			}
+			else
+				;			
+		}
+		else
+			;
+	}
+	return;
+}
+
+/* execution function for our pass */
+static unsigned int
+execute_intfns_io2bo_intra (void)
+{
+	/* local vars*/	
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	VEC(intfns_flow, gc)** intop_sink_pool, **intop_func_pool, **intop_ret_pool, **param_sink_pool;
+	struct intfns_static_facts * sta;
+	FILE* file;
+	int ix, iy;
+	gimple stmt, stmt_start;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_io2bo_intra.txt", "a");
+	fprintf(file,"INTFNS-io2bo-intra for %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+	if((DECL_STRUCT_FUNCTION(current_function_decl) == NULL) || (cfun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}
+
+	/* do some initialization */
+	intop_sink_pool = &(INTFNS_INFO_INTOP_SINK_POOL_FUN(cfun));	// to get the addr of current-func`s intfns-flow-pool		
+	intop_func_pool = &(INTFNS_INFO_INTOP_FUNC_POOL_FUN(cfun));			
+	intop_ret_pool = &(INTFNS_INFO_INTOP_RET_POOL_FUN(cfun));	
+	param_sink_pool = &(INTFNS_INFO_PARAM_SINK_POOL_FUN(cfun));
+	sta = INTFNS_INFO_STA_FUN(cfun);							// point to the struct to store statistics info
+	
+	strncpy(sta->func_name, lang_hooks.decl_printable_name(current_function_decl, 2), 128);	
+	fprintf(file, "\t>>begin\t");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 1. select the intop which could flow into lib-sinks within limited steps.*/
+	/* this process is a backward analysis. */
+	FOR_EACH_BB_REVERSE(bb)
+	{
+		// get the first stmt in bb
+		gsi = gsi_start_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt_start = gsi_stmt(gsi);
+
+		// get the last stmt in bb
+		gsi = gsi_last_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt = gsi_stmt(gsi);	
+		
+		// travesal the stmt in bb backward.
+		while(stmt != stmt_start)
+		{	
+			/* filter all the intop stmt*/
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+				&&(INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+				&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+			{
+				if(INTFNS_INTOP_STATUS(stmt) == INTFNS_INTOP_UN_ANALYZED)
+				{
+					INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEING_ANALYZED;
+					intfns_io2bo_select_intop(file, stmt, stmt, intop_sink_pool, intop_func_pool,
+						intop_ret_pool);
+					INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+				}
+			}
+			gsi_prev(&gsi);
+			stmt = gsi_stmt(gsi);
+		}
+		
+		// here, stmt is stmt-start
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+			&&(INTFNS_STMT_TYPE(stmt) >= FNS_UADD)
+			&&(INTFNS_STMT_TYPE(stmt) <= FNS_SSHL))
+		{
+			if(INTFNS_INTOP_STATUS(stmt) == INTFNS_INTOP_UN_ANALYZED)
+			{
+				INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEING_ANALYZED;
+				intfns_io2bo_select_intop(file, stmt, stmt, intop_sink_pool, intop_func_pool,
+					intop_ret_pool);
+				INTFNS_INTOP_STATUS(stmt) = INTFNS_INTOP_BEEN_ANALYZED;
+			}
+		}
+	}
+	fprintf(file, ">>select\t");
+	
+	/* dump the selected intops */
+	dump_selected_intop(intop_sink_pool, intop_func_pool, 
+		intop_ret_pool, param_sink_pool, INTFNS_INTRA);
+
+	// counter the insn
+	intfns_intra_count(sta);
+	
+	/*-----------------------------------------------------------------------------*/	
+	fprintf(file, ">>finish\n");
+	fclose(file);	
+	return 1;
+}
+
+/* gate for our pass, invoked by -fintfns and -fintfns-io2bo */
+static bool
+gate_intfns_io2bo (void)
+{
+	return (flag_intfns && flag_intfns_io2bo);
+}
+
+/* pass_intfns_io2bo_intra definition */
+struct gimple_opt_pass pass_intfns_io2bo_intra =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_io2bo_intra",					/* name */
+  		gate_intfns_io2bo,		/* gate */
+  		execute_intfns_io2bo_intra,		/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_IO2BO_INTRA,		/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------intfns-selective and inter-p------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+
+/* create an imm param->sink flow */
+void intfns_create_imm_param_flow(VEC(intfns_flow, gc)** param_sink_pool, int index, 
+	struct intfns_param_facts* param_facts, gimple dest, unsigned int dest_type)
+
+{	// steps = 0, src = null, src-type = param-index, flow-type = param->sink, 
+
+	bool build_succeed;
+	intfns_flow flow;
+
+	/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+	if((param_facts[index].has_param_flow == 1) 
+		&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+		return;
+
+	// if there exists no flow: src->sink
+	if(param_facts[index].has_param_flow == 0)
+	{
+		// create a new param->sink flow
+		build_succeed = intfns_build_flow(param_sink_pool, NULL, dest, 0, 
+			INTFNS_FLOW_PARAM_TO_SINK, index, dest_type);
+
+		if(build_succeed)
+		{
+			// update the status of param-index
+			param_facts[index].has_param_flow = 1;
+			param_facts[index].param_flow = VEC_last(intfns_flow, (*param_sink_pool));
+		}
+	}
+	// if there exists a flow: param->sink, we just need to find it and reset it.
+	else
+	{
+		flow = param_facts[index].param_flow;
+		
// update this sink flow
+		SET_INTFNS_FLOW(flow, NULL, dest, 0, INTFNS_FLOW_PARAM_TO_SINK,
+			index, dest_type);
+	}
+}
+
+/* param->intop +++ intop->sink   --->>> param->sink*/
+void intfns_transit_param_flow(VEC(intfns_flow, gc)** intop_sink_pool, VEC(intfns_flow, gc)** param_sink_pool, 
+		int index, struct intfns_param_facts* param_facts, gimple use_stmt)
+{
+	int ix, iy;
+	intfns_flow intop_flow, param_flow;
+	bool found, build_succeed;
+	
+	// there exist  flows: use_stmt -> sink
+	// find the sink flow of use-stmt <dest, steps, dest-type>
+	found = false;
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), ix, intop_flow); ix ++)
+		if(INTFNS_FLOW_SRC(intop_flow) == use_stmt)
+		{
+			found = true;
+			break;
+		}
+	
+	if(found)
+	{
+		if(param_facts[index].has_param_flow == 1)
+		{	// there has already existed param->sink		
+			param_flow = param_facts[index].param_flow;
+			if(INTFNS_FLOW_STEPS(param_flow) > INTFNS_FLOW_STEPS(intop_flow))
+			{
+				INTFNS_FLOW_DEST(param_flow) = INTFNS_FLOW_DEST(intop_flow);
+				INTFNS_FLOW_STEPS(param_flow) = INTFNS_FLOW_STEPS(intop_flow);
+				INTFNS_FLOW_DEST_TYPE(param_flow) = INTFNS_FLOW_DEST_TYPE(intop_flow);
+			}
+		}
+		else
+		{
+			// otherwise, create a new param-sink-flow <null, dest, steps, dest-type>
+			build_succeed = intfns_build_flow(param_sink_pool, NULL, INTFNS_FLOW_DEST(intop_flow),
+				INTFNS_FLOW_STEPS(intop_flow), INTFNS_FLOW_PARAM_TO_SINK,
+				index, INTFNS_FLOW_DEST_TYPE(intop_flow));
+
+			if(build_succeed)
+			{
+				// update the status of param-index
+				param_facts[index].has_param_flow = 1;
+				param_facts[index].param_flow = VEC_last(intfns_flow, (*param_sink_pool));
+			}
+		}
+	}
+}
+
+/* a recursive process to transit param-> ssa-name +++ ssa-name->sink. */
+void intfns_inter_select_param(FILE* file, tree lhs, int index, struct intfns_param_facts * param_facts, 
+		VEC(intfns_flow, gc)** intop_sink_pool, VEC(intfns_flow, gc)** param_sink_pool)
+{
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+	if((param_facts[index].has_param_flow == 1) 
+		&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+		return;
+
+	if(TREE_CODE(lhs) != SSA_NAME)
+		return;
+
+	// check the status of lhs
+	if(TREE_INTFNS_BEING_ANALYZED(lhs) == 1)
+		return;
+	else
+		TREE_INTFNS_BEING_ANALYZED(lhs)= 1;
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{	
+			// check whether use-stmt is array[lhs] = xxxx.
+			use_lhs= gimple_assign_lhs(use_stmt);			
+			if((TREE_CODE(use_lhs) == ARRAY_REF)
+				&&(TREE_OPERAND(use_lhs, 1) == lhs))
+			{	// src is used at array-index, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_ARRAY);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}			
+
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);		
+			if((stmt_type == INTFNS_STMT_ADDRESS_GLOBAL))
+			{	// src is used at global var, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_ADDRESS_GLOBAL);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if((stmt_type == INTFNS_STMT_UMUL_OFFSET)
+				||(stmt_type == INTFNS_STMT_SMUL_OFFSET))
+			{	// src is used at ptr-offset, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_ARRAY);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_PTR_PLUS)
+			{	// src is used at ptr-offset, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_PTR);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_IF)
+			{	// src is used at relation->if, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_IF);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_WHILE)
+			{	// src is used at relation->while, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_WHILE);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_ARRAY_REF)
+			{	// src is used at array-index, create imm-param-sink flow			
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_ARRAY);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_NARROW))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+			
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_inter_select_param(file, gimple_assign_lhs (use_stmt), index, param_facts, intop_sink_pool,
+						param_sink_pool);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+					
+					/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+					if((param_facts[index].has_param_flow == 1)
+						&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+						BREAK_FROM_IMM_USE_STMT (iter)			
+				}
+			}
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// use-stmt->sink, transit
+				if(INTFNS_INTOP_SINK(use_stmt) == INTFNS_INTOP_TO_SINK)
+					intfns_transit_param_flow(intop_sink_pool, param_sink_pool, index,
+						param_facts, use_stmt);
+			}
+			//narrow-op
+			//else if(stmt_type == INTFNS_STMT_NARROW)
+			// sanitization ops
+			else if((stmt_type >= INTFNS_STMT_SANTZ_AND_CONST)
+				&& (stmt_type <= INTFNS_STMT_SANTZ_MOD_VAR_CONST))
+			{	// narrow-op, if we do not consider narrow-op, we treat it as propagate-op
+				if(flag_intfns_omit_narrow)
+				{
+					if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+					{
+						INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+						// propagate, recursive call
+						intfns_inter_select_param(file, gimple_assign_lhs (use_stmt), index, param_facts, intop_sink_pool,
+							param_sink_pool);
+						INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+
+						/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+						if((param_facts[index].has_param_flow == 1) 
+							&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+							BREAK_FROM_IMM_USE_STMT (iter)			
+					}
+				}
+			}
+			else
+				;	// continue
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_COND)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_IF)
+			{	// src is used at if, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_IF);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else
+			{	// src is used at while, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_WHILE);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_SINK_LIB)
+			{	// src is used at sink-lib, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_LIB);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			if((INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_FUNC)
+				||(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_SINK))
+			{	// src is used at sink-extern-func, create imm-param-sink flow				
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_EXTERN_FUNC);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_NORMAL_FUNC)
+			{
+				// fixme: we need transit: param->ix|func +++ ix->sink
+				;
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+   			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_inter_select_param(file, gimple_phi_result(use_stmt), index, param_facts, intop_sink_pool,
+					param_sink_pool);
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+				
+				/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+				if((param_facts[index].has_param_flow == 1) 
+					&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+					BREAK_FROM_IMM_USE_STMT (iter)			
+			}
+			else
+				;	
+		}
+		else
+			;
+	}
+
+	TREE_INTFNS_BEING_ANALYZED(lhs) = 0;
+	return;
+}
+
+/* eliminate those src->func flows if there is src->sink flow */
+void intfns_inter_cleanup_func_pool(VEC(intfns_flow, gc) ** intop_func_pool)
+{
+	int ix;
+	intfns_flow flow_intop_func;
+	gimple intop;
+
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow_intop_func); ix ++)
+	{
+		if(flow_intop_func == NULL)
+			continue;
+
+		intop = INTFNS_FLOW_SRC(flow_intop_func);
+
+		if(INTFNS_INTOP_SINK(intop) == INTFNS_INTOP_TO_SINK)
+		{
+			VEC_ordered_remove(intfns_flow, (*intop_func_pool), ix);
+			free(flow_intop_func);
+			ix --;
+
+			if(INTFNS_INTOP_FUNC_RET(intop) == INTFNS_INTOP_TO_FUNC)
+				INTFNS_INTOP_FUNC_RET(intop) = INTFNS_INTOP_TO_CLEAN;
+			else if(INTFNS_INTOP_FUNC_RET(intop) == INTFNS_INTOP_TO_FUNC_AND_RET)
+				INTFNS_INTOP_FUNC_RET(intop) = INTFNS_INTOP_TO_RET;
+			else
+				;
+		}
+	}
+}
+
+/* update all the flows in ret-pool into sink-flows with <dest, dest-type>,
+and move them into sink-pool. */
+void intfns_inter_sink_ret_pool(FILE * file, VEC(intfns_flow, gc)** func_intop_ret_pool, 
+	VEC(intfns_flow, gc)** func_intop_sink_pool,gimple dest, unsigned int dest_type)
+{
	
+	int ix;
+	intfns_flow flow;
+	gimple intop;
+
+	fprintf(file, "\t4444");
+
+	for(ix = 0; VEC_iterate(intfns_flow, (*func_intop_ret_pool), ix, flow); ix ++)
+	{fprintf(file, "\t5555");
+		if(flow == NULL)
+			continue;
+		fprintf(file, "\t6666");
+
+		intop = INTFNS_FLOW_SRC(flow);
+
+		// update this flow
+		INTFNS_FLOW_TYPE(flow) = INTFNS_FLOW_INTOP_TO_SINK;
+		INTFNS_FLOW_DEST(flow) = dest;
+		INTFNS_FLOW_DEST_TYPE(flow) = dest_type;
+
+		// update the sink-status and func-ret-status for intop
+		INTFNS_INTOP_SINK(intop) = INTFNS_INTOP_TO_SINK;
+		if(INTFNS_INTOP_FUNC_RET(intop) == INTFNS_INTOP_TO_RET)
+			INTFNS_INTOP_FUNC_RET(intop) = INTFNS_INTOP_TO_CLEAN;
+		else if(INTFNS_INTOP_FUNC_RET(intop) == INTFNS_INTOP_TO_FUNC_AND_RET)
+			INTFNS_INTOP_FUNC_RET(intop) = INTFNS_INTOP_TO_FUNC;
+		else
+			;
+
+		// delete this flow out from intop-ret-pool, and insert it into intop-sink-pool
+		VEC_ordered_remove(intfns_flow, (*func_intop_ret_pool), ix);
+		ix --;
+		VEC_safe_push(intfns_flow, gc, (*func_intop_sink_pool), flow);	
+		fprintf(file, "\t7777");
+	}
+}
+
+/* a recursive process to transit intop->ret +++ ssa-name->sink. */
+void intfns_inter_select_ret(FILE* file, tree lhs, VEC(intfns_flow, gc)** func_intop_ret_pool,
+		VEC(intfns_flow, gc)** func_intop_sink_pool, VEC(intfns_flow, gc)** intop_sink_pool)
+{
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	/* if there is no more flows in intop->ret for func */
+	if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+		return;
+
+	if(TREE_CODE(lhs) != SSA_NAME)
+		return;
+
+	// check the status of lhs
+	if(TREE_INTFNS_BEING_ANALYZED(lhs) == 1)
+		return;
+	else
+		TREE_INTFNS_BEING_ANALYZED(lhs)= 1;
+
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{	
+			// check whether use-stmt is array[lhs] = xxxx.
+			use_lhs= gimple_assign_lhs(use_stmt);			
+			if((TREE_CODE(use_lhs) == ARRAY_REF)
+				&&(TREE_OPERAND(use_lhs, 1) == lhs))
+			{	// src is used at array-index, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_ARRAY);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}			
+
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);			
+			if((stmt_type == INTFNS_STMT_ADDRESS_GLOBAL))
+			{	// src is used at global-var, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_ADDRESS_GLOBAL);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if((stmt_type == INTFNS_STMT_UMUL_OFFSET)
+				||(stmt_type == INTFNS_STMT_SMUL_OFFSET))
+			{	// src is used at ptr-offset, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_ARRAY);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_PTR_PLUS)
+			{	// src is used at ptr-offset, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_PTR);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_IF)
+			{	// src is used at relation->if, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_IF);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_WHILE)
+			{	// src is used at relation->while, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_WHILE);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(stmt_type == INTFNS_STMT_ARRAY_REF)
+			{	// src is used at array-index, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_ARRAY);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_NARROW))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+			
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_inter_select_ret(file, gimple_assign_lhs (use_stmt), func_intop_ret_pool,
+						func_intop_sink_pool, intop_sink_pool);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+					
+					/* if there is no more flows in intop->ret for func */
+					if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+						BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// use-stmt->sink, transit
+				if(INTFNS_INTOP_SINK(use_stmt) == INTFNS_INTOP_TO_SINK)
+					; // fixme: transit flows
+			}
+			//narrow-op
+			//else if(stmt_type == INTFNS_STMT_NARROW)
+			// sanitization ops
+			else if((stmt_type >= INTFNS_STMT_SANTZ_AND_CONST)
+				&& (stmt_type <= INTFNS_STMT_SANTZ_MOD_VAR_CONST))
+			{	// narrow-op, if we do not consider narrow-op, we treat it as propagate-op
+				if(flag_intfns_omit_narrow)
+				{
+					if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+					{
+						INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+						// propagate, recursive call
+						intfns_inter_select_ret(file, gimple_assign_lhs (use_stmt), func_intop_ret_pool,
+							func_intop_sink_pool, intop_sink_pool);
+						INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+						
+						/* if there is no more flows in intop->ret for func */
+						if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+							BREAK_FROM_IMM_USE_STMT (iter)		
+					}
+				}
+			}
+			else
+				;	// continue
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_COND)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_IF)
+			{	// src is used at if, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_IF);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else
+			{	// src is used at while, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_WHILE);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{fprintf(file, "\t333");
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_SINK_LIB)
+			{	// src is used at sink-lib, move the flows in func-intop-ret-pool into func-intop-sink-pool
+			fprintf(file, "\t444");
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_LIB);
+				fprintf(file, "\t555");
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			if((INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_FUNC)
+				||(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_SINK))
+			{	// src is used at sink-extern-func, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_EXTERN_FUNC);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_NORMAL_FUNC)
+			{
+				// fixme: we need transit: param->ix|func +++ ix->sink
+				;
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+   			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_inter_select_ret(file, gimple_phi_result(use_stmt), func_intop_ret_pool,
+					func_intop_sink_pool, intop_sink_pool);
+				INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+				
+				/* if there is no more flows in intop->ret for func */
+				if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+					BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else
+				;	
+		}
+		else
+			;
+	}
+
+	TREE_INTFNS_BEING_ANALYZED(lhs) = 0;
+	return;
+}
+
+/* do stats work for the different types of flows*/
+void stats_intfns_flow_sinks(struct intfns_static_facts * sta, 
+ 	VEC(intfns_flow, gc)** flow_pool)
+{
+	int ix;
+	intfns_flow flow;
+	for(ix = 0; VEC_iterate(intfns_flow, (*flow_pool), ix, flow); ix ++)
+	{
+		switch(INTFNS_FLOW_DEST_TYPE(flow))
+		{
+			case INTFNS_SINK_IF:
+				sta->intop_if_sink_inter ++;break;
+			case INTFNS_SINK_WHILE:
+				sta->intop_while_sink_inter ++;break;
+			case INTFNS_SINK_LIB:
+				sta->intop_lib_sink_inter ++;break;
+			case INTFNS_SINK_ARRAY:
+				sta->intop_array_sink_inter ++;break;
+			case INTFNS_SINK_PTR:
+				sta->intop_ptr_sink_inter ++;break;
+			case INTFNS_SINK_EXTERN_FUNC:
+				sta->intop_extern_sink_inter ++;break;
+			case INTFNS_SINK_ADDRESS_GLOBAL:
+				sta->intop_address_global_sink_inter ++; break;
+			default:
+				break;
+		}
+	}
+}
+
+void filter_intfns_flow_sinks(VEC(intfns_flow, gc)** flow_pool, int sink_type)
+{
+	int ix;
+	intfns_flow flow;
+	gimple src;
+	for(ix = 0; VEC_iterate(intfns_flow, (*flow_pool), ix, flow); ix ++)
+		if(INTFNS_FLOW_DEST_TYPE(flow) == sink_type)
+		{
+			src = INTFNS_FLOW_SRC(flow);
+			INTFNS_INTOP_SINK(src) = INTFNS_INTOP_TO_CLEAN;
+		}
+}
+
+
+
+/* execution function for our pass */
+static unsigned int
+execute_intfns_inter (void)
+{
+	/* local vars*/	
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	VEC(intfns_flow, gc)** intop_sink_pool, **intop_func_pool, **intop_ret_pool, ** param_sink_pool;
+	struct intfns_static_facts * sta;
+	FILE* file;
+	int ix, iy;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_inter.txt", "a");
+	fprintf(file,"INTFNS-inter for %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+	if((DECL_STRUCT_FUNCTION(current_function_decl) == NULL) || (cfun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}
+
+	// to test a designated function particularly.
+	/*if((strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "bi_reverse") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "FindRecname") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "Perl_hv_store") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "Perl_hv_delete") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "Perl_hv_delete_ent") == 0)
+		)
+		;
+	else
+	{
+		fprintf(file, " PASS!!!\n");
+		fclose(file);
+		return 0;
+	}*/
+	
+
+	/* do some initialization */
+	intop_sink_pool = &(INTFNS_INFO_INTOP_SINK_POOL_FUN(cfun));	// to get the addr of current-func`s intfns-flow-pool		
+	intop_func_pool = &(INTFNS_INFO_INTOP_FUNC_POOL_FUN(cfun));			
+	intop_ret_pool = &(INTFNS_INFO_INTOP_RET_POOL_FUN(cfun));	
+	param_sink_pool = &(INTFNS_INFO_PARAM_SINK_POOL_FUN(cfun));
+	sta = INTFNS_INFO_STA_FUN(cfun);							// point to the struct to store statistics info
+	
+	fprintf(file, "\t>>begin");
+	
+	/*-----------------------------------------------------------------------------*/
+	/* 1. map the params into their first occurrence of ssa-name. */
+	struct intfns_param_facts param_facts[INTFNS_PARAM_NUM_MAX] = {0};
+	tree param, ssa;
+	ix = 0;
+	
+	for(param = DECL_ARGUMENTS(current_function_decl); param; param = TREE_CHAIN(param))
+	{
+		// currently, we only consider at most 16 params for current function.
+		if(ix == INTFNS_PARAM_NUM_MAX)
+			break;
+		
+		// we only consider those params of integer type
+		if(TREE_CODE(TREE_TYPE(param)) != INTEGER_TYPE)
+			continue;
+		
+		// traversal all the ssa-name in cfun
+		for(iy = 0; VEC_iterate(tree, SSANAMES(cfun), iy, ssa); iy ++)
+		{
+			if(ssa == NULL)
+				continue;
+			if((TREE_CODE(ssa) == SSA_NAME) && (param == SSA_NAME_VAR(ssa)))
+			{
+				// if this ssa is the use version of param
+				if(param_facts[ix].has_param_ssa == 0)
+				{
+					// if this ssa is the first one
+					param_facts[ix].has_param_ssa = 1;
+					param_facts[ix].param_ssa = ssa;
+				}
+				else
+				{
+					// if there has already existed on ssa, we choose the least one.
+					if(SSA_NAME_VERSION(ssa) < SSA_NAME_VERSION(param_facts[ix].param_ssa))
+						param_facts[ix].param_ssa = ssa;
+				}
+			}
+		}
+
+		ix ++;
+	}
+	fprintf(file, "\t>>param-map ok");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 2. intop->x|func +++ param-x->sink --->>> intop->sink */
+	ix = 0;
+	intfns_flow flow_intop_func, flow_param_sink;
+	bool found;
+	int param_ix;
+	
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow_intop_func); ix ++)
+	{	// intop-> x|func
+		param_ix = INTFNS_FLOW_PARAM_INDEX(flow_intop_func);
+		tree func_decl = gimple_call_fndecl(INTFNS_FLOW_DEST(flow_intop_func));
+		struct function * func = DECL_STRUCT_FUNCTION(func_decl);
+		if(func == NULL)
+			continue;
+		
+		// get func->param-sink-pool
+		VEC(intfns_flow, gc) * func_param_sink_pool = INTFNS_INFO_PARAM_SINK_POOL_FUN(func);
+		// get param-x->sink flow
+		found = false;
+		iy = 0;
+		for(iy = 0; VEC_iterate(intfns_flow, func_param_sink_pool, iy, flow_param_sink); iy ++)
+			if((flow_param_sink != NULL)
+				&&(INTFNS_FLOW_PARAM_INDEX(flow_param_sink) == param_ix))
+			{
+				found = true;
+				break;
+			}
+			
+		if(found)
+		{	// there exists param-ix->sink flow, lets transit.
+			if(INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink) > INTFNS_STEPS_MAX)
+				continue;
+
+			// at first, check the sink-status of intop (intop->x|func)
+			gimple intop = INTFNS_FLOW_SRC(flow_intop_func);
+			if(INTFNS_INTOP_SINK(intop) == INTFNS_INTOP_TO_SINK)
+			{
+				if(INTFNS_INTOP_STEPS(intop) <= INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink))
+					continue;
+
+				// find it, and update it
+				bool found_intop;
+				int iz;
+				intfns_flow flow_intop_sink;
+				found_intop = false;
+				for(iz = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), iz, flow_intop_sink); iz ++)
+					if(INTFNS_FLOW_SRC(flow_intop_sink) == intop)
+					{
+						found_intop = true;
+						break;
+					}
+
+				if(found_intop)
+				{
+					// update flow_src
+					INTFNS_FLOW_DEST(flow_intop_sink) = INTFNS_FLOW_DEST(flow_param_sink);
+					INTFNS_FLOW_STEPS(flow_intop_sink) = INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink);
+					INTFNS_FLOW_DEST_TYPE(flow_intop_sink) = INTFNS_FLOW_DEST_TYPE(flow_param_sink);
+					
+					// update the steps-status for src
+					INTFNS_INTOP_STEPS(intop) = INTFNS_FLOW_STEPS(flow_intop_sink);
+				}
+			}
+			else
+			{
+				// otherwise, create a new intop-sink-flow <src, dest, steps, dest-type>
+				bool build_succeed;
+				build_succeed = intfns_build_flow(intop_sink_pool, intop, INTFNS_FLOW_DEST(flow_param_sink),
+					INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink),
+					INTFNS_FLOW_INTOP_TO_SINK,
+					INTFNS_STMT_TYPE(intop), INTFNS_FLOW_DEST_TYPE(flow_param_sink));
+
+				// build the flow successfully
+				if(build_succeed)
+				{
+					// update the sink-status and steps-status of src				
+					INTFNS_INTOP_STEPS(intop) = INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink);
+					INTFNS_INTOP_SINK(intop) = INTFNS_INTOP_TO_SINK;
+				}
+			}
+		}
+	}
+
+	// cleanup the intop-func-pool
+	intfns_inter_cleanup_func_pool(intop_func_pool);
+	fprintf(file, "\t>>intop-func ok");
+	
+	/*-----------------------------------------------------------------------------*/
+	/* 3. fill the param->sink pool: param->intop +++ intop->sink --->>> param->sink*/
+	gimple ssa_def_stmt;
+	for(ix = 0; ix < INTFNS_PARAM_NUM_MAX; ix ++)
+		if(param_facts[ix].has_param_ssa == 1)
+			intfns_inter_select_param(file, param_facts[ix].param_ssa, ix, 
+				param_facts, intop_sink_pool, param_sink_pool);
+		
+	fprintf(file, "\t>>param-sink ok");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 4. intop->ret +++ intop1=call(fn); +++ intop1->sink --->>> intop->sink*/
+	gimple stmt, stmt_start;	
+	FOR_EACH_BB(bb)
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+    	{
+    		stmt = gsi_stmt(gsi);
+	  		if((stmt != NULL) && (gimple_code(stmt) == GIMPLE_CALL)
+				&& (INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_NORMAL_FUNC)
+				&& (gimple_has_lhs(stmt)))
+				// result = normal-func();
+	  		{
+	  			// result must be of ssa-name and of integer-type
+	  			tree result = gimple_call_lhs(stmt);
+				if((TREE_CODE(result) != SSA_NAME)
+					||(TREE_CODE(TREE_TYPE(result)) != INTEGER_TYPE))
+					continue;
+
+				// there should be intop->ret flows for this normal-func.				
+				struct function * func = DECL_STRUCT_FUNCTION(gimple_call_fndecl(stmt));
+				if(func == NULL)
+					continue;
+				VEC(intfns_flow, gc) ** func_intop_ret_pool = &(INTFNS_INFO_INTOP_RET_POOL_FUN(func));
+				VEC(intfns_flow, gc) ** func_intop_sink_pool = &(INTFNS_INFO_INTOP_SINK_POOL_FUN(func));
+				VEC(intfns_flow, gc) ** func_intop_func_pool = &(INTFNS_INFO_INTOP_FUNC_POOL_FUN(func));
+				if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+					continue;
+				fprintf(file, "\t11");
+				// recursively selet intop->ret into intop->sink
+				intfns_inter_select_ret(file, result, func_intop_ret_pool, func_intop_sink_pool,
+					intop_sink_pool);
+				fprintf(file, "\t22");
+				// clean up those updated intop->func
+				intfns_inter_cleanup_func_pool(func_intop_func_pool);
+	  		}
+		}
+
+	/*-----------------------------------------------------------------------------*/
+	/* 5. do statistics and dump work. */
+	sta->intop_sink_inter = VEC_length(intfns_flow, (*intop_sink_pool));
+	sta->intop_func_inter = VEC_length(intfns_flow, (*intop_func_pool));
+	sta->intop_ret_inter = VEC_length(intfns_flow, (*intop_ret_pool));
+	sta->param_sink_inter = VEC_length(intfns_flow, (*param_sink_pool));
+
+	stats_intfns_flow_sinks(sta, intop_sink_pool);
+	//stats_intfns_flow_sinks(sta, param_sink_pool);
+
+	// delete the instrumentation for designated sinks
+	//filter_intfns_flow_sinks(intop_sink_pool, INTFNS_SINK_ARRAY);
+	
+	/* dump the selected intops */
+	dump_selected_intop(intop_sink_pool, intop_func_pool, 
+		intop_ret_pool, param_sink_pool, INTFNS_INTER);
+	
+	fprintf(file, "\t>>finish\n");
+	fclose(file);
+	return 1;
+}
+
+
+/* gate for our pass, invoked by -fintfns and -fintfns-inter */
+static bool
+gate_intfns_inter (void)
+{
+	return (flag_intfns && flag_intfns_inter);
+}
+
+/* pass_intfns_inter definition */
+struct gimple_opt_pass pass_intfns_inter =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_inter",					/* name */
+  		gate_intfns_inter,				/* gate */
+  		execute_intfns_inter,			/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_INTER,			/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------intfns-io2bo and inter-p------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* a recursive process to transit param-> ssa-name +++ ssa-name->sink. */
+void intfns_inter_io2bo_select_param(FILE* file, tree lhs, int index, struct intfns_param_facts * param_facts, 
+		VEC(intfns_flow, gc)** intop_sink_pool, VEC(intfns_flow, gc)** param_sink_pool)
+{
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+	if((param_facts[index].has_param_flow == 1) 
+		&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+		return;
+
+	if(TREE_CODE(lhs) != SSA_NAME)
+		return;
+
+	// check the status of lhs
+	if(TREE_INTFNS_BEING_ANALYZED(lhs) == 1)
+		return;
+	else
+		TREE_INTFNS_BEING_ANALYZED(lhs)= 1;
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{		
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);			
+			if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+			
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_inter_io2bo_select_param(file, gimple_assign_lhs (use_stmt), index, param_facts, intop_sink_pool,
+						param_sink_pool);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+					
+					/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+					if((param_facts[index].has_param_flow == 1)
+						&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+						BREAK_FROM_IMM_USE_STMT (iter)			
+				}
+			}
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// use-stmt->sink, transit
+				if(INTFNS_INTOP_SINK(use_stmt) == INTFNS_INTOP_TO_SINK)
+					intfns_transit_param_flow(intop_sink_pool, param_sink_pool, index,
+						param_facts, use_stmt);
+			}
+			else
+				;	// continue
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_SINK_LIB)
+			{	// src is used at sink-lib, create imm-param-sink flow
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_LIB);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_SINK)
+			{	// src is used at sink-extern-func, create imm-param-sink flow				
+				intfns_create_imm_param_flow(param_sink_pool, index, param_facts, 
+					use_stmt,INTFNS_SINK_EXTERN_FUNC);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_NORMAL_FUNC)
+			{
+				// fixme: we need transit: param->ix|func +++ ix->sink
+				;
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+   			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_inter_io2bo_select_param(file, gimple_phi_result(use_stmt), index, param_facts, intop_sink_pool,
+					param_sink_pool);
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+				
+				/* if param-ix has already been analyzed as flowing into sink immediately, return. */
+				if((param_facts[index].has_param_flow == 1) 
+					&& (INTFNS_FLOW_STEPS(param_facts[index].param_flow) == 0))
+					BREAK_FROM_IMM_USE_STMT (iter)			
+			}
+			else
+				;
+		}
+		else
+			;
+	}
+
+	TREE_INTFNS_BEING_ANALYZED(lhs) = 0;
+	return;
+}
+
+/* a recursive process to transit intop->ret +++ ssa-name->sink. */
+void intfns_inter_io2bo_select_ret(FILE* file, tree lhs, VEC(intfns_flow, gc)** func_intop_ret_pool,
+		VEC(intfns_flow, gc)** func_intop_sink_pool, VEC(intfns_flow, gc)** intop_sink_pool)
+{
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	/* if there is no more flows in intop->ret for func */
+	if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+		return;
+
+	if(TREE_CODE(lhs) != SSA_NAME)
+		return;
+
+	// check the status of lhs
+	if(TREE_INTFNS_BEING_ANALYZED(lhs) == 1)
+		return;
+	else
+		TREE_INTFNS_BEING_ANALYZED(lhs)= 1;
+	
+	// traversal each use-var of lhs
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+		if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+		{		
+			// the type of stmt
+			stmt_type = INTFNS_STMT_TYPE(use_stmt);			
+			if((stmt_type == INTFNS_STMT_PROPAGATE)
+				|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE))
+			{	
+				// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+				// we should first get the next-use-stmt;
+				if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+					use_stmt = gimple_next(use_stmt);
+			
+				// before propagate, we should check the analyze-status of this propagate-op.
+				// if this propagate-op is being analyzed, we should continue;
+				// else, we should set the status into being-analyzed.
+				// doing so, to eliminate the infinite calls
+				if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+				{
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+					// propagate, recursive call
+					intfns_inter_io2bo_select_ret(file, gimple_assign_lhs (use_stmt), func_intop_ret_pool,
+						func_intop_sink_pool, intop_sink_pool);
+					INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+					
+					/* if there is no more flows in intop->ret for func */
+					if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+						BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+			else if((stmt_type >= FNS_UADD)
+				&& (stmt_type <= FNS_SSHL))
+			{	// use-stmt->sink, transit
+				if(INTFNS_INTOP_SINK(use_stmt) == INTFNS_INTOP_TO_SINK)
+					; // fixme: transit flows
+			}		
+			else
+				;	// continue
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_CALL)
+		{
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_SINK_LIB)
+			{	// src is used at sink-lib, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_LIB);				
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_EXTERNAL_SINK)
+			{	// src is used at sink-extern-func, move the flows in func-intop-ret-pool into func-intop-sink-pool
+				intfns_inter_sink_ret_pool(file, func_intop_ret_pool, func_intop_sink_pool,
+					use_stmt, INTFNS_SINK_EXTERN_FUNC);
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else if(INTFNS_STMT_TYPE(use_stmt) == INTFNS_STMT_NORMAL_FUNC)
+			{
+				// fixme: we need transit: param->ix|func +++ ix->sink
+				;
+			}
+			else
+				;
+		}
+		else if(gimple_code(use_stmt) == GIMPLE_PHI)
+		{	
+			// just like INTFNS-INTOP-PROPAGATE and INTFNS-INTOP-PRE-DENIED
+			// we should check analyzed-status of this gimple-phi
+			// in order to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+   			{
+				INTFNS_INTOP_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_inter_io2bo_select_ret(file, gimple_phi_result(use_stmt), func_intop_ret_pool,
+					func_intop_sink_pool, intop_sink_pool);
+				INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+				
+				/* if there is no more flows in intop->ret for func */
+				if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+					BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else
+				;	
+		}
+		else
+			;
+	}
+
+	TREE_INTFNS_BEING_ANALYZED(lhs) = 0;
+	return;
+}
+
+
+/* execution function for our pass */
+static unsigned int
+execute_intfns_io2bo_inter (void)
+{
+	/* local vars*/	
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	VEC(intfns_flow, gc)** intop_sink_pool, **intop_func_pool, **intop_ret_pool, ** param_sink_pool;
+	struct intfns_static_facts * sta;
+	FILE* file;
+	int ix, iy;
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_io2bo_inter.txt", "a");
+	fprintf(file,"INTFNS-io2bo-inter for %s(): \n", lang_hooks.decl_printable_name(current_function_decl, 2));
+	if((DECL_STRUCT_FUNCTION(current_function_decl) == NULL) || (cfun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}	
+
+	/* do some initialization */
+	intop_sink_pool = &(INTFNS_INFO_INTOP_SINK_POOL_FUN(cfun));	// to get the addr of current-func`s intfns-flow-pool		
+	intop_func_pool = &(INTFNS_INFO_INTOP_FUNC_POOL_FUN(cfun));			
+	intop_ret_pool = &(INTFNS_INFO_INTOP_RET_POOL_FUN(cfun));	
+	param_sink_pool = &(INTFNS_INFO_PARAM_SINK_POOL_FUN(cfun));
+	sta = INTFNS_INFO_STA_FUN(cfun);							// point to the struct to store statistics info
+	
+	fprintf(file, "\t>>begin");
+	
+	/*-----------------------------------------------------------------------------*/
+	/* 1. map the params into their first occurrence of ssa-name. */
+	struct intfns_param_facts param_facts[INTFNS_PARAM_NUM_MAX] = {0};
+	tree param, ssa;
+	ix = 0;
+	
+	for(param = DECL_ARGUMENTS(current_function_decl); param; param = TREE_CHAIN(param))
+	{
+		// currently, we only consider at most 16 params for current function.
+		if(ix == INTFNS_PARAM_NUM_MAX)
+			break;
+		
+		// we only consider those params of integer type
+		if(TREE_CODE(TREE_TYPE(param)) != INTEGER_TYPE)
+			continue;
+		
+		// traversal all the ssa-name in cfun
+		for(iy = 0; VEC_iterate(tree, SSANAMES(cfun), iy, ssa); iy ++)
+		{
+			if(ssa == NULL)
+				continue;
+			if((TREE_CODE(ssa) == SSA_NAME) && (param == SSA_NAME_VAR(ssa)))
+			{
+				// if this ssa is the use version of param
+				if(param_facts[ix].has_param_ssa == 0)
+				{
+					// if this ssa is the first one
+					param_facts[ix].has_param_ssa = 1;
+					param_facts[ix].param_ssa = ssa;
+				}
+				else
+				{
+					// if there has already existed on ssa, we choose the least one.
+					if(SSA_NAME_VERSION(ssa) < SSA_NAME_VERSION(param_facts[ix].param_ssa))
+						param_facts[ix].param_ssa = ssa;
+				}
+			}
+		}
+
+		ix ++;
+	}
+	fprintf(file, "\t>>param-map ok");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 2. intop->x|func +++ param-x->sink --->>> intop->sink */
+	ix = 0;
+	intfns_flow flow_intop_func, flow_param_sink;
+	bool found;
+	int param_ix;
+	
+	for(ix = 0; VEC_iterate(intfns_flow, (*intop_func_pool), ix, flow_intop_func); ix ++)
+	{	// intop-> x|func
+		param_ix = INTFNS_FLOW_PARAM_INDEX(flow_intop_func);
+		tree func_decl = gimple_call_fndecl(INTFNS_FLOW_DEST(flow_intop_func));
+		struct function * func = DECL_STRUCT_FUNCTION(func_decl);
+		if(func == NULL)
+			continue;
+		
+		// get func->param-sink-pool
+		VEC(intfns_flow, gc) * func_param_sink_pool = INTFNS_INFO_PARAM_SINK_POOL_FUN(func);
+		// get param-x->sink flow
+		found = false;
+		iy = 0;
+		for(iy = 0; VEC_iterate(intfns_flow, func_param_sink_pool, iy, flow_param_sink); iy ++)
+			if((flow_param_sink != NULL)
+				&&(INTFNS_FLOW_PARAM_INDEX(flow_param_sink) == param_ix))
+			{
+				found = true;
+				break;
+			}
+			
+		if(found)
+		{	// there exists param-ix->sink flow, lets transit.
+			if(INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink) > INTFNS_STEPS_MAX)
+				continue;
+
+			// at first, check the sink-status of intop (intop->x|func)
+			gimple intop = INTFNS_FLOW_SRC(flow_intop_func);
+			if(INTFNS_INTOP_SINK(intop) == INTFNS_INTOP_TO_SINK)
+			{
+				if(INTFNS_INTOP_STEPS(intop) <= INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink))
+					continue;
+
+				// find it, and update it
+				bool found_intop;
+				int iz;
+				intfns_flow flow_intop_sink;
+				found_intop = false;
+				for(iz = 0; VEC_iterate(intfns_flow, (*intop_sink_pool), iz, flow_intop_sink); iz ++)
+					if(INTFNS_FLOW_SRC(flow_intop_sink) == intop)
+					{
+						found_intop = true;
+						break;
+					}
+
+				if(found_intop)
+				{
+					// update flow_src
+					INTFNS_FLOW_DEST(flow_intop_sink) = INTFNS_FLOW_DEST(flow_param_sink);
+					INTFNS_FLOW_STEPS(flow_intop_sink) = INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink);
+					INTFNS_FLOW_DEST_TYPE(flow_intop_sink) = INTFNS_FLOW_DEST_TYPE(flow_param_sink);
+					
+					// update the steps-status for src
+					INTFNS_INTOP_STEPS(intop) = INTFNS_FLOW_STEPS(flow_intop_sink);
+				}
+			}
+			else
+			{
+				// otherwise, create a new intop-sink-flow <src, dest, steps, dest-type>
+				bool build_succeed;
+				build_succeed = intfns_build_flow(intop_sink_pool, intop, INTFNS_FLOW_DEST(flow_param_sink),
+					INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink),
+					INTFNS_FLOW_INTOP_TO_SINK,
+					INTFNS_STMT_TYPE(intop), INTFNS_FLOW_DEST_TYPE(flow_param_sink));
+
+				// build the flow successfully
+				if(build_succeed)
+				{
+					// update the sink-status and steps-status of src				
+					INTFNS_INTOP_STEPS(intop) = INTFNS_FLOW_STEPS(flow_intop_func) + INTFNS_FLOW_STEPS(flow_param_sink);
+					INTFNS_INTOP_SINK(intop) = INTFNS_INTOP_TO_SINK;
+				}
+			}
+		}
+	}
+
+	// cleanup the intop-func-pool
+	intfns_inter_cleanup_func_pool(intop_func_pool);
+	fprintf(file, "\t>>intop-func ok");
+	
+	/*-----------------------------------------------------------------------------*/
+	/* 3. fill the param->sink pool: param->intop +++ intop->sink --->>> param->sink*/
+	gimple ssa_def_stmt;
+	for(ix = 0; ix < INTFNS_PARAM_NUM_MAX; ix ++)
+		if(param_facts[ix].has_param_ssa == 1)
+			intfns_inter_io2bo_select_param(file, param_facts[ix].param_ssa, ix, 
+				param_facts, intop_sink_pool, param_sink_pool);
+		
+	fprintf(file, "\t>>param-sink ok");
+
+	/*-----------------------------------------------------------------------------*/
+	/* 4. intop->ret +++ intop1=call(fn); +++ intop1->sink --->>> intop->sink*/
+	gimple stmt, stmt_start;	
+	FOR_EACH_BB(bb)
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+    	{
+    		stmt = gsi_stmt(gsi);
+	  		if((stmt != NULL) && (gimple_code(stmt) == GIMPLE_CALL)
+				&& (INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_NORMAL_FUNC)
+				&& (gimple_has_lhs(stmt)))
+				// result = normal-func();
+	  		{
+	  			// result must be of ssa-name and of integer-type
+	  			tree result = gimple_call_lhs(stmt);
+				if((TREE_CODE(result) != SSA_NAME)
+					||(TREE_CODE(TREE_TYPE(result)) != INTEGER_TYPE))
+					continue;
+
+				// there should be intop->ret flows for this normal-func.				
+				struct function * func = DECL_STRUCT_FUNCTION(gimple_call_fndecl(stmt));
+				if(func == NULL)
+					continue;
+				VEC(intfns_flow, gc) ** func_intop_ret_pool = &(INTFNS_INFO_INTOP_RET_POOL_FUN(func));
+				VEC(intfns_flow, gc) ** func_intop_sink_pool = &(INTFNS_INFO_INTOP_SINK_POOL_FUN(func));
+				VEC(intfns_flow, gc) ** func_intop_func_pool = &(INTFNS_INFO_INTOP_FUNC_POOL_FUN(func));
+				if(VEC_length(intfns_flow, (*func_intop_ret_pool)) == 0)
+					continue;
+				fprintf(file, "\t11");
+				// recursively selet intop->ret into intop->sink
+				intfns_inter_io2bo_select_ret(file, result, func_intop_ret_pool, func_intop_sink_pool,
+					intop_sink_pool);
+				fprintf(file, "\t22");
+				// clean up those updated intop->func
+				intfns_inter_cleanup_func_pool(func_intop_func_pool);
+	  		}
+		}
+
+	/*-----------------------------------------------------------------------------*/
+	/* 5. do statistics and dump work. */
+	sta->intop_sink_inter = VEC_length(intfns_flow, (*intop_sink_pool));
+	sta->intop_func_inter = VEC_length(intfns_flow, (*intop_func_pool));
+	sta->intop_ret_inter = VEC_length(intfns_flow, (*intop_ret_pool));
+	sta->param_sink_inter = VEC_length(intfns_flow, (*param_sink_pool));
+
+	stats_intfns_flow_sinks(sta, intop_sink_pool);
+	//stats_intfns_flow_sinks(sta, param_sink_pool);
+
+	// delete the instrumentation for designated sinks
+	//filter_intfns_flow_sinks(intop_sink_pool, INTFNS_SINK_ARRAY);
+	
+	/* dump the selected intops */
+	dump_selected_intop(intop_sink_pool, intop_func_pool, 
+		intop_ret_pool, param_sink_pool, INTFNS_INTER);
+	
+	fprintf(file, "\t>>finish\n");
+	fclose(file);
+	return 1;
+}
+
+
+
+/* pass_intfns_inter definition */
+struct gimple_opt_pass pass_intfns_io2bo_inter =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_io2bo_inter",					/* name */
+  		gate_intfns_io2bo,				/* gate */
+  		execute_intfns_io2bo_inter,			/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_IO2BO_INTER,		/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+/*---------------------------------------------------------------------------------*/
+/*----------------------intfns-io2bo guard lib sinks ------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* insert check code after add, sub, and left shift, in both signed and unsigned forms. */
+static unsigned int
+intfns_io2bo_guard_sink(gimple_stmt_iterator *instr_gsi,
+							location_t location, int width, tree arg)
+{
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u, v, w, m, n;
+	gimple gg;
+	gimple_seq seq, stmts;
+
+	// current we focus on 32 bits.
+	if(width != 32)	
+		return;
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block (intfns-io-printer).	*/
+	then_bb = create_empty_bb (cond_bb);
+	make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+	}
+
+	/*-------------------2. create the guard-check-code and insert them into cond-bb---------------*/
+	seq = gimple_seq_alloc ();
+
+	/* 2.1 create the guard code */
+	/* build 'arg & dirty-mask' */
+	t = build2 (BIT_AND_EXPR, unsigned_type_node, arg, DIRTY_mask);
+	/* build  'arg&dirty-mask == dirty-data' */
+	t = build2 (EQ_EXPR, boolean_type_node, t, DIRTY_data);
+	t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+ 	gimple_seq_add_seq (&seq, stmts);
+ 	cond = make_rename_temp (boolean_type_node, "__intfns_io2bo_guard_cond");
+ 	gg = gimple_build_assign  (cond, t);
+	gimple_set_location (gg, location);
+  	gimple_seq_add_stmt (&seq, gg);
+
+	/* 2.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 2.3 insert these code into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------3. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+	gg = gimple_build_call (intfns_io2bo_guard_fndecl, 1, 
+		intfns_file_function_line_tree (location));
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*--------------------------4. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* guard lib sinks */
+static unsigned int
+execute_intfns_io2bo_guard (void)
+{
+	/* a file used to log this process */
+	FILE * file_intfns_print = fopen("/tmp/log_intfns_io2bo_guard.txt", "a");
+	if(file_intfns_print == NULL)
+	{
+		printf("ERROR: fail to open file - log_intfns_io2bo_guard.txt\n");
+		return 0;
+	}
+	fprintf(file_intfns_print, "$intfns-io2bo-guard %s():\n",
+		lang_hooks.decl_printable_name(current_function_decl, 2));
+	if(DECL_STRUCT_FUNCTION(current_function_decl) == NULL)
+	{
+		fprintf(file_intfns_print, "$NO function* field.\n");
+		fprintf(file_intfns_print, "$intfns-io2bo-guard ends here.\n\n");
+		fclose(file_intfns_print);
+		return 0;
+	}
+
+	/* insert checks code for each integer operations */
+	basic_block bb, next;
+	int saved_last_basic_block = last_basic_block;
+	gimple_stmt_iterator gsi;
+	gimple stmt;
+	tree arg;
+	char * fun_name;
+	int width;
+	int count = 0;			/* to record the number of lib sinks */
+
+	bb = ENTRY_BLOCK_PTR ->next_bb;
+  	do
+	{
+      	next = bb->next_bb;
+		for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi)){
+			stmt = gsi_stmt (gsi);
+			
+			switch (gimple_code (stmt))	/* to check the type of stmt */
+			{
+				/* guard sink lib-func:
+					buf = malloc(0); buf = alloc(0);
+					buf=realloc(1); bzero(1); 
+					bcopy(2); memmove(2); memset(2); memcpy(2);
+					movmem(2); strncat(2); strncpy(2); swab(2);  */
+				case GIMPLE_CALL:			
+					if(gimple_call_fndecl(stmt) == NULL)
+						break;
+					fun_name = IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt)));	/* func name */
+
+					/* get the specific sink-arg, which needs to be guarded.  */
+					if((strcmp(fun_name, "malloc") == 0) ||(strcmp(fun_name, "alloc") == 0))
+						arg = gimple_call_arg(stmt, 0);
+					else if((strcmp(fun_name, "realloc") == 0) ||(strcmp(fun_name, "bzero") == 0))
+						arg = gimple_call_arg(stmt, 1);
+					else if ((strcmp(fun_name, "bcopy") == 0) ||(strcmp(fun_name, "memmove") == 0) ||
+						(strcmp(fun_name, "memset") == 0) ||(strcmp(fun_name, "memcpy") == 0) ||
+						(strcmp(fun_name, "movmem") == 0) ||(strcmp(fun_name, "strncat") == 0) ||
+						(strcmp(fun_name, "strncpy") == 0) ||(strcmp(fun_name, "swab") == 0))
+						arg = gimple_call_arg(stmt, 2);
+					else
+						break;
+
+					/* the width of sink-arg */
+					width =  TREE_INT_CST_LOW(TYPE_SIZE(TREE_TYPE(arg)));
+					if(width == 32)
+					{
+						intfns_io2bo_guard_sink(&gsi, gimple_location(stmt), width, arg);
+						count ++;
+					}
+					break;
+				default:
+					;
+			}
+    	}
+		bb = next;
+  	}
+	while(bb && bb->index <= saved_last_basic_block);
+	
+	fprintf (file_intfns_print, "\ttotal %d lib sinks are guarded.\n", count);
+	fprintf (file_intfns_print, "$intfns-insert ends here.\n\n");
+	fclose (file_intfns_print);
+	
+	/* dump the number of lib-sink guarded into file */
+	if(count > 0)
+	{
+		FILE * file_dump = fopen("/tmp/log_intfns_io2bo_guard_no.txt", "a");
+		fprintf(file_dump, "%d\n", count);
+		fclose(file_dump);
+	}
+	return 1;
+
+}
+
+
+/* pass_intfns_inter definition */
+struct gimple_opt_pass pass_intfns_io2bo_guard =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_io2bo_guard",			/* name */
+  		gate_intfns_io2bo,				/* gate */
+  		execute_intfns_io2bo_guard,		/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_IO2BO_GUARD,		/* tv_id */
+  		0, 							/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		0 							/* todo_flags_finish */
+ 	}
+};
+
+
+/*---------------------------------------------------------------------------------*/
+/*---------------------  intfns-begin, do initializations for intfns  -------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* an initialization pass for intfns.
+	we use function->intfns-info to store all the information we collect during our static analysis.
+	and the intfns-info have 4 intfns-flow pools and another struct as counter.
+	therefore, we apply space for these pools and counter.
+	
+	besides, we also allocate a hash table to store the sink-lib info, where all the sensitive
+	function calls and the sensitive arguement are indicated.
+
+	it is a quite simple pass. 
+	we exploit the GCC-VEC to manage all the space we applied.
+*/
+
+
+/* init the sink-lib-specs hash table. */
+void init_sink_lib_specs(void)
+{
+	int ix, count;
+	void ** slot;
+	sink_lib_specs_htab = htab_create(20, func_specs_hash_fun, 
+		func_specs_hash_eq, NULL);
+	count = sizeof(sink_lib_specs)/sizeof(struct intfns_func_specs_node);
+
+	for(ix = 0; ix < count; ix ++)
+	{
+		slot = htab_find_slot(sink_lib_specs_htab, (void*)(&sink_lib_specs[ix]), INSERT);
+		if(slot != NULL && !(*slot))
+			(*slot) = (void*)(&sink_lib_specs[ix]);
+	}
+}
+
+/* init the extern-func-specs hash table. */
+void init_extern_func_specs(void)
+{
+	int ix, count;
+	void ** slot;
+	extern_func_specs_htab = htab_create(20, func_specs_hash_fun, 
+		func_specs_hash_eq, NULL);
+	count = sizeof(extern_func_specs)/sizeof(struct intfns_func_specs_node);
+
+	for(ix = 0; ix < count; ix ++)
+	{
+		slot = htab_find_slot(extern_func_specs_htab, (void*)(&extern_func_specs[ix]), INSERT);
+		if(slot != NULL && !(*slot))
+			(*slot) = (void*)(&extern_func_specs[ix]);
+	}
+}
+
+hashval_t func_specs_hash_fun(const PTR s)
+{
+	struct intfns_func_specs_node * node = (struct intfns_func_specs_node *) s;
+	int len = strlen(node->name);
+	int ix, hash;
+
+	for(hash = 0, ix = 0; ix < len; ix ++)
+		hash += (((int)((node->name)[ix]))<< ix);
+
+	return ((hashval_t)(hash%211));
+}
+
+int func_specs_hash_eq(const void *s1, const void * s2)
+{
+	struct intfns_func_specs_node * n1 = (struct intfns_func_specs_node *) s1;
+	struct intfns_func_specs_node * n2 = (struct intfns_func_specs_node *) s2;
+
+	return !(strncmp(n1->name, n2->name, MAX_NAME_LENGTH));
+}
+
+/* destroy the sink-lib-spec hash tab */
+void destroy_sink_lib_specs(void)
+{
+	htab_delete(sink_lib_specs_htab);
+}
+
+/* destroy the extern-func-spec hash tab */
+void destroy_extern_func_specs(void)
+{
+	htab_delete(extern_func_specs_htab);
+}
+
+/* get the sink-lib-arg for STR, -1 means that it is not sink-lib-call*/
+int find_sink_lib_arg(char * str)
+{
+	void ** slot;
+	struct intfns_func_specs_node sn;
+	strncpy(sn.name, str, MAX_NAME_LENGTH);
+	slot = htab_find_slot(sink_lib_specs_htab, (void*)(&sn), NO_INSERT);
+
+	if( slot != NULL)
+		return ((struct intfns_func_specs_node *)(*slot))->arg;
+	else
+		return -1;
+}
+
+/* get the sink-type for STR, 1 means that it would use its args in a sink-call. 
+0 means it would not use its args sensitively, therefore, we could treat such external
+functions as uncritical one. */
+int find_extern_func_sink(char * str)
+{
+	void ** slot;
+	struct intfns_func_specs_node sn;
+	strncpy(sn.name, str, MAX_NAME_LENGTH);
+	slot = htab_find_slot(extern_func_specs_htab, (void*)(&sn), NO_INSERT);
+
+	if( slot != NULL)
+		return ((struct intfns_func_specs_node *)(*slot))->arg;
+	else
+		return -1;
+}
+
+/* execution function for pass_intfns_begin */
+static unsigned int
+execute_intfns_begin (void)
+{
+	struct function * fun = NULL;
+	struct cgraph_node * call_it;
+	struct intfns_facts * ifs;
+
+	/* travesal each func-decl in this UNIT and allocate the intfns-flow pools for each one. */
+	for(call_it = cgraph_nodes; call_it; call_it = call_it-> next)
+	{
+		fun = DECL_STRUCT_FUNCTION(call_it->decl);
+
+		if(fun != NULL)
+		{
+			/*ggc_alloc_cleared is used to allocate HEAP space.*/
+			ifs = (struct intfns_facts*)ggc_alloc_cleared(sizeof(struct intfns_facts));
+
+			/* initial the intfns-flow pools. */
+			INTFNS_INFO_INTOP_SINK_POOL(ifs) = VEC_alloc(intfns_flow, gc, 50);
+			INTFNS_INFO_INTOP_FUNC_POOL(ifs) = VEC_alloc(intfns_flow, gc, 50);
+			INTFNS_INFO_INTOP_RET_POOL(ifs) = VEC_alloc(intfns_flow, gc, 10);
+			INTFNS_INFO_PARAM_SINK_POOL(ifs) = VEC_alloc(intfns_flow, gc, 10);
+
+			/*initial the static facts*/
+			INTFNS_INFO_STA(ifs) = (struct intfns_static_facts*)ggc_alloc_cleared(sizeof(struct intfns_static_facts));
+			memset(INTFNS_INFO_STA(ifs)->func_name, 0x00, 128);
+			INTFNS_INFO_STA(ifs)->stmt_total = 0;
+			INTFNS_INFO_STA(ifs)->intop_total = 0;
+			INTFNS_INFO_STA(ifs)->intop_mul_offset = 0;
+			INTFNS_INFO_STA(ifs)->intop_shl_const = 0;
+			INTFNS_INFO_STA(ifs)->intop_sink_intra = 0;
+			INTFNS_INFO_STA(ifs)->intop_func_intra = 0;
+			INTFNS_INFO_STA(ifs)->intop_ret_intra = 0;
+
+			/* sanitizatio ops */
+			INTFNS_INFO_STA(ifs)->intop_narrow = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_and_const = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_mod_const = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_and_array = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_mod_const = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_and_if = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_or_if = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_and_mask = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_mod_sizeof = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_and_var_const = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_mod_var_const = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_const_narrow = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_unused = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_uncritical = 0;
+			INTFNS_INFO_STA(ifs)->intop_santz_reverse = 0;
+
+			/* intop santzd by our sanitization ops */
+			INTFNS_INFO_STA(ifs)->intop_santzd_unused = 0;
+			INTFNS_INFO_STA(ifs)->intop_santzd_uncritical = 0;
+			INTFNS_INFO_STA(ifs)->intop_santzd_const_narrow = 0;
+			INTFNS_INFO_STA(ifs)->intop_santzd_reverse = 0;
+			INTFNS_INFO_STA(ifs)->intop_santzd_hybrid = 0;
+
+			
+			/* intop selected by our selection strategy. */
+			INTFNS_INFO_STA(ifs)->intop_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_func_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_ret_inter = 0;
+			INTFNS_INFO_STA(ifs)->param_sink_inter = 0;	
+			INTFNS_INFO_STA(ifs)->intop_if_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_while_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_lib_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_array_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_ptr_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_extern_sink_inter = 0;
+			INTFNS_INFO_STA(ifs)->intop_address_global_sink_inter = 0;
+
+			INTFNS_INFO(fun) = (char *) ifs;
+		}
+				
+	}
+
+	/* init the sink-lib-specs. */
+	init_sink_lib_specs();
+	/* init the extern-func-specs */
+	init_extern_func_specs();
+	
+	return 1;
+}
+
+/* gate for our pass, invoked by -fintfns */
+static bool
+gate_intfns_begin (void)
+{
+	return flag_intfns;
+}
+
+/* pass_intfns_begin definition */
+struct ipa_opt_pass_d pass_intfns_begin =
+{
+ {
+  IPA_PASS,
+  "intfns_begin",		                /* name */
+  gate_intfns_begin,					/* gate */
+  execute_intfns_begin,			        /* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_INTFNS_BEGIN,		/* tv_id */
+  PROP_ssa,	            /* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0                     /* todo_flags_finish */
+ },
+ NULL,		        /* generate_summary */
+ NULL,				/* write_summary */
+ NULL,				/* read_summary */
+ NULL,				/* function_read_summary */
+ 0,					/* TODOs */
+ NULL,			    /* function_transform */
+ NULL				/* variable_transform */
+};
+
+/*---------------------------------------------------------------------------------*/
+/*---------------------  intfns-finish, do ending work for intfns---------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* an ending pass for intfns.
+	here, we have to free all the space we have applied in pass-intfns-begin.
+	for the 4 intfns-flow pools, we have to iterate these pools and free each element in them.(through
+	the functon infns-flow-pool-destroy)
+
+	as for the counter, we want to print them into files for statistics.
+
+	at last, the sink-lib hash table is destroyed at last.
+*/
+
+/* dump all the static counter into a file. */
+void dump_intfns_sta(struct intfns_static_facts * sta)
+{

+	FILE* file;
+	// .txt file
+	file = fopen("/tmp/log_intfns_finish.txt","a");
+	fprintf(file, "FOR %s():\n", sta->func_name);
+
+
+	/* total */
+	fprintf(file, "\tall-stmt: #%u, intop: #%u, mul-offset: #%u, shl-const:#%u\n", 
+		sta->stmt_total, sta->intop_total, sta->intop_mul_offset, sta->intop_shl_const);
+
+	/* intra */
+	fprintf(file, "\tat intra phase: intop->sink: %u, intop->func: %u, intop->ret: %u\n",
+		sta->intop_sink_intra, sta->intop_func_intra, sta->intop_ret_intra);
+
+	/* inter */
+	fprintf(file, "\tat inter phase: intop->sink: %u, intop->func: %u, intop->ret: %u, param->sink: %u\n",
+		sta->intop_sink_inter, sta->intop_func_inter, sta->intop_ret_inter, sta->param_sink_inter);
+	
+	fprintf(file, "\n\n");
+	fclose(file);
+
+	// .bin file
+	FILE * file_bin;
+	file_bin = fopen("/tmp/log_intfns_finish.bin","ab");
+	if(fwrite(sta, sizeof(struct intfns_static_facts), 1, file_bin) != 1)
+		printf("file_bin ERROR");
+	fclose(file_bin);
+}
+
+/* free each of the flow in the pool*/
+void intfns_flow_pool_destroy(VEC(intfns_flow, gc) ** pool)
+{
+	int ix;
+	intfns_flow flow;
+
+	for(ix = 0; VEC_iterate(intfns_flow, (*pool), ix, flow); ix ++)
+		if(flow != NULL)
+			free(flow);
+}
+
+/* execution function for pass_intfns_finish */
+static unsigned int
+execute_intfns_finish (void)
+{
+	struct function * fun = NULL;
+	struct cgraph_node * it;
+	struct intfns_facts * ifs;
+	int ix;
+	intfns_flow flow;
+
+	for(it = cgraph_nodes; it; it = it->next)
+	{
+		fun = DECL_STRUCT_FUNCTION(it->decl);
+
+		if(fun != NULL)
+		{
+			ifs = (struct intfns_facts *) INTFNS_INFO(fun);
+			if(ifs)
+			{
+				/* release the intfns-flow pools */
+				intfns_flow_pool_destroy(&(INTFNS_INFO_INTOP_SINK_POOL(ifs)));
+				intfns_flow_pool_destroy(&(INTFNS_INFO_INTOP_FUNC_POOL(ifs)));
+				intfns_flow_pool_destroy(&(INTFNS_INFO_INTOP_RET_POOL(ifs)));
+				intfns_flow_pool_destroy(&(INTFNS_INFO_PARAM_SINK_POOL(ifs)));
+
+				VEC_free(intfns_flow, gc, INTFNS_INFO_INTOP_SINK_POOL(ifs));
+				VEC_free(intfns_flow, gc, INTFNS_INFO_INTOP_FUNC_POOL(ifs));
+				VEC_free(intfns_flow, gc, INTFNS_INFO_INTOP_RET_POOL(ifs));
+				VEC_free(intfns_flow, gc, INTFNS_INFO_PARAM_SINK_POOL(ifs));
+
+				if(INTFNS_INFO_STA(ifs))
+				{
+					// dump the sta info
+					dump_intfns_sta(INTFNS_INFO_STA(ifs));
+					ggc_free (INTFNS_INFO_STA(ifs));
+				}
+				
+				ggc_free(ifs);
+			}
+		}
+	}
+
+	/* destroy the sink-lib-specs hash table */
+	destroy_sink_lib_specs();
+
+	/* destroy the extern-func-specs hash table. */
+	destroy_extern_func_specs();
+	
+	return 1;
+}
+
+
+/* gate for our pass, invoked by -fintfns */
+static bool
+gate_intfns_finish (void)
+{
+	return flag_intfns;
+}
+
+/* pass_intfns_begin definition */
+struct ipa_opt_pass_d pass_intfns_finish =
+{
+ {
+  IPA_PASS,
+  "intfns_finish",		                /* name */
+  gate_intfns_finish,					/* gate */
+  execute_intfns_finish,			    /* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_INTFNS_FINISH,		/* tv_id */
+  0,	                /* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0                     /* todo_flags_finish */
+ },
+ NULL,		        /* generate_summary */
+ NULL,				/* write_summary */
+ NULL,				/* read_summary */
+ NULL,				/* function_read_summary */
+ 0,					/* TODOs */
+ NULL,			    /* function_transform */
+ NULL				/* variable_transform */
+};
+
+/*---------------------------------------------------------------------------------*/
+/*-----------------------------end of intfns-----------------------------------------*/
+/*---------------------------------------------------------------------------------*/
+
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns1.h /home/haosun/intchecker/gcc-4.5.0/gcc/intfns1.h
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns1.h	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns1.h	2014-09-26 10:32:33.000000000 -0400
@@ -0,0 +1,441 @@
+/*----------------------------------------------------------------------*/
+/*----------------------------------------------------------------------*/
+/* to include *.h files */
+#include "hashtab.h"
+#include "vec.h"
+#include "tree.h"
+
+/*----------------------------------------------------------------------*/
+/*-------------------1. instrument module helpers.------ --------------------*/
+/*----------------------------------------------------------------------*/
+
+/* Global function decls used as handlers.  */
+/* extern void intfns_io_printer_xx (char* loc, tree rhs1, tree rhs2, tree print_type);  */
+static tree intfns_io_printer_8_fndecl;
+static tree intfns_io_printer_16_fndecl;
+static tree intfns_io_printer_32_fndecl;
+static tree intfns_io_printer_64_fndecl;
+/* extern void intfns_io_counter (char* loc, tree print_type);  */
+static tree intfns_io_counter_fndecl;
+/* extern void intfns_io_nop (void);  */
+static tree intfns_io_nop_fndecl;
+/* extern void intfns_insert_init(void);  */
+static tree intfns_insert_init_fndecl;
+/* extern void intfns_insert_finish(void);  */
+static tree intfns_insert_finish_fndecl;
+
+/* Global values used in instrument-intop*/
+static tree intfns_smax_8, intfns_smin_8, intfns_umax_8;
+static tree intfns_smax_16, intfns_smin_16, intfns_umax_16;
+static tree intfns_smax_32, intfns_smin_32, intfns_umax_32;
+static tree intfns_smax_64, intfns_smin_64, intfns_umax_64;
+
+/* for intfns-io2bo */
+static tree intfns_io2bo_dirty_s32, intfns_io2bo_dirty_u32;
+static tree DIRTY_mask, DIRTY_data;
+static tree intfns_io2bo_guard_fndecl;
+
+
+/*----------------------------------------------------------------------*/
+/* Macro */
+enum INTOP_TYPE {FNS_UADD = 1, FNS_SADD, FNS_USUB, FNS_SSUB, FNS_UMUL, FNS_SMUL, FNS_USHL, FNS_SSHL};
+
+/*----------------------------------------------------------------------*/
+/* Basic Helper Functions to define our handlers.  */
+/* Build a reference to a literal string.  */
+static tree intfns_build_string (const char *string);
+
+/* And another friend, for producing a simpler message.  */
+static tree intfns_file_function_line_tree (location_t location);
+
+/* Helper for intsorter_init: construct a decl with the given category,
+   name, and type, mark it an external reference, and pushdecl it.  */
+static inline tree intfns_make_builtin (enum tree_code category, const char *name, tree type);
+
+/* a function to insert 2 handler call */
+void intfns_insert_main (void);
+
+/* a function to initialize the global tree nodes that may be used when instrumentation.  */
+void intfns_init (void);
+
+/*----------------------------------------------------------------------*/
+/* intfns: instrument intop, insertpre-condition test for intop */
+static unsigned int intfns_pre_instrument_intop_add_sub(FILE * file, gimple_stmt_iterator *instr_gsi,
+                              location_t location, tree lhs, tree rhs1, tree rhs2, 
+                              enum INTOP_TYPE type, int width);
+static unsigned int intfns_pre_instrument_intop_mul_shl(FILE * file, gimple_stmt_iterator *instr_gsi,
+                              location_t location, tree lhs, tree rhs1, tree rhs2, 
+                              enum INTOP_TYPE type, int width);
+void intfns_insert_pre_test (void);
+/* insert post-condition test for intop */
+static unsigned int intfns_post_instrument_intop_non_mul(FILE * file, gimple_stmt_iterator *instr_gsi,
+                              location_t location, tree lhs, tree rhs1, tree rhs2, 
+                              enum INTOP_TYPE type, int width);
+static unsigned int intfns_post_instrument_intop_mul(FILE * file, gimple_stmt_iterator *instr_gsi,
+                              location_t location, tree lhs, tree rhs1, tree rhs2, 
+                              enum INTOP_TYPE type, int width);
+void intfns_insert_post_test (void);
+
+
+/*----------------------------------------------------------------------*/
+/*---------------------------------2. stmt-------------------------------*/
+/*----------------------------------------------------------------------*/
+/* using 15 bits (gimple.h:310) to indicate the type and status of stmt.*/
+/* there are a number of GIMPLE stmt type, as shown in gimple.h:734.
+in intfns, we only consider GIMPLE_ASSIGN, GIMPLE_COND, GIMPLE_CALL, GIMPLE_RET, and
+GIMPLE_PHI.
+the first 4 gimple-stmts are structed as gss-with-ops or gss-with-mem-ops, 
+and they share the field 'gsbase'. 
+therefore, we insert intfns-type-flag:5bits into 'gsbase', and use INTFNS-STMT-TYPE
+to identify these 4 gimple-stmts.
+and the last (propagate-op) are structed as gss-stmt-base, 
+and can be identified by their gimple-code.*/
+#define INTFNS_STMT_TYPE(NODE) NODE->gsbase.intfns_type_flag
+
+#define INTFNS_INTOP_STEPS(NODE) NODE->gsbase.intfns_steps_flag
+#define INTFNS_INTOP_SINK(NODE) NODE->gsbase.intfns_sink_flag
+#define INTFNS_INTOP_FUNC_RET(NODE) NODE->gsbase.intfns_func_ret_flag
+#define INTFNS_INTOP_STATUS(NODE) NODE->gsbase.intfns_status_flag
+#define INTFNS_PROPAGATE_STATUS(NODE)	NODE->gsbase.intfns_status_flag
+
+/* used for intfns-santz, 4 bits
+0: initialized value		1: unused op		2: uncritical lib
+3: const-narrow op	4: reverse op		5: hybrid
+6: not sanited
+*/
+#define INTFNS_INTOP_SANTZD_TYPE(NODE) NODE->gsbase.intfns_steps_flag
+#define INTFNS_INTOP_SANTZD_INIT 0
+#define INTFNS_INTOP_SANTZD_UNUSED 1
+#define INTFNS_INTOP_SANTZD_UNCRITICAL 2
+#define INTFNS_INTOP_SANTZD_CONST_NARROW 3
+#define INTFNS_INTOP_SANTZD_REVERSE 4
+#define INTFNS_INTOP_SANTZD_HYBRID 5
+#define INTFNS_INTOP_SANTZD_FAIL 6
+
+/* used for intfns-io2bo, 4 bits, to indicate whether an int-op is marked */
+#define INTFNS_INTOP_IO2BO_SANTZ_POSTCOND(NODE) NODE->gsbase.intfns_steps_flag
+
+/* for stmt type: 6 bits*/
+#define INTFNS_STMT_UNDO	0
+/* 1 to 8: INTOP_TYPE */
+#define INTFNS_STMT_PTR_PLUS	9
+#define INTFNS_STMT_SINK_LIB	10
+#define INTFNS_STMT_UNCRITICAL_LIB	11
+#define INTFNS_STMT_NORMAL_FUNC	12
+#define INTFNS_STMT_IF	13
+#define INTFNS_STMT_WHILE	14
+#define INTFNS_STMT_NARROW	15
+#define INTFNS_STMT_DENIED	16
+#define INTFNS_STMT_RET	17
+#define INTFNS_STMT_PROPAGATE 18
+#define INTFNS_STMT_ARRAY_REF 19
+#define INTFNS_STMT_RELATION	20
+#define INTFNS_STMT_EXTERNAL_SINK 21
+#define INTFNS_STMT_EXTERNAL_FUNC 22
+#define INTFNS_STMT_EXTERNAL_UNCRITICAL 23
+#define INTFNS_STMT_SHL_CONST 24
+#define INTFNS_STMT_UMUL_OFFSET 25
+#define INTFNS_STMT_SMUL_OFFSET 26
+#define INTFNS_STMT_VAR_PROPAGATE 27
+#define INTFNS_STMT_SANTZ_AND_CONST 28
+#define INTFNS_STMT_SANTZ_MOD_CONST 29
+#define INTFNS_STMT_SANTZ_AND_ARRAY 30
+#define INTFNS_STMT_SANTZ_MOD_ARRAY 31
+#define INTFNS_STMT_SANTZ_AND_IF 32
+#define INTFNS_STMT_SANTZ_OR_IF 33
+#define INTFNS_STMT_SANTZ_AND_MASK 34
+#define INTFNS_STMT_SANTZ_MOD_SIZEOF 35
+#define INTFNS_STMT_SANTZ_AND_VAR_CONST 36
+#define INTFNS_STMT_SANTZ_MOD_VAR_CONST 37
+#define INTFNS_STMT_ADDRESS_GLOBAL 38
+#define INTFNS_STMT_ADDRESS_ARRAY_REF 39
+#define INTFNS_STMT_ADDRESS_STRUCT_REF 40
+
+/* for steps: 2 bits, 0,1,2,3. the min steps. */
+#define INTFNS_STEPS_MAX 3
+
+/* for sink-flag: 1bit, 0: clean, 1: sink */
+#define INTFNS_INTOP_TO_CLEAN 0
+#define INTFNS_INTOP_TO_SINK 1
+
+/* for fun-ret-flag: 2bits, 0: clean, 1: in func, 2: in ret, 3: in func and ret*/
+#define INTFNS_INTOP_TO_FUNC 1
+#define INTFNS_INTOP_TO_RET 2
+#define INTFNS_INTOP_TO_FUNC_AND_RET 3
+
+/* for status of intop: 2bits, 0: un-analyzed, 1: being-analyzed, 2: been-analyzed 
+such status flag is used when analyzing intop recursively to break loops. */
+#define INTFNS_INTOP_UN_ANALYZED 0
+#define INTFNS_INTOP_BEING_ANALYZED 1
+#define INTFNS_INTOP_BEEN_ANALYZED 2
+
+/* for status of propagate: 2 bits, 0: not being analyzed, 1: being analyzed*/
+#define INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST 0
+#define INTFNS_PROPAGATE_IN_ANALYZED_LIST 1
+
+/*----------------------------------------------------------------------*/
+/*---------------------------------3. ovf-flow ---------------------------*/
+/*----------------------------------------------------------------------*/
+/*data structure to represent the flowing mode.
+in totally, there are 4 types of flows in current version of intfns.
+0: io-sink
+1: io-func
+2: io-ret
+3: param-sink*/
+struct intfns_flow_def
+{
+	gimple src;					
+	gimple dest;					
+	unsigned int steps : 2;		// 0, 1, 2, 3
+	unsigned int type : 2;		// 0: io-sink, 1:io-func, 2:io-ret, 3:param-sink
+	unsigned int src_type : 4;	// 1-8:INTOP_TYPE if type = 0 and 2, and as the i-th param if type = 1 and 3
+	unsigned int dest_type : 3;	// sink-type: 1-5 if/while/mem/array/ptr iftype = 0 or 3
+};
+typedef struct intfns_flow_def * intfns_flow;
+
+/* get each element of intfns-flow*/
+#define INTFNS_FLOW_SRC(FLOW)	FLOW->src
+#define INTFNS_FLOW_DEST(FLOW)	FLOW->dest
+#define INTFNS_FLOW_STEPS(FLOW) FLOW->steps
+#define INTFNS_FLOW_TYPE(FLOW)	FLOW->type
+#define INTFNS_FLOW_SRC_TYPE(FLOW)	FLOW->src_type
+#define INTFNS_FLOW_INTOP_TYPE(FLOW)	FLOW->src_type
+#define INTFNS_PARAM_NUM_MAX 16
+#define INTFNS_FLOW_PARAM_INDEX(FLOW)	FLOW->src_type
+#define INTFNS_FLOW_DEST_TYPE(FLOW)	FLOW->dest_type
+
+/* define the type of intfns-flow*/
+#define INTFNS_FLOW_INTOP_TO_SINK 0
+#define INTFNS_FLOW_INTOP_TO_FUNC 1
+#define INTFNS_FLOW_INTOP_TO_RET 2
+#define INTFNS_FLOW_PARAM_TO_SINK 3
+
+/* define the type of sink */
+#define INTFNS_SINK_IF 1
+#define INTFNS_SINK_WHILE 2
+#define INTFNS_SINK_LIB 3
+#define INTFNS_SINK_ARRAY 4
+#define INTFNS_SINK_PTR 5
+#define INTFNS_SINK_EXTERN_FUNC 6
+#define INTFNS_SINK_ADDRESS_GLOBAL 7
+
+/* check the type of intfns-flow*/
+#define IS_INTOP_SINK_FLOW(FLOW)		INTFNS_FLOW_TYPE(FLOW)== INTFNS_FLOW_INTOP_TO_SINK
+#define IS_INTOP_FUNC_FLOW(FLOW)		INTFNS_FLOW_TYPE(FLOW) == INTFNS_FLOW_INTOP_TO_FUNC
+#define IS_INTOP_RET_FLOW(FLOW)		INTFNS_FLOW_TYPE(FLOW) == INTFNS_FLOW_INTOP_TO_RET
+#define IS_PARAM_SINK_FLOW(FLOW)	INTFNS_FLOW_TYPE(FLOW) == INTFNS_FLOW_PARAM_TO_SINK
+
+/* init the intfns-flow */
+#define SET_INTFNS_FLOW(FLOW, SRC, DEST, STEPS, TYPE, SRC_TYPE, DEST_TYPE)\
+	INTFNS_FLOW_SRC(FLOW) = SRC;\
+	INTFNS_FLOW_DEST(FLOW) = DEST;\
+	INTFNS_FLOW_STEPS(FLOW) = STEPS;\
+	INTFNS_FLOW_TYPE(FLOW) = TYPE;\
+	INTFNS_FLOW_SRC_TYPE(FLOW) = SRC_TYPE;\
+	INTFNS_FLOW_DEST_TYPE(FLOW) = DEST_TYPE
+
+/* define an vector type for struct intfns_flow_def */
+DEF_VEC_P (intfns_flow);
+DEF_VEC_ALLOC_P(intfns_flow, gc);
+
+/* free each of the flow in the pool*/
+void intfns_flow_pool_destroy(VEC(intfns_flow, gc) ** pool);
+
+
+/*----------------------------------------------------------------------*/
+/*--------------------4. sink: libc call specs -------------------------------*/
+/*----------------------------------------------------------------------*/
+/* this structure is used to store the details of sink-lib.
+for example, for malloc(), it is a sink lib-call.
+the name is 'malloc' and the arg is '0'.*/
+
+#define MAX_NAME_LENGTH 32
+struct intfns_func_specs_node
+{
+	char name[MAX_NAME_LENGTH];
+	int arg;
+};
+
+/* global var to store the definition of sink-lib-spec*/
+static htab_t sink_lib_specs_htab;
+struct intfns_func_specs_node sink_lib_specs[] = 
+{
+	#include "intfns-sink-lib-specs.def"
+};
+
+/* global var to store the definition of external-func-spec */
+static htab_t extern_func_specs_htab;
+struct intfns_func_specs_node extern_func_specs[] = 
+{
+	#include "intfns-extern-func-specs.def"
+};
+
+void init_sink_lib_specs(void);
+void init_extern_func_specs(void);
+hashval_t func_specs_hash_fun(const PTR s);
+int func_specs_hash_eq(const void *s1, const void * s2);
+void destroy_sink_lib_specs(void);
+void destroy_extern_func_specs(void);
+
+/* get the sink-lib-arg for STR, -1 means that it is not sink-lib-call*/
+int find_sink_lib_arg(char * str);
+
+/* get the sink-type for STR, 1 means that it would use its args in a sink-call. 
+0 means it would not use its args sensitively, therefore, we could treat such external
+functions as uncritical one. */
+int find_extern_func_sink(char * str);
+
+/*----------------------------------------------------------------------*/
+/*--------------------5. info for static analysis  ----------------------------*/
+/*----------------------------------------------------------------------*/
+struct intfns_static_facts
+{
+	char func_name[128];
+
+	/* intra */
+	unsigned int stmt_total;
+	unsigned int intop_total;
+	unsigned int intop_mul_offset;
+	unsigned int intop_shl_const;
+	unsigned int intop_sink_intra;
+	unsigned int intop_func_intra;
+	unsigned int intop_ret_intra;
+
+	/* sanitization ops */
+	unsigned int intop_narrow;
+	unsigned int intop_santz_and_const;
+	unsigned int intop_santz_mod_const;
+	unsigned int intop_santz_and_array;
+	unsigned int intop_santz_mod_array;
+	unsigned int intop_santz_and_if;
+	unsigned int intop_santz_or_if;
+	unsigned int intop_santz_and_mask;
+	unsigned int intop_santz_mod_sizeof;
+	unsigned int intop_santz_and_var_const;
+	unsigned int intop_santz_mod_var_const;
+	unsigned int intop_santz_const_narrow;
+	unsigned int intop_santz_unused;
+	unsigned int intop_santz_uncritical;
+	unsigned int intop_santz_reverse;
+
+	/* intop sanitized by our defined sanitization ops. */
+	unsigned int intop_santzd_unused;
+	unsigned int intop_santzd_uncritical;
+	unsigned int intop_santzd_const_narrow;
+	unsigned int intop_santzd_reverse;
+	unsigned int intop_santzd_hybrid;
+	
+	/* inter */
+	unsigned int intop_sink_inter;
+	unsigned int intop_func_inter;
+	unsigned int intop_ret_inter;
+	unsigned int param_sink_inter;	
+
+	/* inter- flow-sinks stats*/
+	unsigned int intop_if_sink_inter;
+	unsigned int intop_while_sink_inter;
+	unsigned int intop_lib_sink_inter;
+	unsigned int intop_array_sink_inter;
+	unsigned int intop_ptr_sink_inter;
+	unsigned int intop_extern_sink_inter;	
+	unsigned int intop_address_global_sink_inter;
+};
+
+struct intfns_facts
+{
+	VEC(intfns_flow, gc) * intop_sink_flow_pool;
+	VEC(intfns_flow, gc) * intop_func_flow_pool;
+	VEC(intfns_flow, gc) * intop_ret_flow_pool;
+	VEC(intfns_flow, gc) * param_sink_flow_pool;
+	struct intfns_static_facts * static_facts;
+};
+
+/* using a new field 'intfns-info' (function.h:530) to 
+store all the info produced during our static analysis. */
+#define INTFNS_INFO(FUN)	FUN->intfns_info
+
+#define INTFNS_INFO_INTOP_SINK_POOL(IFS)	IFS->intop_sink_flow_pool
+#define INTFNS_INFO_INTOP_FUNC_POOL(IFS)	IFS->intop_func_flow_pool
+#define INTFNS_INFO_INTOP_RET_POOL(IFS)		IFS->intop_ret_flow_pool
+#define INTFNS_INFO_PARAM_SINK_POOL(IFS)	IFS->param_sink_flow_pool
+#define INTFNS_INFO_STA(IFS) IFS->static_facts
+
+#define INTFNS_INFO_INTOP_SINK_POOL_FUN(FUN)	((struct intfns_facts*)FUN->intfns_info)->intop_sink_flow_pool
+#define INTFNS_INFO_INTOP_FUNC_POOL_FUN(FUN)	((struct intfns_facts*)FUN->intfns_info)->intop_func_flow_pool
+#define INTFNS_INFO_INTOP_RET_POOL_FUN(FUN)		((struct intfns_facts*)FUN->intfns_info)->intop_ret_flow_pool
+#define INTFNS_INFO_PARAM_SINK_POOL_FUN(FUN)	((struct intfns_facts*)FUN->intfns_info)->param_sink_flow_pool
+#define INTFNS_INFO_STA_FUN(FUN)	((struct intfns_facts*)FUN->intfns_info)->static_facts
+
+/*----------------------------------------------------------------------*/
+/*--------------------6. functions used in intra-p intfns----------------------*/
+/*----------------------------------------------------------------------*/
+gimple gimple_next(gimple stmt);
+void intfns_mark_stmt(gimple stmt);
+void intfns_backward_mark_cond_offset(gimple stmt);
+void intfns_mark_sanitizations(gimple stmt);
+void intfns_mark_universal_santz(gimple stmt);
+void intfns_mark_io2bo_identify_santz_postcond(gimple stmt);
+void intfns_sanitization_count(struct intfns_static_facts * sta);
+void dump_marked_stmt(void);
+bool gimple_is_if_while_relation(gimple stmt);
+void intfns_select_intop(FILE * file, gimple propatate, gimple src, VEC(intfns_flow, gc)** intop_sink_pool,
+	VEC(intfns_flow, gc)** intop_func_pool, VEC(intfns_flow, gc)** intop_ret_pool);
+bool intfns_build_flow(VEC(intfns_flow, gc) ** pool, gimple src, gimple dest, unsigned int steps,
+	unsigned int type, unsigned int src_type, unsigned int dest_type);
+void intfns_create_imm_sink_flow(VEC(intfns_flow, gc) ** intop_sink_pool, VEC(intfns_flow, gc)** intop_func_pool, 
+	VEC(intfns_flow, gc)** intop_ret_pool, gimple src, gimple dest, unsigned int dest_type);
+void intfns_create_imm_ret_flow(VEC(intfns_flow, gc) ** intop_ret_pool, gimple src, gimple dest);
+void intfns_create_imm_func_flow(VEC(intfns_flow, gc) ** intop_func_pool, gimple src, gimple dest, unsigned int param_ix);
+void intfns_transit_flow(VEC(intfns_flow, gc) ** intop_sink_pool, VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool, gimple src, gimple use_stmt);
+void intfns_cleanup_func_ret_pool(VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool, gimple src);
+
+#define INTFNS_INTRA 1
+#define INTFNS_INTER 2
+void dump_selected_intop(VEC(intfns_flow, gc) ** intop_sink_pool, VEC(intfns_flow, gc) ** intop_func_pool,
+	VEC(intfns_flow, gc) ** intop_ret_pool, VEC(intfns_flow, gc) ** param_sink_pool,unsigned int type);
+void dump_intfns_flow(FILE * file, intfns_flow flow);
+void intfns_intra_count(struct intfns_static_facts * sta);
+
+
+/*----------------------------------------------------------------------*/
+/*----------------------------7. inter-p analysis.--------------------------*/
+/*----------------------------------------------------------------------*/
+/* used for intfns-param recursive call*/
+#define TREE_INTFNS_BEING_ANALYZED(NODE) ((NODE)->base.intfns_flag)
+
+/* this structure is used to store many useful and important infor for the param-ix.
+we choose an param-array to improve the speed of indexing the particular param of cfun. */
+struct intfns_param_facts
+{
+	tree param_ssa;
+	intfns_flow param_flow;
+	unsigned int has_param_ssa: 1;
+	unsigned int has_param_flow: 1;
+	unsigned int status: 1;
+};
+/* create an imm param->sink flow */
+void intfns_create_imm_param_flow(VEC(intfns_flow, gc)** param_sink_pool, int index, 
+	struct intfns_param_facts* param_facts, gimple dest, unsigned int dest_type);
+/* fill the param->sink pool for cfun. */
+void intfns_inter_select_param(FILE * file, tree lhs, int index, struct intfns_param_facts * param_facts, 
+		VEC(intfns_flow, gc)** intop_sink_pool, VEC(intfns_flow, gc)** param_sink_pool);
+/* param->intop +++ intop->sink   --->>> param->sink*/
+void intfns_transit_param_flow(VEC(intfns_flow, gc)** intop_sink_pool, VEC(intfns_flow, gc)** param_sink_pool, 
+		int index, struct intfns_param_facts* param_facts, gimple use_stmt);
+/* eliminate those src->func flows if there is src->sink flow */
+void intfns_inter_cleanup_func_pool(VEC(intfns_flow, gc) ** intop_func_pool);
+/* a recursive process to transit intop->ret +++ ssa-name->sink --->>> intop->sink */
+void intfns_inter_select_ret(FILE* file, tree lhs, VEC(intfns_flow, gc)** func_intop_ret_pool,
+		VEC(intfns_flow, gc)** func_intop_sink_pool, VEC(intfns_flow, gc)** intop_sink_pool);
+/* update all the flows in ret-pool into sink-flows with <dest, dest-type>,
+and move them into sink-pool. */
+void intfns_inter_sink_ret_pool(FILE* file, VEC(intfns_flow, gc)** func_intop_ret_pool, 
+	VEC(intfns_flow, gc)** func_intop_sink_pool,gimple dest, unsigned int dest_type);
+
+void stats_intfns_flow_sinks(struct intfns_static_facts * sta, VEC(intfns_flow, gc)** flow_pool);
+
+/*----------------------------------------------------------------------*/
+/*----------------------------8. the end.---------------------------------*/
+/*----------------------------------------------------------------------*/
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns.c /home/haosun/intchecker/gcc-4.5.0/gcc/intfns.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns.c	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns.c	2015-08-23 14:17:02.237991153 -0400
@@ -0,0 +1,5940 @@
+/* Detailed Implementation of IntCHECKER.  
+todo: more infor about this project. */
+
+/* header */
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "rtl.h"
+#include "tm_p.h"
+#include "hard-reg-set.h"
+#include "basic-block.h"
+#include "output.h"
+#include "flags.h"
+#include "function.h"
+#include "expr.h"
+#include "ggc.h"
+#include "langhooks.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "timevar.h"
+#include "tree-dump.h"
+#include "tree-pass.h"
+#include "toplev.h"
+#include "except.h"
+#include "cfgloop.h"
+#include "cfglayout.h"
+#include "tree-ssa-propagate.h"
+#include "value-prof.h"
+#include "pointer-set.h"
+#include "tree-inline.h"
+#include "gimple.h"
+
+#include "intfns.h"
+
+
+/*---------------------------------------------------------------------------------*/
+/*---------------------  intfns-mark, mark the types of all gimple stmts--------------------*/
+/*---------------------------------------------------------------------------------*/
+/* todo: detailed infor about intfns-mark progress.
+*/
+
+/* dump each STMT for current FUN into the FILE */
+void intfns_dump_each_stmt_for_func(struct function * fun, FILE* file)
+{
+	fprintf(file, "\n");
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt,phi;
+	
+	FOR_EACH_BB_FN(bb, fun)
+	{
+	
+	for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+		phi = gsi_stmt(gsi);
+		if(phi != NULL)
+		{
+			print_gimple_stmt (file, phi, 0, TDF_LINENO);
+			fprintf(file, "gimple-code: %s\n\n", gimple_code_name[gimple_code(phi)]);
+		}
+	}
+	
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{    	
+		stmt = gsi_stmt(gsi);
+  		if(stmt != NULL)
+		{
+			print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+			fprintf(file, "gimple-code: %s", gimple_code_name[gimple_code(stmt)]);
+
+			if(gimple_code(stmt) == GIMPLE_ASSIGN)
+				fprintf(file, "\tlhs: %s, rhs: %s",
+					tree_code_name[TREE_CODE(gimple_assign_lhs(stmt))],
+					tree_code_name[gimple_assign_rhs_code(stmt)]);
+			/*if((gimple_code(stmt) == GIMPLE_ASSIGN)
+				&&(TREE_CODE(gimple_assign_lhs(stmt)) != SSA_NAME))
+			{	
+				fprintf(file, "\n\tvdef:");
+				imm_use_iterator iter;
+				gimple use_stmt;
+				tree vdef = gimple_vdef (stmt);
+
+				if (!vdef|| TREE_CODE (vdef) != SSA_NAME)
+				    fprintf(file, "\t no sense.\n");
+				else
+				{
+					fprintf(file, "\t to list all the use\n");
+					FOR_EACH_IMM_USE_STMT (use_stmt, iter, gimple_vdef (stmt))
+					if(use_stmt != NULL)
+					{	
+						fprintf(file, "\tvuse:");
+						print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+					}
+				}
+			}*/
+			/*if((gimple_code(stmt) == GIMPLE_ASSIGN)
+				&& (gimple_assign_rhs_code(stmt) == TRUNC_MOD_EXPR))
+			{
+				fprintf(file, "\trhs1: %s, rhs2: %s",
+					tree_code_name[TREE_CODE(gimple_assign_rhs1(stmt))],
+					tree_code_name[TREE_CODE(gimple_assign_rhs2(stmt))]);
+				if(TREE_CONSTANT(gimple_assign_rhs2(stmt)))
+					fprintf(file, " const\t");
+				else
+					fprintf(file, " not const\t");
+			}*/
+			fprintf(file, "\n\n");
+		}
+	}
+	}
+}
+
+/* return the next stmt after stmt. */
+gimple gimple_next(gimple stmt)
+{
+	// find the gsi for current stmt
+	gimple_stmt_iterator gsi = gsi_for_stmt(stmt);
+	gimple stmt_next;
+
+	gsi_next(&gsi);
+	if(!gsi_end_p(gsi))
+		return (gsi_stmt(gsi));
+	
+	return NULL;
+}
+
+/* mark whether STMT is the location of integer overflow.
+is_unsign (bool): true -> unsign, flase -> sign
+rhs_code: the op-code of STMT*/
+void inteq_mark_io_intop(gimple stmt, bool is_unsign, enum tree_code rhs_code,
+	struct intfns_statistics ** stat_ptr)
+{
+	if(stmt == NULL)
+		return;
+	
+	if(io_num == 0)
+		return;		// if io_num is none, we don't have to execute this function.
+
+	int sign;		// indicate the SIGN type
+	if(is_unsign)
+		sign = 1;
+	else
+		sign = 2;
+
+	int op;			// to indicate the OP
+	if(rhs_code == PLUS_EXPR)
+		op = 1;
+	else if(rhs_code == MINUS_EXPR)
+		op = 2;
+	else if(rhs_code == MULT_EXPR)
+		op = 3;
+	else if(rhs_code == LSHIFT_EXPR)
+		op = 4;
+	else
+		return;
+	
+	int lineno = gimple_lineno(stmt);	// line number
+
+	int colno;	// column number
+	if(gimple_has_location (stmt))
+    {
+      expanded_location xloc = expand_location (gimple_location (stmt));      
+      colno = xloc.column;
+	}
+	//else
+	//	return;	
+
+	// traversal each element in IO_INFO to tell whether STMT is in.
+	unsigned ix;
+	for(ix = 0; ix < io_num; ix ++)
+	{
+		if((strcmp(io_info[ix].filename, gimple_filename(stmt)) == 0)
+			&& (io_info[ix].lineno == lineno)
+			//&& (io_info[ix].colno == colno)
+			&& (io_info[ix].sign == sign)
+			&& (io_info[ix].op == op)
+			)
+		{
+			// this STMT is an overflowed integer arithmetic operation
+			// hence, we want to mark this FUNC and this INTOP
+			INTFNS_INTOP_OVF(stmt) = 1;
+			(*stat_ptr)->intop_ovf ++;
+			(*stat_ptr)->fun_ovf_flag = 1;
+			break;
+		}
+	}
+}
+
+
+/* basic mark for each STMT */
+void intfns_mark_stmt(gimple stmt, int * has_global_var, 
+	struct intfns_statistics ** stat_ptr)
+{	
+	tree lhs, rhs1, rhs2;
+	basic_block bb, then_bb, else_bb;
+	edge e;
+	enum gimple_rhs_class grhs_class;	/* class of rhs-expr */
+	enum tree_code rhs_code;			/* code for rhs-expr */
+	bool is_unsign = false;				/* to indicate the signedness of operations */
+	
+	/* to check the type of stmt, refer to dump_gimple_stmt() in gimple.c for more details */
+	switch (gimple_code (stmt))
+	{
+	case GIMPLE_ASSIGN:
+		grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));
+		rhs_code = gimple_assign_rhs_code(stmt);
+		lhs = gimple_assign_lhs (stmt);
+
+		// FIXME: this check is inaccurate
+		// check whether LHS is a global var
+		if((TREE_CODE(lhs) != SSA_NAME)
+			&&((DECL_EXTERNAL(lhs)) || (POINTER_TYPE_P(TREE_TYPE(lhs)))))
+			//&&((is_global_var(lhs)) || (POINTER_TYPE_P(TREE_TYPE(lhs)))))
+			*has_global_var = 1;
+		
+		if(TREE_CODE(lhs) == SSA_NAME)
+			INTFNS_STMT_LEFT_IS_SSA(stmt) = 1;
+		
+		/* binary operation, c = a op b; */
+		if (grhs_class == GIMPLE_BINARY_RHS)
+		{
+			// pointer-offset stmt
+			if(rhs_code == POINTER_PLUS_EXPR)
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PTR_PLUS;
+				break;
+			}
+
+			// if the LHS of the BIN op is not of integer type
+			if(TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_LEFT_NOT_INT;
+				break;
+			}
+			
+			// intop: +, -, *, <<
+			if((rhs_code == PLUS_EXPR) || (rhs_code == MINUS_EXPR)
+ 				|| (rhs_code == MULT_EXPR) || (rhs_code == LSHIFT_EXPR))
+			{	/* potential intop: c = a op b*/
+				rhs1 = gimple_assign_rhs1(stmt);
+				rhs2 = gimple_assign_rhs2(stmt);
+
+				/* a, b and c are all of integer-type */
+				if ((TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+					||(TREE_CODE (TREE_TYPE(rhs1)) != INTEGER_TYPE)
+					||(TREE_CODE (TREE_TYPE(rhs2)) != INTEGER_TYPE))
+					break;	// maybe we should mark this stmt as propagate-type
+
+				/* a and b are both XX_CST, just pass. caz such cases can not be exploited by attackers.  */
+				if(((TREE_CODE(rhs1) == INTEGER_CST)||(TREE_CODE(rhs1) == REAL_CST))
+					&& ((TREE_CODE(rhs2) == INTEGER_CST)||(TREE_CODE(rhs2) == REAL_CST)))
+					break;
+
+				/* get the sign-info for a, b and c. */
+				is_unsign = TYPE_UNSIGNED(TREE_TYPE(rhs1))
+					&& TYPE_UNSIGNED(TREE_TYPE(rhs2));
+				
+				inteq_mark_io_intop(stmt, is_unsign, rhs_code, stat_ptr);
+
+				if(rhs_code == PLUS_EXPR)
+					INTFNS_STMT_TYPE(stmt) = is_unsign ? INTFNS_STMT_UADD: INTFNS_STMT_SADD;
+				else if(rhs_code == MINUS_EXPR)
+					INTFNS_STMT_TYPE(stmt) = is_unsign ? INTFNS_STMT_USUB: INTFNS_STMT_SSUB;
+				else if(rhs_code == MULT_EXPR)
+					INTFNS_STMT_TYPE(stmt) = is_unsign ? INTFNS_STMT_UMUL: INTFNS_STMT_SMUL;
+				else
+					INTFNS_STMT_TYPE(stmt) = TYPE_UNSIGNED(TREE_TYPE(rhs1))? INTFNS_STMT_USHL: INTFNS_STMT_SSHL;
+			}
+
+			// SHR: >>
+			else if (rhs_code == RSHIFT_EXPR)
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SHR;
+				// annotate the following three stmts in IntEquiv
+				// if: >>cst, we treat this >> as BIT
+				//rhs2 = gimple_assign_rhs2(stmt);
+				//if(TREE_CODE(rhs2) == INTEGER_CST)
+				//	INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_BIT;
+			}
+			
+			// BIT-op: |, &, xor
+			else if((rhs_code == BIT_IOR_EXPR) || (rhs_code == BIT_AND_EXPR)
+				|| (rhs_code == BIT_XOR_EXPR) || (rhs_code == LROTATE_EXPR)
+				|| (rhs_code == RROTATE_EXPR))
+			{	
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_BIT;
+
+				// IntEquiv
+				// if: &cst, and cst is contiguous 'one' bits.
+				//rhs2 = gimple_assign_rhs2(stmt);
+				//if((rhs_code == BIT_AND_EXPR) 
+				//	&& (TREE_CODE(rhs2) == INTEGER_CST))
+				//{
+				//	unsigned int val = TREE_INT_CST_LOW(rhs2);
+				//	if((val & (val + 1)) == 0)
+				//		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NARROW;
+				//}
+			}
+
+			// MOD-op: %
+			else if((rhs_code == TRUNC_MOD_EXPR) || (rhs_code == FLOOR_MOD_EXPR)
+				|| (rhs_code == CEIL_MOD_EXPR) || (rhs_code == ROUND_MOD_EXPR))
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_MOD;
+				// IntEquiv
+				// if: %cst
+				//rhs2 = gimple_assign_rhs2(stmt); 
+				//if(TREE_CODE(rhs2) == INTEGER_CST)
+				//	INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NARROW;
+			}
+			
+			// relation-op: <, >, ==, &&, ||
+			else if((rhs_code == LT_EXPR) || (rhs_code == GT_EXPR)
+				|| (rhs_code == LE_EXPR) || (rhs_code == GE_EXPR)
+				|| (rhs_code == TRUTH_AND_EXPR)|| (rhs_code == TRUTH_OR_EXPR)
+				|| (rhs_code == TRUTH_XOR_EXPR)
+				)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_RELATION;
+			else if((rhs_code == EQ_EXPR) || (rhs_code == NE_EXPR))
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_EQUAL_INEQUAL;
+				
+			// else, such as div(/), we treat them as propagate-op
+			else
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PROPAGATE;
+		}
+
+		/* UNARY op */
+		else if(grhs_class == GIMPLE_UNARY_RHS)
+		{
+			/* lhs must be of integer type. */
+			if(TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+			{
+			// FIXME: in IntEquiv, we treat such cast as CAST-TO-unINT
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_CAST_TO_unINT;
+				break;
+			}
+
+			/* relation-op: !a */
+			if(rhs_code == TRUTH_NOT_EXPR)
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_RELATION;
+
+			/* BIT-op: ~a */
+			else if(rhs_code == BIT_NOT_EXPR)
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_BIT;
+			}
+
+			/* we treat them as propagate-op */
+			else 
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PROPAGATE;
+			}
+		}
+
+		//GIMPLE_SINGLE_RHS or GIMPLE_INVALID_RHS
+		else
+		{
+			// temp = array[index];
+			if(rhs_code == ARRAY_REF)
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_ARRAY_REF;
+				break;
+			}
+
+			// if the LHS is not of integer type
+			if(TREE_CODE (TREE_TYPE(lhs)) != INTEGER_TYPE)
+			{
+			// FIXME: in IntEquiv, we treat such stmt as CAST-TO-unINT, one kind of sink
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_CAST_TO_unINT;
+				break;
+			}
+
+			rhs1 = gimple_assign_rhs1(stmt);
+			// D.temp = RHS.temp
+			if ((TREE_CODE(lhs) == SSA_NAME)
+				&& (TREE_CODE(rhs1) != INTEGER_CST))
+			{
+				INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_PROPAGATE;
+
+				// rhs1 must be of integer type as well
+				if(TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE)
+					break;				
+				break;
+			}
+			// VAR-DECL = SSA-NAME
+			else if((TREE_CODE(lhs) == VAR_DECL)
+				&& (TREE_CODE(rhs1) == SSA_NAME))
+			{
+				// we should propagate the following stmt
+				// var-decl = ssa-name;
+				// ssa-name = var-decl;
+				gimple next_stmt = gimple_next(stmt);
+				if((next_stmt != NULL)
+					&&(gimple_code(next_stmt) == GIMPLE_ASSIGN)
+					&&(get_gimple_rhs_class (gimple_assign_rhs_code (next_stmt))== GIMPLE_SINGLE_RHS))
+				{
+					tree next_lhs = gimple_assign_lhs(next_stmt);
+					tree next_rhs = gimple_assign_rhs1(next_stmt);
+					if((TREE_CODE(next_lhs) == SSA_NAME)
+						&& (TREE_CODE(next_rhs) == VAR_DECL)
+						&& (next_rhs == lhs))
+					{
+						INTFNS_STMT_TYPE(stmt)= INTFNS_STMT_VAR_PROPAGATE;
+						break;
+					}
+				}
+			}	
+		}
+		
+		break;
+	case GIMPLE_CALL:
+		if(gimple_call_fndecl(stmt) == NULL)
+			break;
+		
+		INTFNS_STMT_TYPE(stmt)= INTFNS_STMT_CALL;
+		
+		/*DECL_BUILT_IN(NODE): lib-call. */
+		if(DECL_BUILT_IN(gimple_call_fndecl(stmt)))
+		{
+			if((strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "printf") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "fprintf") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "sprintf") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "uname") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "gettimeofday") == 0))
+			{
+				INTFNS_STMT_STATUS(stmt) = INTFNS_CALL_UNCRITICAL_LIB;
+				break;
+			}
+			else if((strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "bcopy") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "malloc") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "calloc") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "memmove") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "memset") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "memcpy") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "movmem") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "realloc") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "strncat") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "strncpy") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "swab") == 0)
+				|| (strcmp(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "operator new []") == 0))
+			{
+				INTFNS_STMT_STATUS(stmt) = INTFNS_CALL_SINK_LIB;
+				break;
+			}
+			else
+				break;
+		}
+
+		/* user supplied function. */
+		if(DECL_EXTERNAL(gimple_call_fndecl(stmt)))	
+		{
+			if((strstr(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "alloc") != NULL)
+				|| (strstr(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "Alloc") != NULL))
+			{
+				INTFNS_STMT_STATUS(stmt) = INTFNS_CALL_EXTERNAL_SINK;
+				break;
+			}			
+			
+			if(strstr(IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl(stmt))), "print") != NULL)
+			{
+				INTFNS_STMT_STATUS(stmt) = INTFNS_CALL_EXTERNAL_UNCRITICAL;
+				break;
+			}
+		}
+		// normal func
+		else
+		{
+			INTFNS_STMT_STATUS(stmt) = INTFNS_CALL_NORMAL_FUNC;		
+			break;
+		}
+		
+	case GIMPLE_COND:
+
+		// IntEquiv
+		/* fixme: it is too simple to idefntify IF and WHILE. */
+		//if(EDGE_COUNT (bb->succs) == 2)
+		//{
+		//	e = EDGE_SUCC(bb,0);
+		//	then_bb = e->dest;
+		//	e = EDGE_SUCC(bb,1);
+		//	else_bb = e->dest;
+		//	if((then_bb == bb)||(else_bb == bb))
+		//		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_WHILE;
+		//	else
+		//		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_IF;
+		//}
+		//else
+			INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_IF;
+		
+		break;
+	case GIMPLE_RETURN:
+		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_RET;
+		break;
+	case GIMPLE_PHI:
+		// propagae-op in intfns
+		break;
+	default:
+		// non-sense?
+		break;
+	}
+}
+
+/* mark all the relation stmt for if/while, and mul stmt for ptr-offset through a backward analysis */
+void intfns_mark_stmt_backward_cond_and_offset(gimple stmt)
+{	
+	/* refer to tree-flow.h, gimple.h and tree-flow-inline.h for more details */	
+	tree lhs = gimple_assign_lhs (stmt);
+	gimple use;
+	use_operand_p use_p;
+
+	// a mul stmt would trun into mul-offset if its only use is for ptr-offset
+	// we could treat mul-offset as sinks while treating ptr-offset as unciritcal
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UMUL)
+		||(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SMUL))
+	{
+		if(single_imm_use(lhs, &use_p, &use))
+		{
+			if((gimple_code(use) == GIMPLE_ASSIGN)
+				&&(INTFNS_STMT_TYPE(use) == INTFNS_STMT_PTR_PLUS))
+			{
+				if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UMUL)
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_UMUL_OFFSET;
+				else
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_SMUL_OFFSET;
+			}
+		}
+	}
+	
+	/* stmt is relation-op. it would turn into if/while if any of its use is for if/while. */
+	else if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)
+	{
+		// c = a relation-op b;
+		if(single_imm_use(lhs, &use_p, &use))
+		{
+			if((gimple_code(use) == GIMPLE_ASSIGN)
+				||(gimple_code(use) == GIMPLE_COND))
+			{
+				if((INTFNS_STMT_TYPE(use) == INTFNS_STMT_IF)
+					||(INTFNS_STMT_TYPE(use) == INTFNS_STMT_WHILE))
+					INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_TYPE(use);
+			}
+		}
+	}
+	// fixme: we don't consider such cases, as the signcast used in array indexing
+	// doesn't produce sign error in most time
+	/* for sign cast, if it is used directly in mul-offset, we don't analyze it later */
+	/*else if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+		&& (INTFNS_SIGN_CAST_STATUS(stmt)))
+	{
+		if(single_imm_use(lhs, &use_p, &use))
+		{
+			if(gimple_code(use) == GIMPLE_ASSIGN)
+			{
+				if((INTFNS_STMT_TYPE(use) == INTFNS_STMT_SMUL_OFFSET)
+					|| (INTFNS_STMT_TYPE(use) == INTFNS_STMT_UMUL_OFFSET))
+					INTFNS_SIGN_CAST_STATUS(stmt) = INTFNS_STMT_SIGN_CAST_IN_ARRAY;
+			}
+		}
+	}*/
+	else
+		return;
+}
+
+/* dump the location and stmt-type of the stmts marked by intfns. */
+void intfns_dump_marked_stmt(struct function * fun)
+{
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt, phi;
+	FILE* file;
+
+	/* a file descriptor to dump debug info */
+	file =  fopen("/tmp/log_intfns_marked_stmt.txt", "a");
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(fun->decl, 2));
+
+	/* travesal each stmt in current func. */	
+	FOR_EACH_BB_FN(bb, fun)
+	{
+	/*for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+		phi = gsi_stmt(gsi);
+		if(phi != NULL)
+		{
+			fprintf(file, "\tphi-stmt:");
+			print_gimple_stmt (file, phi, 0, TDF_LINENO);
+			fprintf(file, "\n");
+		}
+	}*/
+	
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{    	
+		stmt = gsi_stmt(gsi);
+  		if(stmt == NULL)
+			continue;
+		
+		switch (gimple_code (stmt))	/* to check the type of stmt */
+		{
+		case GIMPLE_ASSIGN:
+		case GIMPLE_COND:
+		case GIMPLE_CALL:
+		case GIMPLE_RETURN:
+			switch(INTFNS_STMT_TYPE(stmt))
+			{
+			/*potential ovf site: +, -, * and <<*/
+			case INTFNS_STMT_UADD:
+				fprintf(file, "\tunsigned add at %s:%d, ovf%dovf\n", 
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_SADD:
+				fprintf(file, "\tsigned add at %s:%d, ovf%dovf\n", 
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_USUB:
+				fprintf(file, "\tunsigned sub at %s:%d, ovf%dovf\n",
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_SSUB:
+				fprintf(file, "\tsigned sub at %s:%d, ovf%dovf\n",
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_UMUL:
+				fprintf(file, "\tunsigned mul at %s:%d, ovf%dovf\n",
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_SMUL:
+				fprintf(file, "\tsigned mul at %s:%d, ovf%dovf\n",
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_USHL:
+				fprintf(file, "\tunsigned shl at %s:%d, ovf%dovf\n",
+					gimple_filename(stmt), gimple_lineno(stmt), INTFNS_INTOP_OVF(stmt));break;
+			case INTFNS_STMT_SSHL:
+				fprintf(file, "\tsigned shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			
+			/* MUL introduced by array[inx] */
+			case INTFNS_STMT_UMUL_OFFSET:
+				fprintf(file, "\tumult-offset at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SMUL_OFFSET:
+				fprintf(file, "\tsmult-offset at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			
+			case INTFNS_STMT_PTR_PLUS:
+				fprintf(file, "\tpointer plus at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_IF:
+				fprintf(file, "\tif-cond at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_WHILE:
+				fprintf(file, "\twhile-cond at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_RET:
+				fprintf(file, "\tret-stmt at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_PROPAGATE:
+				switch(INTFNS_SIGN_CAST_STATUS(stmt))
+				{
+				case INTFNS_STMT_SIGN_TO_UNSIGN:
+					fprintf(file, "\tsign-cast: sign->unsign at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_STMT_UNSIGN_TO_SIGN:
+					fprintf(file, "\tsign-cast: unsign->sign at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_STMT_SIGN_CAST_IN_ARRAY:					
+					fprintf(file, "\tsign-cast: in array at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				default:
+					fprintf(file, "\tpropagate-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				}
+				break;
+			case INTFNS_STMT_ARRAY_REF:
+				fprintf(file, "\tarray-ref at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_RELATION:
+				fprintf(file, "\trelation-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_VAR_PROPAGATE:
+				fprintf(file, "\tvar-propagate-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_MOD:
+				fprintf(file, "\tmod-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_NARROW:
+				fprintf(file, "\tnarrow-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_BIT:
+				fprintf(file, "\tbit-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SHR:
+				fprintf(file, "\tright-shift-op at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			//case INTFNS_STMT_LEFT_NOT_SSA:
+			//	fprintf(file, "\tlhs is not ssa at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_LEFT_NOT_INT:
+				fprintf(file, "\tlhs is not int at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			
+			case INTFNS_STMT_CAST_TO_unINT:
+				fprintf(file, "\tcast to not int at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_EQUAL_INEQUAL:
+				fprintf(file, "\tequal or inequal at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+
+			/* FUNC CALL stmt*/
+			case INTFNS_STMT_CALL:
+				switch(INTFNS_STMT_STATUS(stmt))
+				{
+				case INTFNS_CALL_SINK_LIB:
+					fprintf(file, "\tsink lib call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_CALL_UNCRITICAL_LIB:
+					fprintf(file, "\tuncritical lib call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_CALL_NORMAL_FUNC:
+					fprintf(file, "\tnormal func call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_CALL_EXTERNAL_SINK:
+					fprintf(file, "\texternal sink at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_CALL_EXTERNAL_UNCRITICAL:
+					fprintf(file, "\texternal uncritical call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				default:
+					fprintf(file, "\tfunc call at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				}
+			default:
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	}
+
+	fprintf(file, "-------------------------------------\n\n");
+	fclose(file);
+	return;
+}
+
+/* to mark each STMT for FUNC */
+static unsigned int
+intfns_mark_func (struct function * fun)
+{
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	FILE* file;
+	int ix, iy;
+	gimple stmt, phi, stmt_start;
+	int has_global_var = 0;	// used to indicate whether FUNC uses GLOBAL VAR
+	struct intfns_statistics * stat = INTFNS_STAT(fun);
+
+	/* a file descriptor to dump debug info*/
+	file =  fopen("/tmp/log_intfns_mark.txt", "a");
+	fprintf(file,"INTFNS-mark for %s(): \n",
+		lang_hooks.decl_printable_name(fun->decl, 2));
+	if((DECL_STRUCT_FUNCTION(fun->decl) == NULL) || (fun == NULL))
+	{
+		fprintf(file, " NO function* field\n");
+		fclose(file);
+		return 0;
+	}
+
+	// to analyze the designated function particularly.
+	/*if((strcmp(lang_hooks.decl_printable_name(fun->decl, 2), "Perl_my_atof2") == 0)
+		//||(strcmp(lang_hooks.decl_printable_name(current_function_decl, 2), "inflate_codes") == 0)
+		)
+		;
+	else
+	{
+		fprintf(file, " PASS!!!\n");
+		fclose(file);
+		return 0;
+	}*/
+
+	// dump each STMT for FUN.
+	intfns_dump_each_stmt_for_func(fun, file);
+
+	
+	fprintf(file, "\t>>begin\t");
+
+	/* 1. mark the stmt-type through a forward-analysis */
+	FOR_EACH_BB_FN(bb, fun)
+	{
+		for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+		{
+			phi = gsi_stmt(gsi);
+			if(phi != NULL)
+				intfns_mark_stmt(phi, &has_global_var, &stat);
+		}
+	
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+		{
+			stmt = gsi_stmt(gsi);
+	  		if(stmt != NULL)
+				intfns_mark_stmt(stmt, &has_global_var, &stat);
+		}
+	}
+	
+	stat->has_global_var = has_global_var;
+	fprintf(file, ">>basic mark, has-global-var:%d\t", stat->has_global_var);
+	
+	/* 2 mark the if/while/mul-offset/SignCastInArray through a backward-analysis. */
+	FOR_EACH_BB_REVERSE_FN(bb, fun)
+	{
+		// get the first stmt in bb
+		gsi = gsi_start_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt_start = gsi_stmt(gsi);
+
+		// get the last stmt in bb
+		gsi = gsi_last_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt = gsi_stmt(gsi);
+		
+		// travesal the stmt in bb backward.
+		while(stmt != stmt_start)
+		{
+			/* filter all the relation/mul stmt*/
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+				&&(INTFNS_STMT_LEFT_IS_SSA(stmt))
+				&&(
+				// IntEquiv
+				//(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)||
+				(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SMUL)
+				||(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UMUL)
+				|| ((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+					&& (INTFNS_SIGN_CAST_STATUS(stmt)))))		
+				intfns_mark_stmt_backward_cond_and_offset(stmt);
+			gsi_prev(&gsi);
+			stmt = gsi_stmt(gsi);
+		}
+		
+		// here, stmt is stmt-start
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+			&&(INTFNS_STMT_LEFT_IS_SSA(stmt))
+			&&(
+			//IntEquiv
+			//(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_RELATION)||
+			(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SMUL)
+			||(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UMUL)
+			|| ((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+				&& (INTFNS_SIGN_CAST_STATUS(stmt)))))
+			intfns_mark_stmt_backward_cond_and_offset(stmt);
+	}
+	fprintf(file, ">>cond and offset mark\t");
+
+	/*-----------------------------------------------------------------------------*/	
+	fprintf(file, ">>finish\n");
+	fclose(file);
+	return 1;
+}
+
+/*check whether current func is uncritical?
+	1. if all the PARAMs are not of ptr
+	2. no Global Vars
+	3. all the CALLEEs are uncritical or there are no CALLEEs
+	4. RET is void, set FUNCTION->is_uncritical = 1
+		if RET is not void, set it as 2 (meaning that HALF-uncritical)
+*/
+void intfns_check_uncritical (struct function * fun, struct cgraph_node * node)
+{
+	tree parm, type, result;
+	struct intfns_statistics * stat = INTFNS_STAT(fun);
+	unsigned int tag = 1;
+	struct cgraph_edge *edge;
+	struct function * callee_fun;
+	struct intfns_statistics * callee_stat;
+	gimple callee_stmt;
+	
+	FILE * file =  fopen("/tmp/log_intfns_uncritical.txt", "a");
+	fprintf(file,"INTFNS-uncritical for %s(): \n",
+		lang_hooks.decl_printable_name(fun->decl, 2));
+	
+	// 1. traversal each PARM of FUN, and check the corresponding TYPE
+	for (parm = DECL_ARGUMENTS (fun->decl); parm; parm = TREE_CHAIN (parm))
+	{
+		type = DECL_ARG_TYPE(parm);
+		
+		// if this ARG-TYPE is a pointer
+		if(POINTER_TYPE_P(type))
+		{
+			//fprintf(file, "\tpointer-%s", tree_code_name[TREE_CODE(type)]);
+			tag = 0;
+			break;
+		}
+	}
+	if(tag == 0)
+	{
+		fprintf(file, "\ttag= 0: arg-type has pointer.\n");
+		fclose(file);
+		return;
+	}
+	fprintf(file, "all ARG type are biaoliang.\n");
+	
+	// readonly func or pure func
+	if(TREE_READONLY(fun->decl) || DECL_PURE_P(fun->decl) || DECL_IS_NOVOPS(fun->decl))
+	{
+		tag = 1;
+		fprintf(file, "\tpure and novops\n");
+	}
+	// 2. no Global Vars
+	// 3. all the CALLEEs are uncritical or there are no CALLEEs
+	if(stat->has_global_var == 0)
+	{
+		tag = 1;
+		fprintf(file, "\tno global vars\n");
+		
+		for (edge = node->callees; edge; edge = edge->next_callee)
+		{
+			callee_fun = DECL_STRUCT_FUNCTION(edge->callee->decl);
+			callee_stmt = edge->call_stmt;
+			if(INTFNS_STMT_TYPE(callee_stmt)== INTFNS_STMT_CALL)
+			{
+				if((INTFNS_STMT_STATUS(callee_stmt) == INTFNS_CALL_UNCRITICAL_LIB)
+					|| (INTFNS_STMT_STATUS(callee_stmt) == INTFNS_CALL_EXTERNAL_UNCRITICAL))
+					;
+				else if(INTFNS_STMT_STATUS(callee_stmt) == INTFNS_CALL_NORMAL_FUNC)
+				{
+					callee_stat = INTFNS_STAT(callee_fun);
+					if(callee_stat == NULL)		
+						tag = 0;
+					else if(callee_stat->is_uncritical)
+						;
+					else
+						tag = 0;
+				}
+				else
+					tag = 0;
+			}
+			else
+				tag = 0;
+
+			if(tag == 0)
+				break;
+		}
+	}
+	else
+		tag = 0;
+
+	if(tag == 1)
+		fprintf(file, "\tcallee uncritical\n");
+	else
+	{
+		fclose(file);
+		return;
+	}
+	
+	// 4. RET is void, set FUNCTION->is_uncritical = 1, otherwise, set it as 2
+	result = DECL_RESULT(fun->decl);
+	type = TREE_TYPE(result);
+	if(TREE_CODE(type) == VOID_TYPE)
+	{
+		stat->is_uncritical = 1;
+		fprintf(file, "\tUNCRITICAL-1\n");
+	}
+	else
+	{
+		stat->is_uncritical = 2;
+		fprintf(file, "\tUNCRITICAL-2\n");
+	}
+	
+	fclose(file);
+	return;
+}
+
+/* execution function for pass_intfns_mark */
+static unsigned int
+execute_intfns_mark (void)
+{
+	struct function * fun = NULL;
+	struct cgraph_node * call_it;
+	struct intfns_statistics * stat;
+
+	// at first, get the number of IOs as input.
+	io_num = sizeof(io_info)/sizeof(struct intfns_ios_node);
+	if(io_num == 0)
+		return 1;
+
+	/* travesal each func-decl in this UNIT and initialize the STAT for each one. */
+	for(call_it = cgraph_nodes; call_it; call_it = call_it-> next)
+	{
+		fun = DECL_STRUCT_FUNCTION(call_it->decl);
+
+		if(fun != NULL)
+		{
+			/*ggc_alloc_cleared is used to allocate HEAP space.*/
+			stat = (struct intfns_statistics*)ggc_alloc_cleared(sizeof(struct intfns_statistics));
+
+			memset(stat->func_name, 0x00, 128);
+			stat->stmt_total = 0;
+			stat->intop_total = 0;
+			stat->intop_mul_offset = 0;
+			stat->intop_left_not_ssa = 0;
+			stat->intop_implicit = 0;
+			stat->intop_exclude_cst = 0;
+			stat->intop_exclude_unuse = 0;
+			stat->intop_exclude_uncritical_use = 0;
+			stat->intop_exclude_santz_post = 0;
+			stat->intop_exclude_bit = 0;
+			stat->intop_exclude_narrow = 0;
+			stat->intop_exclude = 0;
+
+			stat->sign_cast_total = 0;
+			stat->sign_cast_implicit = 0;
+			stat->sign_cast_in_array = 0;
+			stat->sign_cast_useless = 0;
+			stat->sign_cast_exclude_cst = 0;
+			stat->sign_cast_exclude_unuse = 0;
+			stat->sign_cast_exclude_uncritical_use = 0;
+			stat->sign_cast_exclude_santz_post = 0;
+			stat->sign_cast_exclude_bit = 0;
+			stat->sign_cast_exclude_narrow = 0;
+			stat->sign_cast_exclude = 0;
+	
+			stat->is_uncritical = 0;
+			stat->is_santzd = 0;
+			stat->has_global_var = 0;
+			stat->in_queue = 0;
+			
+			//init the path-pool
+			stat->intfns_path_node_pool = VEC_alloc(intfns_path_node, gc, 30);
+			stat->intfns_path_pool = VEC_alloc(intfns_path, gc, 10);
+
+			// inteq
+			stat->fun_ovf_flag = 0;
+			stat->intop_ovf = 0;
+			stat->path = 0;
+			stat->path_node_num = 0;
+			stat->path_node_min = 0x7fffffff;
+			stat->path_node_max = 0;
+			stat->path_intop_node_num = 0;
+			stat->path_intop_node_min = 0x7fffffff;
+			stat->path_intop_node_max = 0;
+			
+			stat->precs_min = 0x7fffffff;
+			stat->precs_max = 0;
+			
+			fun->intfns_info = (char *) stat;
+
+			// mark the stmts for each func
+			intfns_mark_func(fun);
+			
+			// check whether current func is uncritical or not.
+			//intfns_check_uncritical(fun, call_it);
+			
+			//dump all the marked stmt
+			intfns_dump_marked_stmt(fun);
+		}
+	}
+
+	// check each call sites
+	return 1;
+}
+
+/* invoked by -fintfns */
+static bool
+gate_intfns (void)
+{
+	return flag_intfns;
+}
+
+/* pass_intfns_mark definition */
+struct ipa_opt_pass_d pass_intfns_mark =
+{
+ {
+  IPA_PASS,
+  "intfns_mark",		                /* name */
+  gate_intfns,							/* gate */
+  execute_intfns_mark,			        /* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_INTFNS_MARK,		/* tv_id */
+  PROP_ssa,	            /* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0                     /* todo_flags_finish */
+ },
+ NULL,		        /* generate_summary */
+ NULL,				/* write_summary */
+ NULL,				/* read_summary */
+ NULL,				/* function_read_summary */
+ 0,					/* TODOs */
+ NULL,			    /* function_transform */
+ NULL				/* variable_transform */
+};
+
+
+/*---------------------------------------------------------------------------------*/
+/*---------------------  intfns-cst, do const propagation work for intfns-------------------*/
+/*---------------------------------------------------------------------------------*/
+/* todo: detailed infor about intfns-cst progress.
+
+the cst-propagation we are currently considering is only for ssa-names.
+current version of implementation isnt field-senstive.
+we may want to extend our tool in the future.
+
+Further Readings:
+we may want to refer to the SSA propagation engine (tree-ssa-propagate.c)
+
+under -O1 optimization level:
+	-ftree-ccp will invoke pass-ccp. 
+		the details of implementation is on tree-ssa-ccp.c file.
+		its task is to conduct Conditional Constant Propagation.
+	-ftree-dominator-opts will invoke pass_dominator
+		the details of implementation is on tree-ssa-dom.c file.
+		its task is SSA Dominator optimizations for trees
+		
+under -O2 optimization level:
+	-fipa-cp will invoke pass_ipa_cp.
+		the details can be got on ipa-cp.c file.
+		its taks is to Interprocedural constant propagation.
+*/
+
+
+/* basic CST-propagate for each STMT */
+void intfns_cst_stmt(gimple stmt)
+{
+	if(gimple_code (stmt) == GIMPLE_ASSIGN)
+	{		
+		tree lhs, rhs1, rhs2;
+		enum gimple_rhs_class grhs_class;	// class of rhs-expr 
+		grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));
+
+		lhs = gimple_assign_lhs (stmt);
+
+		// if lhs is a globla var, we pass
+		if(is_global_var(lhs))
+			return;
+		
+		if(grhs_class == GIMPLE_BINARY_RHS)
+		{
+			rhs1 = gimple_assign_rhs1(stmt);
+			rhs2 = gimple_assign_rhs2(stmt);
+
+			// is_gimple_constant is to check whether rhs1 is a cst or not
+			// TYPE_READONLY is to check the 'const' type
+			if(is_gimple_constant(rhs1))
+				INTFNS_TREE_NODE_CST(rhs1) = 1;
+
+			if(is_gimple_constant(rhs2))
+				INTFNS_TREE_NODE_CST(rhs2) = 1;
+		}
+		else
+		{
+			rhs1 = gimple_assign_rhs1(stmt);
+			if(is_gimple_constant(rhs1))
+				INTFNS_TREE_NODE_CST(rhs1) = 1;
+		}
+
+		// then cst propagate from rhs1 and rhs2 to lhs
+		if (grhs_class == GIMPLE_BINARY_RHS)	// c = a op b
+		{
+			if((INTFNS_TREE_NODE_CST(rhs1))
+				&& (INTFNS_TREE_NODE_CST(rhs2)))
+			{
+				INTFNS_TREE_NODE_CST(lhs) = 1;
+				
+				// for UADD~SSHL, set the tag 'EXCLUDE-CST' and 'EXCLUDE'
+				if((INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+					&&(INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL))
+					INTFNS_STMT_EXCLUDE_CST(stmt) = 1;
+					INTFNS_STMT_EXCLUDE(stmt) = 1;
+			}
+			else
+				INTFNS_TREE_NODE_CST(lhs) = 0;
+
+			//IntEquiv
+			//if(INTFNS_TREE_NODE_CST(rhs2))
+			//{					
+				// check 'c = a%b'; if 'b' is CSTed, we set this MOD-stmt as Narrow-op
+			//	if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_MOD)
+			//		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NARROW;
+
+				// check 'c = a>>b'; if 'b' is CSTed, we set this RSHIFT-stmt as Narrow-op
+			//	if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SHR)
+			//		INTFNS_STMT_TYPE(stmt) = INTFNS_STMT_NARROW;			
+			//}
+		}
+		else	//GIMPLE_SINGLE_RHS or GIMPLE_INVALID_RHS
+		{
+			// if 'a = &b' and 'b' is cst, we have to clean up such tag
+			// as 'b' may be modified in a way we don't know.
+			if(gimple_assign_rhs_code(stmt) == ADDR_EXPR)
+			{
+				if(INTFNS_TREE_NODE_CST(rhs1))
+					INTFNS_TREE_NODE_CST(rhs1) = 0;
+			}
+			
+			INTFNS_TREE_NODE_CST(lhs) = INTFNS_TREE_NODE_CST(rhs1);
+		}
+	}
+	else if (gimple_code (stmt) == GIMPLE_CALL)
+	{
+		// todo: here we will handler something for the inter-p analysis
+		/*
+		here, the premise is that this call-stmt is Normal-func.
+		at first, if the N-th argument of Normal-func is CSTed, then we will update
+		the Status of Normal-func in the call-graph.
+		if  for all the call sites of Normal-func, the N-th argument is CSTed,
+		then, we will add Normal-func marked with N-th, into the Worklist.
+
+		when implementation, please refer to the IntTracker for parts of details.
+		*/
+
+		/* THEN, check the call form is result = func( arg0, arg1, ..., argN);
+		then, if func is LIB-UNCRITICAL or External-UNCRITICAL
+		we will set 'result' as CSTed.
+		*/
+		tree result;
+		if(gimple_has_lhs(stmt))
+		{
+			result = gimple_call_lhs(stmt);
+			if((INTFNS_STMT_STATUS(stmt)== INTFNS_CALL_UNCRITICAL_LIB)
+				|| (INTFNS_STMT_STATUS(stmt)== INTFNS_CALL_EXTERNAL_UNCRITICAL))
+				INTFNS_TREE_NODE_CST(result) = 1;
+
+			
+			if(gimple_call_fndecl(stmt) == NULL)
+			{
+				;
+			}
+			/* here, we wanna check whehter argI is '&a',
+			if 'a' is set constant before, we have to clean this tag up. */
+			else
+			{
+				int ix;
+				tree arg, node;
+				for (ix = 0; ix < gimple_call_num_args (stmt); ix++)
+				{
+					arg = gimple_call_arg (stmt, ix);
+					if(arg == NULL_TREE)
+						continue;         
+					if(TREE_CODE(arg) == ADDR_EXPR)
+					{
+						//debug_gimple_stmt (stmt);
+						node = TREE_OPERAND(arg, 0);
+						if(INTFNS_TREE_NODE_CST(node))
+							INTFNS_TREE_NODE_CST(node) = 0;
+					}					
+				}
+			}
+			/* fixme: for libcall : result = libcall(arg1, arg2, ...);
+			if each argI is cst, then we can set this result as cst */
+			/*else if(DECL_BUILT_IN(gimple_call_fndecl(stmt)))
+			{
+				int ix;
+				tree arg;
+				unsigned int cst = 1;
+				for (ix = 0; ix < gimple_call_num_args (stmt); ix++)
+				{
+					arg = gimple_call_arg (stmt, ix);
+					if(arg == NULL_TREE)
+						continue;         
+					
+					if(is_gimple_constant(arg))
+						;
+					else
+					{
+						cst = 0;
+						break;
+					}
+				}
+				
+				if(cst)
+					INTFNS_TREE_NODE_CST(result) = 1;
+			}*/
+		}
+	}
+	else if (gimple_code (stmt) == GIMPLE_PHI)
+	{	// result = phi (arg0, arg1, ..., argN)
+		tree result, arg;
+		int ix;
+		int tag = 1;
+		result = gimple_phi_result (stmt);
+
+		// if each ARGi is CSTed, then set 'result' CSTed
+		for(ix = 0; ix < gimple_phi_num_args(stmt); ix ++)
+		{
+			arg = gimple_phi_arg(stmt, ix)->def;
+			if(INTFNS_TREE_NODE_CST(arg) == 0)
+			{
+				tag = 0;
+				break;
+			}
+		}
+
+		if(tag == 1)
+			INTFNS_TREE_NODE_CST(result) = 1;
+	}
+	else
+		;
+	
+	return;
+}
+
+/* to check whether one phi-stmt and the def-stmt of argI are co-depend 
+	arg-def-stmt: 	argI = A op const;/ argI = A;
+	phi-stmt: 		result = phi(const, argI);
+		then, we check A == result
+		
+	or----------	
+	another-def-stmt:	A = B op const;	/ A = B;
+	arg-def-stmt: 	argI = A op const; / argI = A;
+	phi-stmt: 		result = phi(const, argI);
+		then, we check B == result
+
+	if co-depend, we set INTFNS_TREE_NODE_CST(result) = 1;
+*/
+void intfns_cst_stmt_special_codepend(tree phi_result, gimple arg_def_stmt)
+{
+	tree rhs1, rhs2, rhs;
+	if(arg_def_stmt == NULL)
+		return;
+	if(gimple_code (arg_def_stmt) != GIMPLE_ASSIGN)
+		return;
+	
+	if(get_gimple_rhs_class (gimple_assign_rhs_code (arg_def_stmt)) == GIMPLE_BINARY_RHS)
+	{
+		rhs1 = gimple_assign_rhs1(arg_def_stmt);
+		rhs2 = gimple_assign_rhs2(arg_def_stmt);
+
+		if((INTFNS_TREE_NODE_CST(rhs1)) && (!INTFNS_TREE_NODE_CST(rhs2)))
+		{
+			rhs = rhs2;
+		}
+		else if((!INTFNS_TREE_NODE_CST(rhs1)) && (INTFNS_TREE_NODE_CST(rhs2)))
+		{
+			rhs = rhs1;
+		}
+		else
+			return;
+
+		if(rhs == phi_result)
+		{
+			INTFNS_TREE_NODE_CST(phi_result) = 1;
+
+			// then we set current arg-def-stmt as CSTed
+			INTFNS_TREE_NODE_CST(gimple_assign_lhs(arg_def_stmt)) = 1;
+			if((INTFNS_STMT_TYPE(arg_def_stmt) >= INTFNS_STMT_UADD)
+				&& (INTFNS_STMT_TYPE(arg_def_stmt) <= INTFNS_STMT_SSHL))
+			{
+				INTFNS_STMT_EXCLUDE_CST(arg_def_stmt) = 1;
+				INTFNS_STMT_EXCLUDE(arg_def_stmt) = 1;
+			}
+			return;
+		}
+		else
+		{	// fixme: we may want to conduct a recursive call 
+			if(TREE_CODE(rhs) == SSA_NAME)
+				intfns_cst_stmt_special_codepend(phi_result, SSA_NAME_DEF_STMT(rhs));
+		}
+	}
+	else
+	{
+		rhs1 = gimple_assign_rhs1(arg_def_stmt);
+		if(rhs1 == NULL_TREE)
+			return;
+		else if(rhs1 == phi_result)
+		{
+			INTFNS_TREE_NODE_CST(phi_result) = 1;
+			return;
+		}
+		else
+		{	// fixme: we may want to conduct a recursive call 
+			if(TREE_CODE(rhs1) == SSA_NAME)
+				intfns_cst_stmt_special_codepend(phi_result, SSA_NAME_DEF_STMT(rhs1));
+		}
+	}
+	return;
+}
+
+/* special CST-propagate for each phi-stmt to handle the particular FOR-stmt  */
+/* for example, the ssa form of for( i=1; i < 10; i++) is like:
+		<bb 2>:
+		  i_2 = 1;
+		  goto <bb 4>;
+
+		<bb 3>:
+		  D.1690_3 = (const char * restrict) &"ok:%d\n"[0];
+		  printf (D.1690_3, i_1);
+		  i_4 = i_1 + 1;
+
+		<bb 4>:
+		  # i_1 = PHI <i_2(2), i_4(3)>
+		  if (i_1 <= 9)
+		    goto <bb 3>;
+		  else
+		    goto <bb 5>;
+
+		<bb 5>:
+		  return;
+
+	we can observe that, i_4 and i_1 are depended by each other.
+	it is not easy for the basic forwarding propagation described above to determine
+	both i_4 and i_1 are CSTed.
+
+	another typical example is 
+		for (i=0, j=1; i < j; i = j, j = (2*j+1)) large = i;
+	the corresponding ssa is like:
+		<bb 2>:
+		  i_3 = 0;
+		  j_4 = 1;
+		  goto <bb 4>;
+
+		<bb 3>:
+		  large_5 = i_1;
+		  i_6 = j_2;
+		  D.1692_7 = j_2 * 2;
+		  j_8 = D.1692_7 + 1;
+
+		<bb 4>:
+		  # i_1 = PHI <i_3(2), i_6(3)>
+		  # j_2 = PHI <j_4(2), j_8(3)>
+		  if (i_1 < j_2)
+		    goto <bb 3>;
+		  else
+		    goto <bb 5>;
+
+		<bb 5>:
+		  return;
+	
+	therefore, we wanna conduct a further analysis to handle the PHI-stmt particularly.	
+*/
+void intfns_cst_stmt_special(gimple phi)
+{
+	tree result, arg1, arg2, arg;
+	gimple arg_def;
+	
+	// if 'result' is already CSTed, return.
+	// currently, we only consider two ARGs
+	result = gimple_phi_result (phi);
+	if((INTFNS_TREE_NODE_CST(result))
+		|| (gimple_phi_num_args(phi) != 2))
+		return;
+
+	// result = phi (arg1, arg2) 
+	arg1 = gimple_phi_arg(phi, 0)->def;
+	arg2 = gimple_phi_arg(phi, 1)->def;
+
+	// 1. find the unCSTed one and use 'arg' to indicate that ARG.
+	if(INTFNS_TREE_NODE_CST(arg1))
+	{
+		arg = arg2;
+	}
+	else
+	{
+		arg = arg1;
+		if(!INTFNS_TREE_NODE_CST(arg2))
+			return;
+	}
+
+	// 2. find the def-stmt of 'arg' and check whether it is depended by 'result'
+	arg_def = SSA_NAME_DEF_STMT(arg);
+	intfns_cst_stmt_special_codepend(result, arg_def);
+	
+	/*FILE* file = fopen("/tmp/log_intfns_cst_special.txt", "a");
+	print_gimple_stmt (file, phi, 0, TDF_LINENO);
+	fprintf(file, "arg1:%d, arg2:%d\n", 
+		INTFNS_TREE_NODE_CST(arg1),INTFNS_TREE_NODE_CST(arg2));
+	fprintf(file, "its def stmt is \n");
+	print_gimple_stmt (file, arg_def, 0, TDF_LINENO);
+	fprintf(file, "----------------\n\n");
+	fclose(file);*/
+	return;
+	
+}
+
+/* to cst-propagate each STMT for FUNC */
+static unsigned int
+intfns_cst_func (struct function * func)
+{
+	gimple_stmt_iterator gsi;
+	basic_block bb;
+	gimple stmt, phi;
+
+	// 1. traverse each STMT of func. it is a forwarding propagation.
+	FOR_EACH_BB_FN(bb, func)
+	{
+	for(gsi = gsi_start_phis(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		phi = gsi_stmt(gsi);
+		if(phi != NULL)
+			intfns_cst_stmt(phi);
+	}
+	
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{		
+		stmt = gsi_stmt(gsi);
+		if((stmt != NULL)
+			&&((gimple_code (stmt) == GIMPLE_ASSIGN)
+				|| (gimple_code (stmt) == GIMPLE_CALL)))
+			intfns_cst_stmt(stmt);
+	}
+	}
+
+	// 2. we have further to handler the special cases in for-stmt
+	FOR_EACH_BB_FN(bb, func)
+	for(gsi = gsi_start_phis(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		phi = gsi_stmt(gsi);
+		if(phi != NULL)
+			intfns_cst_stmt_special(phi);
+	}
+
+	// 3. at last, conduct the process 1 again.
+	FOR_EACH_BB_FN(bb, func)
+	{
+	for(gsi = gsi_start_phis(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+		phi = gsi_stmt(gsi);
+		if(phi != NULL)
+			intfns_cst_stmt(phi);
+	}
+	
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{		
+		stmt = gsi_stmt(gsi);
+		if((stmt != NULL)
+			&&((gimple_code (stmt) == GIMPLE_ASSIGN)
+				|| (gimple_code (stmt) == GIMPLE_CALL)))
+			intfns_cst_stmt(stmt);
+	}
+	}
+	
+	return 1;
+}
+
+/* dump the CSTed integer operations marked by intfns-cst. */
+void intfns_dump_csted_stmt(struct function * func)
+{
+	gimple_stmt_iterator gsi;
+	basic_block bb;
+	gimple stmt;
+	FILE* file;
+	
+	/* a file descriptor to dump debug info*/
+	file =	fopen("/tmp/log_intfns_csted_stmt.txt", "a");
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(func->decl, 2));
+
+	/* travesal each stmt in func. */
+	FOR_EACH_BB_FN(bb, func)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+	stmt = gsi_stmt(gsi);
+	if(stmt != NULL)
+	{		
+		if((gimple_code (stmt) == GIMPLE_ASSIGN)
+			// && (INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+			// && (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL)
+			&& (INTFNS_STMT_EXCLUDE_CST(stmt)))
+		{
+			fprintf(file, "\tCSTed ");
+			switch(INTFNS_STMT_TYPE(stmt))
+			{
+			case INTFNS_STMT_UADD:
+				fprintf(file, "unsigned add at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SADD:
+				fprintf(file, "signed add at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_USUB:
+				fprintf(file, "unsigned sub at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SSUB:
+				fprintf(file, "signed sub at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_UMUL:
+				fprintf(file, "unsigned mul at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SMUL:
+				fprintf(file, "signed mul at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_USHL:
+				fprintf(file, "unsigned shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SSHL:
+				fprintf(file, "signed shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_PROPAGATE:
+				switch(INTFNS_SIGN_CAST_STATUS(stmt))
+				{
+				case INTFNS_STMT_SIGN_TO_UNSIGN:
+					fprintf(file, "sign->unsign at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_STMT_UNSIGN_TO_SIGN:
+					fprintf(file, "\tsign-cast: unsign->sign at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				default:
+					break;
+				}
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	}
+
+	fprintf(file, "-------------------------------------\n\n");
+	fclose(file);
+	return;
+}
+
+/* execution function for pass_intfns_cst */
+static unsigned int
+execute_intfns_cst (void)
+{
+	return 1;
+// FIXME: 
+// In the case of IntEquiv, we should close this PASS
+
+	struct cgraph_node *node;
+	struct function * func = NULL;
+	
+	// this container is used as the Worklist for inter-procedure analysis
+	//VEC(intfns_func, gc) * func_queue = VEC_alloc(intfns_func, gc, 10);
+
+	/*1. intra-p, taint propagate from CST node. ---------*/
+	for (node = cgraph_nodes; node; node = node->next)
+	{
+		/* Nodes without a body are not interesting.  */
+      	if (!gimple_has_body_p (node->decl)
+	  		|| node->clone_of)
+			continue;
+
+		func = DECL_STRUCT_FUNCTION (node->decl);
+		intfns_cst_func(func);
+		// as for the inter-p analysis, we would select the Func whose certain PARM is cst into the Worklist
+		// intfns_cst_func(func, func_queue);
+	}
+
+	/*2. inter-p, using worklist algorithm to taint propagate from the CST PARM----*/
+	/*struct function * elmt;
+	while(!VEC_empty(intfns_func, func_queue))
+	{
+		elmt = VEC_pop(intfns_func, func_queue);
+		intfns_cst_func(elmt, 2, &func_queue);
+	}*/
+	
+	// at last, free the que.
+	//if(func_queue != NULL)
+	//VEC_free(intfns_func, gc, func_queue);
+	
+	
+	/*3. at last, dump all CSTed intop*/
+	for (node = cgraph_nodes; node; node = node->next)
+	{
+		/* Nodes without a body are not interesting.  */
+      	if (!gimple_has_body_p (node->decl)
+	  		|| node->clone_of)
+			continue;
+		
+		func = DECL_STRUCT_FUNCTION (node->decl);
+		intfns_dump_csted_stmt(func);
+	}
+	
+	return 1;
+}
+
+/* pass_intfns_begin definition */
+struct ipa_opt_pass_d pass_intfns_cst =
+{
+ {
+  IPA_PASS,
+  "intfns_cst",		                /* name */
+  gate_intfns,					/* gate */
+  execute_intfns_cst,			        /* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_INTFNS_CST,		/* tv_id */
+  PROP_ssa,	            /* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0                     /* todo_flags_finish */
+ },
+ NULL,		        /* generate_summary */
+ NULL,				/* write_summary */
+ NULL,				/* read_summary */
+ NULL,				/* function_read_summary */
+ 0,					/* TODOs */
+ NULL,			    /* function_transform */
+ NULL				/* variable_transform */
+};
+
+
+/*---------------------------------------------------------------------------------*/
+/*---------------------  intfns-dep, do ending work for intfns----------------------------*/
+/*---------------------------------------------------------------------------------*/
+/* todo: details about dep.
+
+P1: const intop  -->> handled at intfns-cst phase
+P2: unused -->> we have to mark it at first
+P3: uncritical lib -->> marked at intfns-mark phase
+P4: santz-postcond -->> we have to mark it at first
+P5: Bit -->> marked at intfns-mark phase
+P6: Mod-narrow -->> first marked at intfns-mark phase, and further updated at intfns-cst phase
+Implicit intop: -->> we have to mark it at first
+
+then, we will conduct an inter-p dep analysis to find out all the intop,
+which are post dominated by P2, P3, P5 and P6.
+*/
+
+/* aux functions for path extraction. */
+int build_path_node(intfns_path_node* path_node, VEC(intfns_path_node, gc)** path_node_pool,
+ 			gimple stmt)
+{
+	int type;
+	(*path_node) = (intfns_path_node) ggc_alloc_cleared(sizeof(struct intfns_path_node_def));	
+
+	// allocation succeeds
+	if((*path_node) != NULL)
+	{
+		(*path_node)->stmt = stmt;
+		VEC_safe_push(intfns_path_node, gc, (*path_node_pool), (*path_node));
+		return 1;
+	}
+	// allocate err
+	else
+	{
+		FILE * file_warn =	fopen("/tmp/intfns_warning.txt", "a");
+		fprintf(file_warn,"malloc error in build_path_node().\n");
+		fclose(file_warn);
+		return -1;
+	}
+}
+
+int build_path(intfns_path* path, VEC(intfns_path, gc)** path_pool)
+{
+	int type;
+	(*path) = (struct intfns_path_def*) ggc_alloc_cleared(sizeof(struct intfns_path_def));	
+
+	// allocation succeeds
+	if((*path) != NULL)
+	{
+		(*path)->node_list = VEC_alloc(intfns_path_node, gc, 2);
+		(*path)->status = 0;
+		VEC_safe_push(intfns_path, gc, (*path_pool), (*path));
+		return 1;
+	}
+	// allocate err
+	else
+	{
+		FILE * file_warn =	fopen("/tmp/intfns_warning.txt", "a");
+		fprintf(file_warn,"malloc error in build_path().\n");
+		fclose(file_warn);
+		return -1;
+	}
+}
+
+int copy_path(intfns_path src, intfns_path dest)
+{
+	int ix;
+	intfns_path_node node;
+	for(ix = 0; VEC_iterate(intfns_path_node, (src->node_list), ix, node); ix ++)
+	{		
+		VEC_safe_push(intfns_path_node, gc, (dest->node_list), node);
+	}
+	src->status = dest->status;
+	src->has_ovf_intop = dest->has_ovf_intop;
+}
+
+// dump one full path, which are stored in new-path-nodes
+void dump_full_path(struct function * func, unsigned int path_counter, unsigned int path_type,
+	VEC(intfns_path_node, gc)* new_path_nodes)
+{
+	FILE * file = fopen("/tmp/log_intfns_FULL_paths.txt", "a");
+	fprintf(file,"FUNCTION %s(): path-%d ", lang_hooks.decl_printable_name(func->decl, 2), path_counter);
+
+	// print path type
+	if(path_type == PATH_TO_ARRAYREF)
+		fprintf(file, "<to array ref> ");
+	else if(path_type == PATH_TO_ARRAYREF_OFFSET)
+		fprintf(file, "<to array ref offset> ");
+	else if(path_type == PATH_TO_ARRAYREF_LHS)
+		fprintf(file, "<to left array ref> ");
+	else if(path_type == PATH_TO_POINTER_PLUS)
+		fprintf(file, "<to ptr plus> ");
+	else if(path_type == PATH_TO_INTOP)
+		fprintf(file, "<to intop> ");
+	else if(path_type == PATH_TO_RET)
+		fprintf(file, "<to ret> ");
+	else if(path_type == PATH_TO_COND)
+		fprintf(file, "<to cond> ");
+	else if(path_type == PATH_TO_CAST_TO_unINT)
+		fprintf(file, "<to unINT> ");
+	else if(path_type == PATH_TO_EQUAL_INEQAUL)
+		fprintf(file, "<to eq or ineq> ");
+	else if(path_type == PATH_TO_UNKWN)
+		fprintf(file, "<to unknown site> ");
+	else if(path_type == PATH_TO_UNUSE)
+		fprintf(file, "<to unuse> ");
+	else if(path_type == PATH_TO_UNCRITICAL)
+		fprintf(file, "<to ununcritical> ");
+	else
+		fprintf(file, "<to void> ");
+	fprintf(file, "\n");
+	
+	int ix;
+	intfns_path_node path_node;
+	gimple stmt;
+	
+	// print each node of this full path
+	for(ix = 0; VEC_iterate(intfns_path_node, new_path_nodes, ix, path_node); ix++)
+	{
+		stmt = path_node->stmt;
+		if(stmt != NULL)
+		{
+			print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+			fprintf(file, "=====>>>>\n");
+		}
+		else
+			fprintf(file, "NULL-NODE\n=====>>>>\n");
+	}
+	fprintf(file, "\n\n");
+	fclose(file);
+}
+
+// dump all intop nodes for one path, which are stored in intop-nodes
+void dump_all_intop_for_path(struct function * func, unsigned int path_counter, 
+	VEC(intfns_path_node, gc)* intop_nodes)
+{
+	FILE * file = fopen("/tmp/log_intfns_INTOP_paths.txt", "a");
+	
+	// 0. get the first INTOP in intop-nodes, we wanna to get the FILENAME of INTOP
+	intfns_path_node path_node;
+	gimple stmt;
+	path_node = VEC_index(intfns_path_node, intop_nodes, 0);
+	stmt = path_node->stmt;
+	if(stmt != NULL)
+		fprintf(file, "%s", gimple_filename(stmt));
+	else
+		fprintf(file, "NULL");
+
+	// 1. print the FUNC-NAME
+	fprintf(file,"+%s", lang_hooks.decl_printable_name(func->decl, 2));
+
+	// 2. convert path-counter into 'string'
+	char path_counter_str[4];
+	path_counter_str[0] = '0' + (path_counter / 100);
+	path_counter_str[1] = '0' + ((path_counter / 10) % 10);
+	path_counter_str[2] = '0' + (path_counter % 10);
+	path_counter_str[3] = '\0';
+
+	// print the PATH-COUNTER
+	fprintf(file, "%s\n", path_counter_str);
+
+	// 3. print the NUMBER of intop for each PATH
+	fprintf(file, "%d\n", VEC_length(intfns_path_node, intop_nodes));
+	
+	// 4. print each node of this full path
+	int ix;
+	for(ix = 0; VEC_iterate(intfns_path_node, intop_nodes, ix, path_node); ix++)
+	{
+		stmt = path_node->stmt;
+		if((stmt != NULL)
+			&& (INTFNS_INTOP_OVF(stmt)))	// this STMT is OVFed intop
+		{
+			print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+		}
+		else
+			fprintf(file, "NULL-NODE\n");
+	}
+	//fprintf(file, "\n\n");
+	fclose(file);
+	return;
+}
+
+// get the name of NODE, and store it into our STR
+unsigned int get_tree_node_name(tree node, char * str)
+{
+	char ssaid_str[5];
+	// Here, node can be either SSA-NAME or VAR-DECL
+	// for SSA-NAME, STR is ssa-name-var + ssa-name-version + intfns-ssaid
+	if(TREE_CODE(node) == SSA_NAME)
+	{	// for this part, please refer to print-tree.c : 95 for details
+		tree ssa_name_var = SSA_NAME_VAR(node);
+		if(DECL_NAME(ssa_name_var))
+		{
+			sprintf(str, "%s_%u",
+				IDENTIFIER_POINTER(DECL_NAME(ssa_name_var)),
+				SSA_NAME_VERSION(node));			
+		}
+		else
+		{
+			sprintf(str, "D.%u_%u", DECL_UID (node), SSA_NAME_VERSION(node));
+		}
+		
+		if(INTFNS_TREE_NODE_SSAID(node))
+		{
+			sprintf(ssaid_str, "_%u", INTFNS_TREE_NODE_SSAID(node));
+			strcat(str, ssaid_str);
+		}
+		return 1;
+	}
+	else if(TREE_CODE(node) == VAR_DECL)
+	{
+		sprintf(str, "%s_haosun", IDENTIFIER_POINTER(DECL_NAME(node)));
+		if(INTFNS_TREE_NODE_SSAID(node))
+		{
+			sprintf(ssaid_str, "_%u", INTFNS_TREE_NODE_SSAID(node));
+			strcat(str, ssaid_str);
+		}
+		return 1;
+	}
+	else
+		return 0;
+}
+
+// print each STMT into z3 format
+tree dump_z3_for_stmt(FILE * file, gimple stmt, tree prev_def_node, 
+	VEC(tree, gc)** tree_node_list_addr, unsigned int * ret_val)
+{	// note that  ret_val is initialized as 1
+	// print the details of this STMT
+	fprintf(file, ";STMT: ");
+	print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+	
+	// 1. at first, get the names of OPs and print the Declarations in Z3
+	tree rhs1, rhs2, lhs;
+	unsigned int rhs1_is_const = 0, rhs2_is_const = 0;
+	unsigned int rhs1_const, rhs2_const;
+	//unsigned int rhs1_ssaid, rhs2_ssaid;
+	char rhs1_str[255], rhs2_str[255], lhs_str[255];	// to store the names of OP
+
+	enum gimple_rhs_class grhs_class;	/* class of rhs-expr */
+	switch (gimple_code (stmt))
+	{
+	case GIMPLE_ASSIGN:
+		grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));
+		lhs = gimple_assign_lhs (stmt);
+		
+		/* binary operation, c = a op b; */
+		if (grhs_class == GIMPLE_BINARY_RHS)
+		{
+			rhs1 = gimple_assign_rhs1(stmt);
+			rhs2 = gimple_assign_rhs2(stmt);
+		}
+		/* UNARY op */
+		else if(grhs_class == GIMPLE_UNARY_RHS)
+		{
+			rhs1 = gimple_assign_rhs1(stmt);
+			rhs2 = NULL;
+		}
+		//GIMPLE_SINGLE_RHS or GIMPLE_INVALID_RHS
+		else
+		{
+			rhs1 = gimple_assign_rhs1(stmt);
+			rhs2 = NULL;
+		}
+		break;
+	case GIMPLE_COND:
+		lhs = NULL;	//fixme here, we will define our own
+		rhs1 = gimple_cond_lhs(stmt);
+		rhs2 = gimple_cond_rhs(stmt);
+		break;
+	case GIMPLE_PHI:
+		lhs = gimple_phi_result(stmt);
+		rhs1 = prev_def_node;
+		rhs2 = NULL;
+		break;
+	default:
+		*ret_val = 0;
+		break;
+	}
+	
+	// for rhs1 and rhs2,
+	// we at first check whether they are CONST or not, if so, rhs1-str and rhs2-str can be easily obtained
+	// then, we will check the INLIST flag of rhs1/rhs2, if so, rhs1/2-str is also trivial;
+	// 	if not, we have enlist them and Declare and Assert
+	if(rhs1 != NULL)
+	{
+		if(TREE_CODE(rhs1) == INTEGER_CST)
+		{
+			rhs1_is_const = 1;
+			rhs1_const = TREE_INT_CST_LOW(rhs1);
+			//printf("%0*X", rhs1_const);
+			// test
+			//fprintf(file, ">>>>> rhs1: %0*X\n", sizeof(rhs1_const) * 2, rhs1_const);
+		}
+		else
+		{
+			unsigned int name_ok = get_tree_node_name(rhs1, rhs1_str);
+
+			if(name_ok)
+			{	
+			// test
+			//fprintf(file, ">>>>> rhs1: %s\n", rhs1_str);
+			
+			// if not INLIST, we have to do the following things:
+			// 1. push RHS1 into our LIST
+			// 2. update the INLIST flag of RHS1
+			// 3. Declare of RHS1_32/64, and Assert
+			if(!INTFNS_TREE_NODE_INLIST(rhs1))
+			{	//the name of RHS1: fprintf(file, "%s\n", rhs1_str);
+				VEC_safe_push(tree, gc, (*tree_node_list_addr), rhs1);
+				INTFNS_TREE_NODE_INLIST(rhs1) = 1;
+				fprintf(file, "(declare-fun %s_32 () (_ BitVec 32))\n", rhs1_str);
+				fprintf(file, "(declare-fun %s_64 () (_ BitVec 64))\n", rhs1_str);
+				fprintf(file, "(assert (= %s_64 (concat #x00000000 %s_32)))\n", 
+					rhs1_str, rhs1_str);
+
+				// FIXME:
+				// for unsigned int, we get xx_64 by concating #x0000 0000 with xx_32,
+				// however as for signed int, we have to get xx_64 by concating #xffff ffff with xx_32
+				// if xx_32 is negative
+			}
+			
+			}
+			*ret_val = *ret_val & name_ok;				
+		}
+	}
+	
+	if(rhs2 != NULL)
+	{
+		if(TREE_CODE(rhs2) == INTEGER_CST)
+		{
+			rhs2_is_const = 1;
+			rhs2_const = TREE_INT_CST_LOW(rhs2);
+			//printf("%0*X", rhs2_const);
+			// test
+			//fprintf(file, ">>>>> rhs2: %0*X\n", sizeof(rhs2_const) * 2, rhs2_const);
+		}
+		else
+		{
+			unsigned int name_ok = get_tree_node_name(rhs2, rhs2_str);
+
+			if(name_ok)
+			{				
+			
+			// test
+			//fprintf(file, ">>>>> rhs2: %s\n", rhs2_str);
+			
+			// if not INLIST, we have to do the following things:
+			// 1. push RHS2 into our LIST
+			// 2. update the INLIST flag of RHS2
+			// 3. Declare of RHS2_32/64, and Assert
+			if(!INTFNS_TREE_NODE_INLIST(rhs2))
+			{	//the name of RHS2: fprintf(file, "%s\n", rhs2_str);
+				VEC_safe_push(tree, gc, (*tree_node_list_addr), rhs2);
+				INTFNS_TREE_NODE_INLIST(rhs2) = 1;
+				fprintf(file, "(declare-fun %s_32 () (_ BitVec 32))\n", rhs2_str);
+				fprintf(file, "(declare-fun %s_64 () (_ BitVec 64))\n", rhs2_str);
+				fprintf(file, "(assert (= %s_64 (concat #x00000000 %s_32)))\n", 
+					rhs2_str, rhs2_str);
+			}
+			
+			}
+			*ret_val = *ret_val & name_ok;				
+		}
+	}
+	
+	// for lhs
+	if(lhs != NULL)
+	{
+		// if not INLIST, we have to do the following things:
+		// 1. push LHS into our LIST
+		// 2. update the INLIST flag of LHS
+		// 3. update the ISLEFT flag of LHS
+		// 4. Declare of LHS_32/64
+		if(!INTFNS_TREE_NODE_INLIST(lhs))
+		{	//the name of LHS: fprintf(file, "%s\n", lhs_str);
+			unsigned int name_ok = get_tree_node_name(lhs, lhs_str);
+			if(name_ok)
+			{
+				// test
+				//fprintf(file, ">>>>> lhs: %s\n", lhs_str);
+				
+				VEC_safe_push(tree, gc, (*tree_node_list_addr), lhs);
+				INTFNS_TREE_NODE_INLIST(lhs) = 1;
+				INTFNS_TREE_NODE_ISLEFT(lhs) = 1;
+				fprintf(file, "(declare-fun %s_32 () (_ BitVec 32))\n", lhs_str);
+				fprintf(file, "(declare-fun %s_64 () (_ BitVec 64))\n", lhs_str);				
+			}
+			*ret_val = *ret_val & name_ok;
+		}
+		else
+		{
+		// LHS is already INLIST, we have to do the following things:
+		// 1. update the SSAID of LHS
+		// 2. get the name of LHS
+		// 3. Declare of LHS_32/64			
+			INTFNS_TREE_NODE_SSAID(lhs) ++;
+			unsigned int name_ok = get_tree_node_name(lhs, lhs_str);
+			if(name_ok)
+			{
+				// test
+				//fprintf(file, ">>>>> lhs: %s\n", lhs_str);
+				
+				fprintf(file, "(declare-fun %s_32 () (_ BitVec 32))\n", lhs_str);
+				fprintf(file, "(declare-fun %s_64 () (_ BitVec 64))\n", lhs_str);
+			}
+			*ret_val = *ret_val & name_ok;
+		}
+	}
+
+	// 2. dump each operation into z3 format
+	// if any error happens in previous process, we just return
+	if(*ret_val == 0)
+	{
+		fprintf(file, "\n");
+		return lhs;
+	}
+	
+	// the TYPE of STMT is considered, including binary, unary, assign, phi-node, cond
+	// in Z3 format, the basic operations are as follows:
+	// 1. bitwise: bvand, bvor, bvxor, bvnot, bvnand, bvnor, bvxnor, bvneg
+	// 2. arith: bvadd, bvmul, bvudiv, bvurem, bvsub, bvsdiv, bvsrem, bvsmod, bvshl, bvlshr, bvashr
+	// 3. comp: bvult, bvule, bvugt, bvuge, bvslt, bvsle, bvsgt, bvsge
+	// 4. bit-propagation: concat, extract, bvshl, bvlshr, repeat, zero-extend, 
+	//		sign-extend, rotate-left, rotate-right
+
+	char expr_str[15];
+	enum tree_code rhs_code;	// used to indicate the EXPR-CODE of rhs
+	bool is_unsign;
+	switch (gimple_code (stmt))
+	{
+	case GIMPLE_ASSIGN:
+		grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));
+		rhs_code = gimple_assign_rhs_code(stmt);
+		
+		/* binary operation, c = a op b; */
+		if (grhs_class == GIMPLE_BINARY_RHS)
+		{	// print: (assert (= lhs-str (exp-code rhs1-str rhs2-str)))
+			// to indicate the signedness of this binary operation
+			is_unsign = TYPE_UNSIGNED(TREE_TYPE(rhs1))
+				&& TYPE_UNSIGNED(TREE_TYPE(rhs2));
+			
+			// 1. at first, we dump the 32-version
+			// 1.1 dump the LHS
+			fprintf(file, "(assert (= %s_32 ( ", lhs_str);
+
+			// 1.2 dump the Operation code
+			if(rhs_code == PLUS_EXPR)
+				strcpy(expr_str, "bvadd");
+			else if(rhs_code == MINUS_EXPR)
+				strcpy(expr_str, "bvsub");
+			else if(rhs_code == MULT_EXPR)
+				strcpy(expr_str, "bvmul");
+			else if(rhs_code == LSHIFT_EXPR)
+				strcpy(expr_str, "bvshl");
+			else if(rhs_code == RSHIFT_EXPR)	// bvlshr or bvashr
+				strcpy(expr_str, "bvlshr");
+			else if(rhs_code == BIT_IOR_EXPR)	// OR
+				strcpy(expr_str, "bvor");
+			else if(rhs_code == BIT_AND_EXPR)	
+				strcpy(expr_str, "bvand");
+			else if(rhs_code == BIT_XOR_EXPR)
+				strcpy(expr_str, "bvxor");
+			else if(rhs_code == LROTATE_EXPR)	// rotate
+				strcpy(expr_str, "rotate_left");
+			else if(rhs_code == RROTATE_EXPR)
+				strcpy(expr_str, "rotate_right");
+			else if((rhs_code == TRUNC_MOD_EXPR) || (rhs_code == FLOOR_MOD_EXPR)
+				|| (rhs_code == CEIL_MOD_EXPR) || (rhs_code == ROUND_MOD_EXPR))
+				strcpy(expr_str, "bvsmod");
+			else if((rhs_code == TRUNC_DIV_EXPR) || (rhs_code == FLOOR_DIV_EXPR)
+				|| (rhs_code == CEIL_DIV_EXPR) || (rhs_code == ROUND_DIV_EXPR)
+				|| (rhs_code == EXACT_DIV_EXPR))
+			{
+				if(is_unsign)
+					strcpy(expr_str, "bvudiv");
+				else
+					strcpy(expr_str, "bvsdiv");
+			}
+			else if(rhs_code == MIN_EXPR)
+			{
+				if(is_unsign)
+					strcpy(expr_str, "ite ( bvult");	// after ITE (
+				else
+					strcpy(expr_str, "ite ( bvslt");
+			}
+			else if(rhs_code == MAX_EXPR)
+			{
+				if(is_unsign)
+					strcpy(expr_str, "ite ( bvugt");	// after ITE(
+				else
+					strcpy(expr_str, "ite ( bvsgt");
+			}			
+			else
+			{
+				strcpy(expr_str, "bvadd"); 	// default expr	
+	// test
+	FILE* file_error = fopen("/tmp/log_intfns_dump_z3_error.txt", "a");
+	print_gimple_stmt (file_error, stmt, 0, TDF_LINENO);
+	fclose(file_error);
+			}			
+			
+			fprintf(file, "%s ", expr_str);
+
+			// note that, for MIN-EXPR and MAX-EXPR, we have to dump many more THINGS
+			// MIN-EXPR: (assert (= lhs_str (ite (bvult/bvslt rhs1-str rhs2-str) rhs1-str rhs2-str)))
+			// MAX-EXPR: (assert (= lhs_str (ite (bvugt/bvsgt rhs1-str rhs2-str) rhs1-str rhs2-str)))
+			// dump: "rhs1-str rhs2-str ) "
+			if((rhs_code == MIN_EXPR) || (rhs_code == MAX_EXPR))
+			{				
+				if(rhs1_is_const)
+					fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_32 ", rhs1_str);
+				
+				if(rhs2_is_const)
+					fprintf(file, "\#x%0*X ", sizeof(rhs2_const) * 2, rhs2_const);
+				else
+					fprintf(file, "%s_32 ", rhs2_str);
+				
+				fprintf(file, ") ");
+			}				
+			
+			// 1.3 dump the RHS1 and RHS2
+			if(rhs1_is_const)
+				fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+			else
+				fprintf(file, "%s_32 ", rhs1_str);
+			
+			if(rhs2_is_const)
+				fprintf(file, "\#x%0*X ", sizeof(rhs2_const) * 2, rhs2_const);
+			else
+				fprintf(file, "%s_32 ", rhs2_str);
+			
+			fprintf(file, ")))\n");
+
+			// 2. then, we dump the 64-version			
+			fprintf(file, "(assert (= %s_64 ( %s ", lhs_str, expr_str);
+
+			// note that, we have also to dump "rhs1-str rhs2-str )"
+			if((rhs_code == MIN_EXPR) || (rhs_code == MAX_EXPR))
+			{
+				if(rhs1_is_const)
+					fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_64 ", rhs1_str);
+				
+				if(rhs2_is_const)
+					fprintf(file, "\#x00000000%0*X ", sizeof(rhs2_const) * 2, rhs2_const);
+				else
+					fprintf(file, "%s_64 ", rhs2_str);
+				
+				fprintf(file, ") ");
+			}		
+			
+			if(rhs1_is_const)
+				fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+			else
+				fprintf(file, "%s_64 ", rhs1_str);
+			
+			if(rhs2_is_const)
+				fprintf(file, "\#x00000000%0*X ", sizeof(rhs2_const) * 2, rhs2_const);
+			else
+				fprintf(file, "%s_64 ", rhs2_str);
+			
+			fprintf(file, ")))\n");
+		}
+		/* UNARY op */
+		else if(grhs_class == GIMPLE_UNARY_RHS)
+		{	// print: (assert (= lhs (expr-code rhs1)))
+			// fixme: here, we only consider NEGATE-EXPR and BIT-NOT-EXPR
+			// for others, we do not consider currently.
+
+			if((rhs_code == NEGATE_EXPR) ||(rhs_code == BIT_NOT_EXPR))
+			{
+				if(rhs_code == NEGATE_EXPR)
+					strcpy(expr_str, "bvneg");
+				else	// BIT-NOT-EXPR
+					strcpy(expr_str, "bvnot");
+				
+				fprintf(file, "(assert (= %s_32 ( %s ", lhs_str, expr_str);
+
+				if(rhs1_is_const)
+					fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_32 ", rhs1_str);
+				fprintf(file, ")))\n");
+				
+				// dump the 64-version
+				fprintf(file, "(assert (= %s_64 ( %s ", lhs_str, expr_str);
+				if(rhs1_is_const)
+					fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_64 ", rhs1_str);
+				fprintf(file, ")))\n");
+			}
+			else if((rhs_code == NOP_EXPR) ||(rhs_code == CONVERT_EXPR)
+				//convert or cast, print: (assert (= lhs rhs1))
+				|| (rhs_code == ABS_EXPR))
+ 				// abs-expr, also print: (assert (= lhs rhs1))
+			{	
+				fprintf(file, "(assert (= %s_32 ", lhs_str);
+				if(rhs1_is_const)
+					fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_32 ", rhs1_str);
+				fprintf(file, "))\n");
+				
+				fprintf(file, "(assert (= %s_64 ", lhs_str);
+				if(rhs1_is_const)
+					fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_64 ", rhs1_str);
+				fprintf(file, "))\n");
+			}
+			else	// default expr, print: (assert (= lhs rhs1))
+			{	
+	// test
+	FILE* file_error = fopen("/tmp/log_intfns_dump_z3_error.txt", "a");
+	//fprintf(file, "rhs is not of integer type\n");
+	print_gimple_stmt (file_error, stmt, 0, TDF_LINENO);
+	fclose(file_error);	
+	
+				fprintf(file, "(assert (= %s_32 ", lhs_str);
+				if(rhs1_is_const)
+					fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_32 ", rhs1_str);
+				fprintf(file, "))\n");
+				
+				fprintf(file, "(assert (= %s_64 ", lhs_str);
+				if(rhs1_is_const)
+					fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+				else
+					fprintf(file, "%s_64 ", rhs1_str);
+				fprintf(file, "))\n");
+			}			
+		}
+		//GIMPLE_SINGLE_RHS or GIMPLE_INVALID_RHS
+		else
+		{
+			// print: (assert (= lhs-str  rhs1-str ))
+			fprintf(file, "(assert (= %s_32 ", lhs_str);
+			if(rhs1_is_const)
+				fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+			else
+				fprintf(file, "%s_32 ", rhs1_str);
+			fprintf(file, "))\n");
+			
+			fprintf(file, "(assert (= %s_64 ", lhs_str);
+			if(rhs1_is_const)
+				fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+			else
+				fprintf(file, "%s_64 ", rhs1_str);
+			fprintf(file, "))\n");
+		}
+		break;
+	case GIMPLE_COND:
+		// 1. LHS is null under this case, we will define our own
+		fprintf(file, "(declare-fun haosun_32 () Bool)\n");		
+		fprintf(file, "(declare-fun haosun_64 () Bool)\n");		
+		is_unsign = TYPE_UNSIGNED(TREE_TYPE(rhs1))
+			&& TYPE_UNSIGNED(TREE_TYPE(rhs2));
+		
+		// print: (assert (= haosun (expr-code rhs1 rhs2)))
+		// >, <, >=, <= ( in both signed and unsigned)
+		// ==, != (= or NOT in z3 format)
+		// 2.1 print the lhs
+		fprintf(file, "(assert (= haosun_32 ( ");
+		rhs_code = gimple_cond_code(stmt);
+
+		// 2.2 get the expr-code
+		if(rhs_code == LT_EXPR)
+		{
+			if(is_unsign)
+				strcpy(expr_str, "bvult");
+			else
+				strcpy(expr_str, "bvslt");
+		}
+		else if(rhs_code == GT_EXPR)
+		{
+			if(is_unsign)
+				strcpy(expr_str, "bvugt");
+			else
+				strcpy(expr_str, "bvsgt");
+		}
+		else if(rhs_code == LE_EXPR)
+		{
+			if(is_unsign)
+				strcpy(expr_str, "bvule");
+			else
+				strcpy(expr_str, "bvsle");
+		}
+		else if(rhs_code == GE_EXPR)
+		{
+			if(is_unsign)
+				strcpy(expr_str, "bvuge");
+			else
+				strcpy(expr_str, "bvsge");
+		}
+		else if(rhs_code == EQ_EXPR)
+			strcpy(expr_str, "=");
+		else if(rhs_code == NE_EXPR)
+			strcpy(expr_str, "not (=");
+		else
+		{	
+			strcpy(expr_str, "=");	// default expr	
+	// test
+	FILE* file_error = fopen("/tmp/log_intfns_dump_z3_error.txt", "a");
+	//fprintf(file, "rhs is not of integer type\n");
+	print_gimple_stmt (file_error, stmt, 0, TDF_LINENO);
+	fclose(file_error);	
+		}
+
+		fprintf(file, "%s ", expr_str);
+		
+		// 2.3 dump the RHS1 and RHS2
+		if(rhs1_is_const)
+			fprintf(file, "\#x%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+		else
+			fprintf(file, "%s_32 ", rhs1_str);
+		
+		if(rhs2_is_const)
+			fprintf(file, "\#x%0*X ", sizeof(rhs2_const) * 2, rhs2_const);
+		else
+			fprintf(file, "%s_32 ", rhs2_str);
+
+		if(rhs_code == NE_EXPR)
+			fprintf(file, "))))\n");
+		else		
+			fprintf(file, ")))\n");
+
+		// 3. we dump the 64-version
+		fprintf(file, "(assert (= haosun_64 ( %s ", expr_str);
+		if(rhs1_is_const)
+			fprintf(file, "\#x00000000%0*X ", sizeof(rhs1_const) * 2, rhs1_const);
+		else
+			fprintf(file, "%s_64 ", rhs1_str);
+		
+		if(rhs2_is_const)
+			fprintf(file, "\#x00000000%0*X ", sizeof(rhs2_const) * 2, rhs2_const);
+		else
+			fprintf(file, "%s_64 ", rhs2_str);
+		
+		if(rhs_code == NE_EXPR)
+			fprintf(file, "))))\n");
+		else
+			fprintf(file, ")))\n");
+		
+		break;
+	case GIMPLE_PHI:
+		// print: (assert (= lhs-str  rhs1-str ))
+		fprintf(file, "(assert (= %s_32 %s_32 ))\n", lhs_str, rhs1_str);
+		fprintf(file, "(assert (= %s_64 %s_64 ))\n", lhs_str, rhs1_str);
+		break;
+	default:
+		*ret_val = 0;
+		break;
+	}
+	
+	// 3. at last, return prev-def-node
+	fprintf(file, "\n");
+	return lhs;
+}
+
+// encode one full path into z3 format
+void dump_z3_for_path(struct function * func, unsigned int path_counter, unsigned int path_type,
+ VEC(intfns_path_node, gc)* new_path_nodes)
+{
+	// 0. get the first STMT in new-path-nodes, we wanna to get the FILENAME of STMT
+	intfns_path_node path_node;
+	gimple stmt;
+	char filename_of_stmt[255];
+	path_node = VEC_index(intfns_path_node, new_path_nodes, 0);
+	stmt = path_node->stmt;
+	if(stmt != NULL)
+		strcpy(filename_of_stmt, gimple_filename(stmt));
+	else
+		strcpy(filename_of_stmt, "NULL");
+	
+	// 1. convert path-counter into 'string'
+	char path_counter_str[4];
+	path_counter_str[0] = '0' + (path_counter / 100);
+	path_counter_str[1] = '0' + ((path_counter / 10) % 10);
+	path_counter_str[2] = '0' + (path_counter % 10);
+	path_counter_str[3] = '\0';
+	
+	// 2. if this path is <to void>, then we just print the result of this path, and return
+	// the format is file-name + func-name + path-counter /newline/ 3
+	if((path_type == 0) || (path_type == PATH_TO_INTOP)
+		|| (path_type > PATH_TO_UNKWN))	// VERY IMPORTANT here.
+	{
+		FILE * file_z3_result = fopen("/tmp/z3_to_void_result.txt", "a");
+		fprintf(file_z3_result, "%s+%s%s\n",
+			filename_of_stmt,lang_hooks.decl_printable_name(func->decl, 2), 
+			path_counter_str);
+		fclose(file_z3_result);
+		return 1;
+	}
+
+	// 3. creat the corresonding Z3 filename: /tmp/z3paths/ + file-name + func-name + path-counter
+	char filename_of_z3[600];
+	char * prefix = "/tmp/z3paths/";
+	strcpy(filename_of_z3, prefix);
+
+	// FIXME: if FILENAME is too long (bigger than 50), we choose not to print FILENAME
+/*	if(strlen(filename_of_stmt) > 50)
+		;
+	else
+	{
+		strcat(filename_of_z3, filename_of_stmt);
+		strcat(filename_of_z3, "+");
+	}  	*/
+	
+	strcat(filename_of_z3, lang_hooks.decl_printable_name(func->decl, 2));
+	strcat(filename_of_z3, path_counter_str);
+	
+	FILE * file = fopen(filename_of_z3, "a");
+	if(file == NULL)
+	{
+		return;
+	}
+	fprintf(file, ";for Func %s(), path-%d, path-type-%d\n",
+		lang_hooks.decl_printable_name(func->decl, 2), path_counter, path_type);
+	
+	// 4. convert each path-node into z3 format	
+	unsigned int analysis_num;
+	// analysis-num stores the number of path-nodes we will anlayze
+	// for ARRAYREF, ARRAYREF-LHS, POINTER-PLUS, RET, CAST-TO-unINT, EQUAL-inEQUAL
+	// and ARRAY-LHS-UNEXTEND, analysis-num is length(new-path-nodes) -1
+	// for ARRAYREF-OFFSET, analysis-num is length(new-path-nodes) -2
+	// for COND, analysis-num is length(new-path-nodes)
+	if(path_type == PATH_TO_COND)
+		analysis_num = VEC_length(intfns_path_node,new_path_nodes);
+	else if(path_type == PATH_TO_ARRAYREF_OFFSET)
+		analysis_num = VEC_length(intfns_path_node,new_path_nodes) - 2;
+	else
+		analysis_num = VEC_length(intfns_path_node,new_path_nodes) - 1;
+	
+	// Then, we convert the first analysis-num path nodes in NEW-PATH-NODES into Z3 format
+	unsigned int ix;
+	tree prev_def_node = NULL;
+	tree lhs_cur = NULL;
+	unsigned int no_error_flag = 1;
+	unsigned int ret_val = 1;
+	
+	// a container, used to store all the TREE NODEs, whose FLAGS might be modified in IntEquiv
+	VEC(tree, gc)* tree_node_list = VEC_alloc(tree, gc, 10);
+	
+	for(ix = 0; ix < analysis_num; ix ++)
+	{
+		path_node = VEC_index(intfns_path_node, new_path_nodes, ix);
+		stmt = path_node->stmt;
+		if(stmt != NULL)
+		{
+			lhs_cur = dump_z3_for_stmt(file, stmt, prev_def_node, (&tree_node_list), &ret_val);
+			prev_def_node = lhs_cur;
+			no_error_flag = no_error_flag & ret_val;
+		}
+	}
+	
+	// 5. at last, the security policy
+	// for PATH-TO-COND, we check whether (assert (not (= haosun_32 haosun_64)))
+	// for PATH-TO-EQUAL-INEQUAL, we check whehter (assert (not ( = lhs_32 (extract 31 0 lhs_64))))
+	// for others, we check whether (assert (not ( = lhs_64 (concat #x00000000 lhs_32))))
+	if(path_type == PATH_TO_COND)
+	{
+		fprintf(file, ";check policy\n");
+		fprintf(file, "(assert (not (= haosun_32 haosun_64)))\n");
+	}
+	else if((path_type == PATH_TO_EQUAL_INEQAUL)
+		|| (path_type == PATH_TO_ARRAY_LHS_UNEXTEND))
+	{
+		char prev_def_node_str[255];
+		unsigned int name_ok = get_tree_node_name(prev_def_node, prev_def_node_str);
+		if(name_ok)
+		{
+			fprintf(file, ";check policy\n");
+			fprintf(file, "(declare-fun haosun_64 () (_ BitVec 64))\n");
+			fprintf(file, "(assert (= haosun_64 (bvand \#x00000000ffffffff %s_64)))\n",
+				prev_def_node_str);
+			fprintf(file, "(assert (not (= haosun_64 (concat \#x00000000 %s_32))))\n",
+				prev_def_node_str);
+		}
+		else
+			no_error_flag = 0;
+	}
+	else
+	{
+		char prev_def_node_str[255];
+		unsigned int name_ok = get_tree_node_name(prev_def_node, prev_def_node_str);
+		if(name_ok)
+		{
+			fprintf(file, ";check policy\n");
+			fprintf(file, "(assert (not (= %s_64 (concat \#x00000000 %s_32))))\n",
+				prev_def_node_str, prev_def_node_str);
+		}
+		else
+			no_error_flag = 0;
+	}
+	
+	// print the check-sat in the end
+	// we will not print check-sat if there exists any error in z3 transformation
+	if(no_error_flag)
+		fprintf(file, "(check-sat)\n");
+	else
+		fprintf(file, "(echo \"sat\")\n");
+
+	tree tree_node;	
+	// clean all the inlist-ssaid-isleft tag for all tree nodes in our list
+	for(ix = 0; VEC_iterate(tree, tree_node_list, ix, tree_node); ix++)
+	{
+		INTFNS_TREE_NODE_INLIST(tree_node) = 0;
+		INTFNS_TREE_NODE_SSAID(tree_node) = 0;
+		INTFNS_TREE_NODE_ISLEFT(tree_node) = 0;
+	}
+		
+	VEC_free(tree, gc, tree_node_list);
+	fclose(file);
+	return;
+}
+
+// dump the PATH starting from STMT, with TAB-NUM tabs in the line
+void dump_path_starting_with_stmt(FILE * file, gimple stmt, 
+ 	VEC(intfns_path, gc)* path_pool, VEC(intfns_path, gc) ** dump_stack_addr, int * path_counter,
+ 	struct function * func, struct intfns_statistics ** stat_ptr)
+{
+	int ix, iy, iz;
+	intfns_path path, print_path;
+	intfns_path_node path_node, print_path_node;
+	gimple stmt_start, stmt_last;
+	
+	// locate the path, which starts from STMT
+	for(ix = 0; VEC_iterate(intfns_path, path_pool, ix, path); ix++)
+	{
+		if((path != NULL) && (path->node_list != NULL))
+		{
+			path_node = VEC_index(intfns_path_node, (path->node_list), 0);
+			stmt_start = path_node->stmt;
+			
+			// if match
+			if(stmt_start == stmt)
+			{
+				if(path->in_stack)
+					continue;
+				else if(path->type == PATH_TO_INTOP)
+				{	// recursive call
+					// PUSH into STACK
+					VEC_safe_push(intfns_path, gc, (*dump_stack_addr), path);
+					path->in_stack = 1;
+					
+					// the last node of this path, if it is an intop and IN-POOL, we dump the next path
+					path_node = VEC_last(intfns_path_node, (path->node_list));
+					stmt_last = path_node->stmt;
+					if((stmt_last != NULL)
+						&& (gimple_code(stmt_last) == GIMPLE_ASSIGN)
+						&& (INTFNS_STMT_TYPE(stmt_last) >= INTFNS_STMT_UADD)
+						&& (INTFNS_STMT_TYPE(stmt_last) <= INTFNS_STMT_SSHL)
+						&& (INTFNS_INTOP_POOL_STATUS(stmt_last) == IN_POOL))
+						dump_path_starting_with_stmt(file, stmt_last, path_pool, 
+							dump_stack_addr, path_counter, func, stat_ptr);
+
+					// POP out from the STACK
+					VEC_pop(intfns_path, (*dump_stack_addr));
+					path->in_stack = 0;
+				}
+				else	// print the stack directly
+				{	
+					// Here, all basic paths stored in our STACK can be chained together to construct one full path.
+					// We traversal all basic paths and store all path-node into our new PATH.
+					// At last, we print detailed info about this PATH into files: each path-node, PATH-id, IntOp,
+					// the z3 constraint.
+					unsigned int path_id = *path_counter;
+					unsigned int path_type;
+					VEC(intfns_path_node, gc)* new_path_nodes = VEC_alloc(intfns_path_node, gc, 10);
+					VEC(intfns_path_node, gc)* intop_nodes = VEC_alloc(intfns_path_node, gc, 4);
+					unsigned int path_has_ovf_intop = 0;	// to indicate there is a PATH in DUMP-STACK, which has ovf-int
+
+					
+					//fprintf(file, "PATH-%d:\t", (*path_counter));
+					for(iy = 0; VEC_iterate(intfns_path, (*dump_stack_addr), iy, print_path); iy++)
+					{
+						if((print_path != NULL) && (print_path->node_list != NULL))
+						{
+							//fprintf(file, "path %d -> ", print_path->index_in_pool);
+							if(print_path->has_ovf_intop)
+								path_has_ovf_intop = 1;
+
+							// add the first INTOP of the first BASIC PATH into new-path-nodes
+							if(iy == 0)
+							{
+								VEC_safe_push(intfns_path_node, gc, new_path_nodes, 
+									VEC_index(intfns_path_node, (print_path->node_list), 0));
+							}
+
+							// add the first INTOP of each BASIC PATH into intop-nodes
+							VEC_safe_push(intfns_path_node, gc, intop_nodes, 
+									VEC_index(intfns_path_node, (print_path->node_list), 0));
+
+							// add the 2nd to last nodes of each BASIC PATH into new-path-nodes
+							for(iz = 1; VEC_iterate(intfns_path_node, (print_path->node_list), iz, print_path_node); iz++)
+							{
+								VEC_safe_push(intfns_path_node, gc, new_path_nodes, print_path_node);
+							}
+						}
+					}
+					// for the last BASIC PATH, add the first INTOP into intop-nodes
+					// and add the 2nd to last nodes into new-path-nodes
+					//fprintf(file, "path %d\n", path->index_in_pool);
+					VEC_safe_push(intfns_path_node, gc, intop_nodes, 
+						VEC_index(intfns_path_node, (path->node_list), 0));
+					for(iz = 1; VEC_iterate(intfns_path_node, (path->node_list), iz, print_path_node); iz++)
+					{
+						VEC_safe_push(intfns_path_node, gc, new_path_nodes, print_path_node);
+					}
+					
+					if(path->has_ovf_intop)
+						path_has_ovf_intop = 1;					
+					path_type = path->type;
+
+					// if this ful path has an OVF intop inside, we dump it.
+					// In IntEQ, we should check this path has OVF intop.
+					if(path_has_ovf_intop)
+					{
+					// at first we have to update the path, path-node and precision info.
+					(*stat_ptr)->path ++;
+					unsigned int path_node_num = 0;
+					unsigned int path_intop_node_num = 0;
+					unsigned int precs = 32;
+
+					// get path-node-num
+					path_node_num = VEC_length(intfns_path_node, new_path_nodes);
+					(*stat_ptr)->path_node_num += path_node_num;
+					if((*stat_ptr)->path_node_min > path_node_num)
+						(*stat_ptr)->path_node_min = path_node_num;
+					if((*stat_ptr)->path_node_max < path_node_num)
+						(*stat_ptr)->path_node_max = path_node_num;
+					
+					// get path-intop-node-num
+					path_intop_node_num = VEC_length(intfns_path_node, intop_nodes);
+					(*stat_ptr)->path_intop_node_num += path_intop_node_num;
+					if((*stat_ptr)->path_intop_node_min > path_intop_node_num)
+						(*stat_ptr)->path_intop_node_min = path_intop_node_num;
+					if((*stat_ptr)->path_intop_node_max < path_intop_node_num)
+						(*stat_ptr)->path_intop_node_max = path_intop_node_num;
+
+					// get 'precs'
+					gimple stmt_intop;
+					int ii;
+					for(ii = 0; VEC_iterate(intfns_path_node, intop_nodes, ii, print_path_node); ii++)
+					{
+						stmt_intop = print_path_node->stmt;
+						if((stmt_intop != NULL)
+							&& (gimple_code(stmt_intop) == GIMPLE_ASSIGN))
+						{
+							// ADD or SUB
+							if((INTFNS_STMT_TYPE(stmt_intop) >= INTFNS_STMT_UADD)
+								&& (INTFNS_STMT_TYPE(stmt_intop) <= INTFNS_STMT_SSUB))
+								precs ++;
+							else if((INTFNS_STMT_TYPE(stmt_intop) >= INTFNS_STMT_UMUL)
+								&& (INTFNS_STMT_TYPE(stmt_intop) <= INTFNS_STMT_SSHL))
+								precs += 32;
+						}
+					}
+					if((*stat_ptr)->precs_min > precs)
+						(*stat_ptr)->precs_min = precs;
+					if((*stat_ptr)->precs_max < precs)
+						(*stat_ptr)->precs_max = precs;
+					
+					fprintf(file, "PATH-%d:\t\n", (*path_counter));
+					
+					// dump work
+					dump_full_path(func, path_id, path_type, new_path_nodes);
+					dump_all_intop_for_path(func, path_id, intop_nodes);
+					dump_z3_for_path(func, path_id, path_type, new_path_nodes);
+					
+					VEC_free(intfns_path_node, gc, new_path_nodes);
+					VEC_free(intfns_path_node, gc, intop_nodes);
+					
+					*path_counter = (*path_counter) + 1;
+					if((*path_counter) > PATH_MAX)
+						return;
+					}
+				}
+			}
+		}
+	}
+}
+
+//================================================================
+
+/* to check whether two ssa-name are derived from the same origin. */
+bool intfns_check_ssa_origin(tree t1, tree t2)
+{
+	// t1 = t2
+	if(t1 == t2)
+		return true;
+
+	// their var are the same.
+	if(SSA_NAME_VAR(t1) == SSA_NAME_VAR(t2))
+		return true;
+	
+	// check their def-stmt. if the right-val of def-stmt are the same.
+	gimple def1 = SSA_NAME_DEF_STMT(t1);
+	gimple def2 = SSA_NAME_DEF_STMT(t2);
+	if((def1 != NULL)
+		&& (def2 != NULL)
+		&& (gimple_assign_rhs1(def1) == gimple_assign_rhs1(def2)))
+		return true;
+	
+	return false;	
+}
+
+/* to check whether an STMT is like: unsigned XX = signed YY */
+bool intfns_check_stmt_is_cast_sign_to_unsign(gimple stmt)
+{
+	// fixme: we can easily check whether stmt is INTFNS-STMT-PROPAGATE
+	// and stmt is INTFNS-STMT-SIGN-TO-UNSIGN
+	if((gimple_code(stmt) == GIMPLE_ASSIGN)
+		&&((gimple_assign_rhs_code(stmt) == CONVERT_EXPR)
+			||(gimple_assign_rhs_code(stmt) == NOP_EXPR)))
+	{
+		tree lhs, rhs;
+		lhs = gimple_assign_lhs (stmt);
+		rhs = gimple_assign_rhs1(stmt);
+		if(TYPE_UNSIGNED(TREE_TYPE(lhs)) 
+			&& (!TYPE_UNSIGNED(TREE_TYPE(rhs))))
+			return true;
+		else
+			return false;
+	}
+	return false;
+}
+
+/* to check whether an STMT is like: signed XX = unsigned YY */
+bool intfns_check_stmt_is_cast_unsign_to_sign(gimple stmt)
+{
+	// fixme: we can easily check whether stmt is INTFNS-STMT-PROPAGATE
+	// and stmt is INTFNS-STMT-UNSIGN-TO-SIGN
+	if((gimple_code(stmt) == GIMPLE_ASSIGN)
+		&&((gimple_assign_rhs_code(stmt) == CONVERT_EXPR)
+			||(gimple_assign_rhs_code(stmt) == NOP_EXPR)))
+	{
+		tree lhs, rhs;
+		lhs = gimple_assign_lhs (stmt);
+		rhs = gimple_assign_rhs1(stmt);
+		if(!TYPE_UNSIGNED(TREE_TYPE(lhs)) 
+			&& (TYPE_UNSIGNED(TREE_TYPE(rhs))))
+			return true;
+		else
+			return false;
+	}
+	return false;
+}
+
+
+/* to further mark each INTOP: : P2, P4 and Implicit Intop
+P2: unused intop
+	c = a op b.
+	if c has no use,
+		we select this stmt as unused op.
+
+P4: santz-postcond
+	S1. c = a +s b;
+		a>0 && b>0 && c<0 or a<0 && b<0 && c>0
+	S2. c= a +u b;
+		c<a or c<b
+	S3. c = a -s b
+		a<0 && b>0 && c>0 or a>0 && b<0 && c<0
+	S4. c = a -u b
+		a<b
+	S5. c = a * b
+		x!=0 && c/a != b
+	S6. c = a << b
+		c >> b != a
+
+	To simplify our implementation, we pay much attention on S2, S4, S5 and S6, 
+		as they are much more common.
+	For S1, S3, their postcondtion test are very complicated.
+		In real world, such complicated check are rarely utilized by programmers.
+		Therefore, we don't identify these cases in current implementation.
+		However, this can be easily extended.
+
+	Besides, we wanna handle 'while(i--)' particularly, as such statement is widely used.
+	the corresponding ssa form is shown as below:
+		i2 = phi(i, i3);
+		temp = i2 != 0;
+		i3 = i2 - 1;
+		if(temp)
+			goto BB1;
+		else
+			goto BB2;
+	In intchecker, we try to identify 'while(i--)' using:
+		check an USUB intop, if RHS2 is 1.
+		if so,
+			check whether i2 and i3 is co-depend;
+		if so, check another use of i2
+			if this use is i2!=0 or i2 > 0
+				then we set this USUB as SANTZ-POST
+
+Implicit intop:
+	Implicit Castings might have been deployed when generating GIMPLE form.
+	Many false positives would be produced if we still use the normal Pre-condtion or 
+	Post-condtion test to catch integer overflow.
+	Therefore, in IntChecker, we at first identify these implicit castings and then insert
+	particular test code to catch integer overflow. In this way, false positives would be reduced.
+
+	Here, we summarize the following common implicit castings:
+	I1: Cu = As + Bu; -->>
+		Du = As;
+		Cu = Du + Bu;
+				
+	I2: Cs = As + Bu; -->>
+		Du = As;
+		Eu = Du + Bu;
+		Cs = Eu;
+
+	I3: Cs = As - Bu; -->>
+		Du = As;
+		Eu = Du - Bu;
+		Cs = Eu;
+
+	I4: Cu = As - Bu; -->>
+		Du = As;
+		Cu = Du - Bu;
+
+	I5: Cs = Au - Bs; -->>
+		Du = Bs;
+		Eu = Au - Du;
+		Cs = Eu;
+
+	I6: Cu = Au - Bs; -->>
+		Du = Bs;
+		Cu = Au - Du;
+
+	I7: Cu = Au * Bs; -->>
+		Du = Bs;
+		Cu = Au * Du;
+
+	I8: Cs = Au * Bs; -->>
+		Du = Bs;
+		Eu = Au * Du;
+		Cs = Eu;
+
+	I9: Cs = Au - Bu; -->>
+		Du = Au - Bu;
+		Cs = Du;
+		this case is a special case.
+		IF Au-Bu undeflows, it is still ok.
+		IF A > B and Du > 0x7fff,ffff, it is a signedness error.
+
+****************************************
+For sign cast, 
+P2 is the same with the situation of intop
+
+P4 is like:
+SC1. sign = unsign;
+	we have to check whether there is the comparison between 'sign' and 0
+SC2. unsign = sign;
+	we have to check whether there is the cpmparision between 'unsign' and '0x7fff,ffff'
+
+and implicit castings for sign cast can be adopted in the situation of intop. :)
+
+Besides, as for sign cast, we have also to check whether this sign cast is USELESS or not.
+UL1:
+	b = (int) a;
+	c = (uint) b;
+   or
+   	b = (unint) a;
+   	c = (int) b;
+UL2:
+	b1 = (int) a1;	b2 = (int) a2;
+	c1 = b1 op b2;
+	c = (uint) c1;
+   or
+   	b1 = (uint) a1; b2 = (uint) a2;
+	c1 = b1 op b2;
+	c = (int) c1;
+*/
+void intfns_mark_stmt_further(gimple stmt, struct function * func)
+{
+	/* refer to tree-flow.h, gimple.h and tree-flow-inline.h */	
+	tree lhs = gimple_assign_lhs (stmt);
+	tree rhs1, rhs2;
+
+	if((INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+		&& (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL))
+	{	
+		rhs1 = gimple_assign_rhs1(stmt);
+		rhs2 = gimple_assign_rhs2(stmt);
+	}
+
+	if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+		rhs1 = gimple_assign_rhs1(stmt);
+	
+	gimple use;
+	tree use_rhs1, use_rhs2;
+	imm_use_iterator iter;
+	use_operand_p use_p;
+
+	/*1. P2-----------------------------------------*/
+	/* c = a arith-op b; or c = (cast) a;
+	if c has no imm-use*/
+	if((INTFNS_STMT_LEFT_IS_SSA(stmt))
+		&&(has_zero_uses(lhs)))
+	{
+		INTFNS_STMT_EXCLUDE(stmt) = 1;
+		INTFNS_STMT_EXCLUDE_UNUSE(stmt) = 1;
+	}
+	
+	/*2. P4-----------------------------------------*/
+	if((INTFNS_STMT_LEFT_IS_SSA(stmt)
+		&& (num_imm_uses(lhs) > 0)))
+	{
+	
+	// S2: c= a +u b;
+	if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UADD)
+	{
+		// traversal each use of lhs
+		FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+		if((gimple_code(use)== GIMPLE_ASSIGN)
+			&& ((gimple_assign_rhs_code(use) == LT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GE_EXPR)))
+		{
+			use_rhs1 = gimple_assign_rhs1(use);
+			use_rhs2 = gimple_assign_rhs2(use);
+			
+			// for c = a +u b, we should check whether the 'use' is c<a or c<b
+			if((use_rhs1 == lhs)
+				&& ((intfns_check_ssa_origin(use_rhs2, rhs1))
+				|| (intfns_check_ssa_origin(use_rhs2, rhs2))))
+			{
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)		// break this loop
+			}
+		}
+		else if((gimple_code(use) == GIMPLE_COND)
+			&& ((gimple_cond_code(use) == LT_EXPR)
+				|| (gimple_cond_code(use) == GT_EXPR)
+				|| (gimple_cond_code(use) == GE_EXPR)))
+		{
+			use_rhs1 = gimple_cond_lhs(use);
+			use_rhs2 = gimple_cond_rhs(use);
+			
+			// for c = a +u b, we should check whether the 'use' is c<a or c<b
+			if((use_rhs1 == lhs)
+				&& ((intfns_check_ssa_origin(use_rhs2, rhs1))
+				|| (intfns_check_ssa_origin(use_rhs2, rhs2))))
+			{
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+	}
+
+	// S4: c = a -u b
+	if(INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_USUB)
+	{
+		// check whether there are a < b in this program, via the use-chain of 'a'
+		if(TREE_CODE(rhs1) == SSA_NAME)
+		{
+		
+		FOR_EACH_IMM_USE_STMT(use, iter, rhs1)
+		if((gimple_code(use)== GIMPLE_ASSIGN)
+			&& (gimple_assign_rhs_code(use) == LT_EXPR))
+  		{	// this check-stmt is lt-expr, then we have to check whether it is 'a<b'
+  			use_rhs1 = gimple_assign_rhs1(use);
+			use_rhs2 = gimple_assign_rhs2(use);
+
+			if((intfns_check_ssa_origin(use_rhs1, rhs1))
+				&& (intfns_check_ssa_origin(use_rhs2, rhs2)))
+			{	
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+  		}
+		else if((gimple_code(use) == GIMPLE_COND)
+			&& (gimple_cond_code(use) == LT_EXPR))
+		{
+			use_rhs1 = gimple_cond_lhs(use);
+			use_rhs2 = gimple_cond_rhs(use);
+
+			if((intfns_check_ssa_origin(use_rhs1, rhs1))
+				&& (intfns_check_ssa_origin(use_rhs2, rhs2)))
+			{	
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}					
+		}		
+		}
+
+		/* to handle the special case: while(i--)*/
+		// at first, check whether rhs2 is const-node 1.
+		if((TREE_CODE(rhs2) == INTEGER_CST)
+			&& (TREE_INT_CST_LOW(rhs2) == 1)
+			&& (TREE_CODE(rhs1) == SSA_NAME))
+		{
+			// lhs = rhs1 - 1;
+			/* then locate the def-stmt of rhs1:
+				1.check whehter def-stmt is a phi-node and lhs is one of the arg
+				2.or check whehter def-stmt is SSA=VAR-DECL.*/
+			int found;
+			gimple def_stmt = SSA_NAME_DEF_STMT(rhs1);
+			int iy;
+			tree arg_next;
+			gimple def_stmt_next;
+			if((gimple_code (def_stmt) == GIMPLE_PHI)
+				|| (gimple_code (def_stmt) == GIMPLE_ASSIGN))
+			{
+				tree arg;
+				int ix;
+				found = 0;
+
+				if(gimple_code(def_stmt) == GIMPLE_PHI)
+				for(ix = 0; ix < gimple_phi_num_args(def_stmt); ix ++)
+				{
+					arg = gimple_phi_arg(def_stmt, ix)->def;
+					if(arg == lhs)
+					{
+						found = 1;
+						break;
+					}
+					// fixme: actually we should check recursively recursively....
+					// xxx = phi(lhs, zzz);
+					// rhs1 = phi(xxx, yyy);
+					// lhs = rhs1 -1;
+					else
+					{
+						if(TREE_CODE(arg) == SSA_NAME)
+						{
+							def_stmt_next = SSA_NAME_DEF_STMT(arg);
+							if(gimple_code(def_stmt_next) == GIMPLE_PHI)
+							for(iy = 0; iy < gimple_phi_num_args(def_stmt_next); iy ++)
+							{
+								arg_next = gimple_phi_arg(def_stmt_next, iy)->def;
+								if(arg_next == lhs)
+								{
+									found = 1;
+									break;
+								}
+							}
+						}
+						
+						if(found)
+							break;
+					}
+				}
+				else	// GIMPLE-ASSIGN
+				{
+					if(TREE_CODE(gimple_assign_rhs1(def_stmt)) == VAR_DECL)
+						found = 1;
+				}
+
+				// if found, we further check, 
+				// the other use of rhs1 is rhs1!=0 or rhs1>0
+				// fixme: we may want to further check use-lhs is used at a IF()
+				if(found)
+				FOR_EACH_IMM_USE_STMT(use, iter, rhs1)
+				if(use != stmt)
+				{
+					if((gimple_code(use)== GIMPLE_ASSIGN)
+						&& ((gimple_assign_rhs_code(use) == GT_EXPR)
+							|| (gimple_assign_rhs_code(use) == NE_EXPR)))
+			  		{	// this check-stmt is lt-expr, then we have to check whether it is 'a<b'
+			  			use_rhs1 = gimple_assign_rhs1(use);
+						use_rhs2 = gimple_assign_rhs2(use);
+
+						if((use_rhs1 == rhs1)
+							&& (TREE_CODE(use_rhs2) == INTEGER_CST)
+							&& (TREE_INT_CST_LOW(use_rhs2) == 0))
+						{	
+							INTFNS_STMT_EXCLUDE(stmt) = 1;
+							INTFNS_STMT_EXCLUDE_UNUSE(stmt) = 1;
+							BREAK_FROM_IMM_USE_STMT (iter)
+						}
+			  		}
+					else if((gimple_code(use) == GIMPLE_COND)
+						&& ((gimple_cond_code(use) == GT_EXPR)
+							|| (gimple_cond_code(use) == NE_EXPR)))
+					{
+						use_rhs1 = gimple_cond_lhs(use);
+						use_rhs2 = gimple_cond_rhs(use);
+
+						if((use_rhs1 == rhs1)
+							&& (TREE_CODE(use_rhs2) == INTEGER_CST)
+							&& (TREE_INT_CST_LOW(use_rhs2) == 0))
+						{	
+							INTFNS_STMT_EXCLUDE(stmt) = 1;
+							INTFNS_STMT_EXCLUDE_UNUSE(stmt) = 1;
+							BREAK_FROM_IMM_USE_STMT (iter)
+						}				
+					}
+				}
+			}
+		}
+	}
+
+	// S5: c = a * b
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_UMUL)
+		|| (INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SMUL))
+	{
+		// traversal each use of lhs
+		FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+		if((gimple_code(use)== GIMPLE_ASSIGN)
+			&& (gimple_assign_rhs_code(use) == TRUNC_DIV_EXPR))
+		{	
+			use_rhs1 = gimple_assign_rhs1(use);
+			use_rhs2 = gimple_assign_rhs2(use);
+		
+			// for c = a * b, we should check whether the 'use' is c/a or c/b
+			if((use_rhs1 == lhs)
+				&& (intfns_check_ssa_origin(use_rhs2, rhs1))
+				|| (intfns_check_ssa_origin(use_rhs2, rhs2)))				
+			{
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+	}
+ 
+	//S6: c = a << b */
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_USHL)
+		|| (INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_SSHL))
+	{
+		// traversal each use of lhs
+		if(single_imm_use(lhs, &use_p, &use))
+		//FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+		if((gimple_code(use)== GIMPLE_ASSIGN)
+			&& (gimple_assign_rhs_code(use) == RSHIFT_EXPR))
+		{
+			use_rhs1 = gimple_assign_rhs1(use);
+			use_rhs2 = gimple_assign_rhs2(use);
+			
+			// for c = a << b; we should check whether the 'use' is c >> b		
+			if((use_rhs1 == lhs)
+				&& (intfns_check_ssa_origin(use_rhs2, rhs2)))
+			{
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				//BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+	}
+
+	// SC1: sign c = unsign b;
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+		&& (INTFNS_SIGN_CAST_STATUS(stmt) == INTFNS_STMT_UNSIGN_TO_SIGN))
+	{
+		// traversal each use of lhs
+		FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+		if((gimple_code(use)== GIMPLE_ASSIGN)
+			&& ((gimple_assign_rhs_code(use) == LT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GE_EXPR)))
+		{
+			use_rhs1 = gimple_assign_rhs1(use);
+			use_rhs2 = gimple_assign_rhs2(use);
+			
+			// we should check whether the 'use' is c > 0, c >=0 or c < 0
+			if((use_rhs1 == lhs)
+				&& (TREE_CODE(use_rhs2) == INTEGER_CST)
+				&& (TREE_INT_CST_LOW(use_rhs2) == 0))
+			{
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)		// break this loop
+			}
+		}
+		else if((gimple_code(use) == GIMPLE_COND)
+			&& ((gimple_cond_code(use) == LT_EXPR)
+				|| (gimple_cond_code(use) == GT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GE_EXPR)))
+		{
+			use_rhs1 = gimple_cond_lhs(use);
+			use_rhs2 = gimple_cond_rhs(use);
+			
+			// we should check whether the 'use' is c > 0, c >= 0 or c < 0
+			if((use_rhs1 == lhs)
+				&& (TREE_CODE(use_rhs2) == INTEGER_CST)
+				&& (TREE_INT_CST_LOW(use_rhs2) == 0))
+			{
+				INTFNS_STMT_EXCLUDE(stmt) = 1;
+				INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+	}
+
+	// SC2: unsign c = sign b;
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+		&& (INTFNS_SIGN_CAST_STATUS(stmt) == INTFNS_STMT_SIGN_TO_UNSIGN))
+	{
+		unsigned int width = TREE_INT_CST_LOW(TYPE_SIZE(TREE_TYPE(lhs)));
+		unsigned int found = 0;
+		// traversal each use of lhs
+		FOR_EACH_IMM_USE_STMT(use, iter, lhs)
+		if((gimple_code(use)== GIMPLE_ASSIGN)
+			&& ((gimple_assign_rhs_code(use) == LT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GE_EXPR)))
+		{
+			use_rhs1 = gimple_assign_rhs1(use);
+			use_rhs2 = gimple_assign_rhs2(use);
+			
+			// we should check whether the 'use' is c > 0x7fff,ffff or c < 0x7fff,ffff
+			if((use_rhs1 == lhs)
+				&& (TREE_CODE(use_rhs2) == INTEGER_CST))
+			{
+				if(width == 8)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7f)
+						found = 1;
+
+				if(width == 16)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7fff)
+						found = 1;
+
+				if(width == 32)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7fffffff)
+						found = 1;
+
+				if(width == 64)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7fffffffffffffff)
+						found = 1;
+
+				if(found)
+				{
+					INTFNS_STMT_EXCLUDE(stmt) = 1;
+					INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+					BREAK_FROM_IMM_USE_STMT (iter)		// break this loop
+				}
+			}
+		}
+		else if((gimple_code(use) == GIMPLE_COND)
+			&& ((gimple_cond_code(use) == LT_EXPR)
+				|| (gimple_cond_code(use) == GT_EXPR)
+				|| (gimple_assign_rhs_code(use) == GE_EXPR)))
+		{
+			use_rhs1 = gimple_cond_lhs(use);
+			use_rhs2 = gimple_cond_rhs(use);
+			
+			// we should check whether the 'use' is c > 0x7fff,ffff or c < 0x7fff,ffff
+			if((use_rhs1 == lhs)
+				&& (TREE_CODE(use_rhs2) == INTEGER_CST))
+			{
+				if(width == 8)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7f)
+						found = 1;
+
+				if(width == 16)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7fff)
+						found = 1;
+
+				if(width == 32)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7fffffff)
+						found = 1;
+
+				if(width == 64)
+					if(TREE_INT_CST_LOW(use_rhs2) == 0x7fffffffffffffff)
+						found = 1;
+
+				if(found)
+				{
+					INTFNS_STMT_EXCLUDE(stmt) = 1;
+					INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt) = 1;
+					BREAK_FROM_IMM_USE_STMT (iter)		// break this loop
+				}
+			}
+		}
+	}
+	
+	}
+
+	/* 3.Implicit intop--------------------------------*/
+	/* Uadd, Usub and Umul */
+	unsigned int stmt_type = INTFNS_STMT_TYPE(stmt);
+	unsigned int sign_pos = 0;			// the position of the SIGN operand, left or right
+	unsigned int result_is_sign = 0;	// to indicate that RES is actually SIGN
+	if((stmt_type == INTFNS_STMT_UADD)
+		|| (stmt_type == INTFNS_STMT_USUB)
+		|| (stmt_type == INTFNS_STMT_UMUL))
+	{
+		// at first whether there are: TMPu=OP1s; RESu =TMPu op OP2u;
+		if((TREE_CODE(rhs1) == SSA_NAME)
+			&& (intfns_check_stmt_is_cast_sign_to_unsign(SSA_NAME_DEF_STMT(rhs1))))
+		{	
+			sign_pos = 1;
+			INTFNS_SIGN_CAST_IN_IMPLICIT(SSA_NAME_DEF_STMT(rhs1)) = 1;
+		}
+		else if((TREE_CODE(rhs2) == SSA_NAME)
+			&& (intfns_check_stmt_is_cast_sign_to_unsign(SSA_NAME_DEF_STMT(rhs2))))
+		{
+			sign_pos = 2;
+			INTFNS_SIGN_CAST_IN_IMPLICIT(SSA_NAME_DEF_STMT(rhs2)) = 1;
+		}
+		else if((TREE_CODE(rhs1) == SSA_NAME)
+			|| (TREE_CODE(rhs2) == SSA_NAME))
+			sign_pos = 3;	// sign_pos is 3, indicating that neither rhs1 nor rhs2 is casted from SIGN
+		else
+			;
+		
+		// then, we check whether there are RESs = RESu;
+		if((TREE_CODE(lhs) == SSA_NAME)
+			&&(single_imm_use(lhs, &use_p, &use)))
+			if(intfns_check_stmt_is_cast_unsign_to_sign(use))
+			{	
+				result_is_sign = 1;				
+				INTFNS_SIGN_CAST_IN_IMPLICIT(use) = 1;
+			}
+		
+		// at last, mark the implicit casting type for this INTOP
+		if(stmt_type == INTFNS_STMT_UADD)
+		{
+			if(sign_pos == 1)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_ADD_SSU;
+				else
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_ADD_USU;
+			else if(sign_pos == 2)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_ADD_SUS;
+				else
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_ADD_UUS;
+			else
+				;
+		}
+		else if(stmt_type == INTFNS_STMT_USUB)
+		{
+			if(sign_pos == 1)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_SUB_SSU;
+				else
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_SUB_USU;
+			else if(sign_pos == 2)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_SUB_SUS;
+				else
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_SUB_UUS;
+			else if(sign_pos == 3)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_SUB_SUU;
+				else
+					;
+			else
+				;
+		}
+		else
+		{
+			if(sign_pos == 1)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_MUL_SSU;
+				else
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_MUL_USU;
+			else if(sign_pos == 2)
+				if(result_is_sign == 1)
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_MUL_SUS;
+				else
+					INTFNS_INTOP_IMPLICIT_TYPE(stmt) = INTFNS_INTOP_IMPLICIT_MUL_UUS;
+			else
+				;
+		}
+	}	
+
+	/* 4.USELESS sign cast--------------------------------*/
+	/* UL2: add, sub and mul */
+	if( (INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+		&& (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SMUL))
+	{
+		if((TREE_CODE(rhs1) == SSA_NAME)
+			&& (intfns_check_stmt_is_cast_sign_to_unsign(SSA_NAME_DEF_STMT(rhs1)))
+			&& (TREE_CODE(rhs2) == SSA_NAME)
+			&& (intfns_check_stmt_is_cast_sign_to_unsign(SSA_NAME_DEF_STMT(rhs2)))
+			&& (TREE_CODE(lhs) == SSA_NAME)
+			&& (single_imm_use(lhs, &use_p, &use))
+			&& (intfns_check_stmt_is_cast_unsign_to_sign(use))			
+			)
+		{
+			INTFNS_SIGN_CAST_USELESS(SSA_NAME_DEF_STMT(rhs1)) = 1;
+			INTFNS_SIGN_CAST_USELESS(SSA_NAME_DEF_STMT(rhs2)) = 1;
+			INTFNS_SIGN_CAST_USELESS(use) = 1;
+		}
+
+		if((TREE_CODE(rhs1) == SSA_NAME)
+			&& (intfns_check_stmt_is_cast_unsign_to_sign(SSA_NAME_DEF_STMT(rhs1)))
+			&& (TREE_CODE(rhs2) == SSA_NAME)
+			&& (intfns_check_stmt_is_cast_unsign_to_sign(SSA_NAME_DEF_STMT(rhs2)))
+			&& (TREE_CODE(lhs) == SSA_NAME)
+			&& (single_imm_use(lhs, &use_p, &use))
+			&& (intfns_check_stmt_is_cast_sign_to_unsign(use))			
+			)
+		{
+			INTFNS_SIGN_CAST_USELESS(SSA_NAME_DEF_STMT(rhs1)) = 1;
+			INTFNS_SIGN_CAST_USELESS(SSA_NAME_DEF_STMT(rhs2)) = 1;
+			INTFNS_SIGN_CAST_USELESS(use) = 1;
+		}
+	}
+
+	// UL1: unsign c = sign b;
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+		&& (INTFNS_SIGN_CAST_STATUS(stmt) == INTFNS_STMT_SIGN_TO_UNSIGN))
+	{
+		if((TREE_CODE(lhs) == SSA_NAME)
+			&& (single_imm_use(lhs, &use_p, &use))
+			&& (intfns_check_stmt_is_cast_unsign_to_sign(use)))	
+		{
+			INTFNS_SIGN_CAST_USELESS(stmt) = 1;
+			INTFNS_SIGN_CAST_USELESS(use) = 1;
+		}
+	}
+	// UL1: sign c = unsign b;
+	if((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE)
+		&& (INTFNS_SIGN_CAST_STATUS(stmt) == INTFNS_STMT_UNSIGN_TO_SIGN))
+	{
+		if((TREE_CODE(lhs) == SSA_NAME)
+			&& (single_imm_use(lhs, &use_p, &use))
+			&& (intfns_check_stmt_is_cast_sign_to_unsign(use)))	
+		{
+			INTFNS_SIGN_CAST_USELESS(stmt) = 1;
+			INTFNS_SIGN_CAST_USELESS(use) = 1;
+		}
+	}
+	
+	return;
+}
+
+/* to further mark each INTOP and SignCast for FUNC */
+static unsigned int
+intfns_mark_func_further (struct function * func)
+{
+	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	gimple stmt;
+	
+	FOR_EACH_BB_FN(bb, func)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{		
+		stmt = gsi_stmt(gsi);
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+			// IntEquiv: we only consider intop, not including signcast
+			&& (INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+			&& (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL)
+			)
+			intfns_mark_stmt_further(stmt, func);
+	}
+
+	// FIXME: For IntEquiv, we may also want to dump all while(i--) cases into a file.
+	FILE* file_unuse = fopen("/tmp/log_intfns_intop_unuse.txt", "a");
+	FOR_EACH_BB_FN(bb, func)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+	stmt = gsi_stmt(gsi);
+	if(stmt != NULL)
+	{		
+		if((gimple_code (stmt) == GIMPLE_ASSIGN)
+			&& (INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+			&& (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL)
+			&& (INTFNS_STMT_EXCLUDE_UNUSE(stmt)))
+		{
+			if(INTFNS_STMT_EXCLUDE_UNUSE(stmt))
+				print_gimple_stmt (file_unuse, stmt, 0, TDF_LINENO);
+		}
+	}
+	}
+	fclose(file_unuse);
+	
+	/*-------------------------------------------------*/
+	/* dump all the P2, P4 and implicit castings */
+	FILE* file = fopen("/tmp/log_intfns_further_marked_stmt.txt", "a");
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(func->decl, 2));
+
+	/* travesal each INTOP in func. */	
+	FOR_EACH_BB_FN(bb, func)
+	for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+	{
+	stmt = gsi_stmt(gsi);
+	if(stmt != NULL)
+	{		
+		if((gimple_code (stmt) == GIMPLE_ASSIGN)
+			//&& (INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+			//&& (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL)
+			&& ((INTFNS_STMT_EXCLUDE_UNUSE(stmt))
+				||(INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt))
+				||(INTFNS_INTOP_IMPLICIT_TYPE(stmt) > 0))
+				|| (INTFNS_SIGN_CAST_USELESS(stmt)))
+		{
+			if(INTFNS_STMT_EXCLUDE_UNUSE(stmt))
+				fprintf(file, "\tUNUSEd ");
+			if(INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt))
+				fprintf(file, "\tSANTZ_POST ");
+			if(INTFNS_INTOP_IMPLICIT_TYPE(stmt) > 0)
+				fprintf(file, "\tIMPLICIT ");
+			if(INTFNS_SIGN_CAST_USELESS(stmt))
+				fprintf(file, "\tUSELESS-SIGN-CAST ");
+			
+			switch(INTFNS_STMT_TYPE(stmt))
+			{
+			case INTFNS_STMT_UADD:
+				fprintf(file, "unsigned add at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SADD:
+				fprintf(file, "signed add at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_USUB:
+				fprintf(file, "unsigned sub at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SSUB:
+				fprintf(file, "signed sub at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_UMUL:
+				fprintf(file, "unsigned mul at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SMUL:
+				fprintf(file, "signed mul at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_USHL:
+				fprintf(file, "unsigned shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_SSHL:
+				fprintf(file, "signed shl at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+			case INTFNS_STMT_PROPAGATE:
+				switch(INTFNS_SIGN_CAST_STATUS(stmt))
+				{
+				case INTFNS_STMT_SIGN_TO_UNSIGN:
+					fprintf(file, "sign->unsign at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				case INTFNS_STMT_UNSIGN_TO_SIGN:
+					fprintf(file, "\tunsign->sign at %s:%d\n", gimple_filename(stmt), gimple_lineno(stmt));break;
+				default:
+					fprintf(file, "\n");break;
+				}
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	}
+
+	fprintf(file, "-------------------------------------\n\n");
+	fclose(file);
+	return;
+}
+
+/* copy the RET and EXCLUDE tag of USE into SRC: using bitwise-OR operation */
+void intfns_transit_stmt_ret_exclude(gimple src, gimple use)
+{
+	INTFNS_STMT_INTO_RET(src) |= INTFNS_STMT_INTO_RET(use);
+	INTFNS_STMT_EXCLUDE(src) |= INTFNS_STMT_EXCLUDE(use);
+	INTFNS_STMT_EXCLUDE_UNUSE(src) |= INTFNS_STMT_EXCLUDE_UNUSE(use);
+	INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(src) |= INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(use);
+	INTFNS_STMT_EXCLUDE_BIT(src) |= INTFNS_STMT_EXCLUDE_BIT(use);
+	INTFNS_STMT_EXCLUDE_NARROW(src) |= INTFNS_STMT_EXCLUDE_NARROW(use);
+}
+
+/*------------------
+here, we conduct a backward dep analysis to find out all signcast, which are post-dominated by
+P2, P3, P5 and P6.
+--------------------*/
+static unsigned int
+intfns_dep_stmt_signcast(gimple propagate, gimple src, struct function * func)
+{
+	tree lhs;
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+
+	/* if src has already been analyzed as flowing into sink, we return. */
+	if(INTFNS_STMT_INTO_SINK(src))
+		return;
+	
+	// src is an being-analyzed int-op, and progate is an convert-op, casting-op or phi-node
+	if(gimple_code(propagate) == GIMPLE_PHI)
+		lhs = gimple_phi_result(propagate);
+	else if(gimple_code(propagate) == GIMPLE_ASSIGN)
+		lhs = gimple_assign_lhs (propagate);
+	else
+		return;
+	
+	// traversal each use-var of lhs
+	if(TREE_CODE(lhs) == SSA_NAME)
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	/*1.------------------------------------------------
+		1.1 at first check whether SRC is used at array-index.
+		1.2 check whether SRC is used at
+			global var, pointer-plus, if/while-relation stmt, if so, set INTO-SINK
+		1.3 check if SRC is used at propagate-stmt. if so, recurvie call.
+		1.4 check if SRC is used at +,-,* and <<. if so, transit.
+		1.5 check if SRC is used at Bit or Narrow. if so, update the EXCLUDE status. */
+	if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+	{	
+		// 1.1 check whether use-stmt is array[lhs] = xxxx.
+		use_lhs= gimple_assign_lhs(use_stmt);		
+		if((TREE_CODE(use_lhs) == ARRAY_REF)
+			&&(TREE_OPERAND(use_lhs, 1) == lhs))
+		{	// src is used at array-index, set INTO_SINK				
+			INTFNS_STMT_INTO_SINK(src) = 1;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}
+
+		// 1.2
+		stmt_type = INTFNS_STMT_TYPE(use_stmt);
+		if(((!INTFNS_STMT_LEFT_IS_SSA(use_stmt))&& (stmt_type != INTFNS_STMT_VAR_PROPAGATE))
+			|| (stmt_type == INTFNS_STMT_SMUL_OFFSET)
+			|| (stmt_type == INTFNS_STMT_UMUL_OFFSET)
+			|| (stmt_type == INTFNS_STMT_LEFT_NOT_INT)
+			|| (stmt_type == INTFNS_STMT_PTR_PLUS)
+			|| (stmt_type == INTFNS_STMT_IF)
+			|| (stmt_type == INTFNS_STMT_WHILE)
+			|| (stmt_type == INTFNS_STMT_ARRAY_REF))
+		{
+			INTFNS_STMT_INTO_SINK(src) = 1;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}		
+		
+		//1.4 transit
+		else if((stmt_type >= INTFNS_STMT_UADD)
+			&& (stmt_type <= INTFNS_STMT_SSHL))
+		{	// fixme: we may want to check the DEP-analysis status of use-stmt must be INTFNS_INTOP_BEEN_ANALYZED
+			if(INTFNS_STMT_INTO_SINK(use_stmt))
+			{
+				INTFNS_STMT_INTO_SINK(src) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+
+			// copy the RET and EXCLUDE tag of use-stmt into src
+			intfns_transit_stmt_ret_exclude(src, use_stmt);
+		}
+		// 1.5: bit and narrow
+		else if(stmt_type == INTFNS_STMT_BIT)
+		{
+			INTFNS_STMT_EXCLUDE(src) = 1;
+			INTFNS_STMT_EXCLUDE_BIT(src) = 1;
+		}
+		else if(stmt_type == INTFNS_STMT_NARROW)
+		{
+			INTFNS_STMT_EXCLUDE(src) = 1;
+			INTFNS_STMT_EXCLUDE_NARROW(src) = 1;
+		}
+		// sign-cast: update directly
+		else if((stmt_type == INTFNS_STMT_PROPAGATE)
+			&& INTFNS_SIGN_CAST_STATUS(use_stmt))
+		{
+			// propagate
+			if(INTFNS_STMT_INTO_SINK(use_stmt))
+			{
+				INTFNS_STMT_INTO_SINK(src) = 1;
+				BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			// copy the RET and EXCLUDE tag of use-stmt into src
+			intfns_transit_stmt_ret_exclude(src, use_stmt);
+		}
+		else
+		// 1.3 
+		/*((stmt_type == INTFNS_STMT_PROPAGATE)
+			|| (stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+			|| (stmt_type == INTFNS_STMT_SHR)
+			|| (stmt_type == INTFNS_STMT_MOD))*/
+		{	
+			// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+			// we should first get the next-use-stmt;
+			if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+				use_stmt = gimple_next(use_stmt);			
+			
+			// before propagate, we should check the analyze-status of this propagate-op.
+			// if this propagate-op is being analyzed, we should continue;
+			// else, we should set the status into being-analyzed.
+			// doing so, to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+			{
+				INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_dep_stmt_signcast(use_stmt, src, func);
+				INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+			
+				// check the result of propagate. 
+				// if src has been analyzed as flowing into sink immediately, return
+				if(INTFNS_STMT_INTO_SINK(src))
+					BREAK_FROM_IMM_USE_STMT (iter)				
+			}
+			else
+				;	// continue
+		}
+	}
+	
+	/*2.------------------------------------------------*/
+	else if(gimple_code(use_stmt) == GIMPLE_COND)
+	{
+		// src is used at if/while, set INTO_SINK				
+		INTFNS_STMT_INTO_SINK(src) = 1;
+		BREAK_FROM_IMM_USE_STMT (iter)
+	}
+	/*3.------------------------------------------------
+		3.1 if used at unciritcal-lib or external-lib, we set EXECLUDE tag
+		3.2 if used at normal-func:
+			if this func's UNCRITICAL tag is 1, then set EXECLUDE tag
+			if this func's UNCRITICAL tag is 2 and use-stmt has no lhs, we also set EXECLUDE tag
+		3.3 otherwise, we set INTO-SINK and break. */
+	else if(gimple_code(use_stmt) == GIMPLE_CALL)
+	{
+		unsigned int call_type = INTFNS_STMT_STATUS(use_stmt);
+		if((call_type == INTFNS_CALL_UNCRITICAL_LIB)
+			||(call_type == INTFNS_CALL_EXTERNAL_UNCRITICAL))
+		{
+			INTFNS_STMT_EXCLUDE(src) = 1;
+			INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(src) = 1;
+		}
+		else if(call_type == INTFNS_CALL_NORMAL_FUNC)
+		{
+			struct function* use_call = DECL_STRUCT_FUNCTION(gimple_call_fndecl(use_stmt));
+			if(use_call != NULL)
+			{
+				struct intfns_statistics * stat = INTFNS_STAT(use_call);
+				if(stat != NULL)
+				{
+					if(stat->is_uncritical == 1)
+					{
+						INTFNS_STMT_EXCLUDE(src) = 1;
+						INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(src) = 1;
+					}
+					else if((stat->is_uncritical == 2)
+						&& (!gimple_has_lhs(use_stmt)))
+					{
+						INTFNS_STMT_EXCLUDE(src) = 1;
+						INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(src) = 1;
+					}
+					else
+					{	// fixme: we may further conduct inter-p through the PARM
+						INTFNS_STMT_INTO_SINK(src) = 1;
+						BREAK_FROM_IMM_USE_STMT (iter)
+					}
+				}
+				else
+				{	// fixme: we may further conduct inter-p through the PARM
+					INTFNS_STMT_INTO_SINK(src) = 1;
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+		}
+		else
+		{
+			// src is used at potential sensitive calls, set INTO_SINK				
+			INTFNS_STMT_INTO_SINK(src) = 1;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}
+	}
+	/*4.------------------------------------------------
+		we have to check whehter FUNC is santzed at its call site, i.e. FUNC->intfns_info->is_santzd
+		if so, we set EXCLUDE flag and clean the RET tag
+		else set its RET tag.
+		Therefore, at the phase of instrumentation,
+			an intop have to be instrumented if RET tag is valid.*/
+	else if(gimple_code(use_stmt) == GIMPLE_RETURN)
+	{
+		struct intfns_statistics * stat = INTFNS_STAT(func);
+		if(stat->is_santzd)
+		{
+			INTFNS_STMT_EXCLUDE(src) = 1;
+			INTFNS_STMT_INTO_RET(src) = 0;
+		}
+		else
+		{
+			INTFNS_STMT_INTO_RET(src) = 1;
+			// then, we push current FUNC into our FUNC-QUEUE for further analysis
+			if(stat->in_queue)
+				;
+			else
+				stat->in_queue = 1;
+		}
+	}
+	/*5.------------------------------------------------*/
+	else if(gimple_code(use_stmt) == GIMPLE_PHI)
+	{	
+		// just like INTFNS-INTOP-PROPAGATE
+		// we should check analyzed-status of this gimple-phi
+		// in order to eliminate the infinite calls
+		if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+		{
+			INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+			// propagate, recursive call
+			intfns_dep_stmt_signcast(use_stmt, src, func);
+			INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+
+			// check the result of propagate. 
+			// if src has been analyzed as flowing into sink immediately, return
+			if(INTFNS_STMT_INTO_SINK(src))
+				BREAK_FROM_IMM_USE_STMT (iter)				
+		}
+		else
+			;	// continue
+	}
+	else
+		;
+	
+	return;
+}
+
+
+/*------------------
+here, we conduct a backward dep analysis to find out all intop, which are post-dominated by
+P2, P3, P5 and P6.
+--------------------*/
+static unsigned int
+intfns_dep_stmt_intop(FILE* file, gimple propagate, gimple src, struct function * func,
+	intfns_path current_path, VEC(intfns_path_node, gc) ** path_node_pool, VEC(intfns_path, gc) ** path_pool)
+{
+	tree lhs;
+	imm_use_iterator iter;
+	gimple use_stmt;
+	tree use_lhs;
+	unsigned int stmt_type;
+	unsigned int num_uses;
+	intfns_path new_path;
+	int status;
+
+	/* if src has already been analyzed as FAIL-TO-PROPAGATE, we return. */
+	//if(INTFNS_INTOP_POOL_STATUS(src) == FAIL_PROPAGATE)
+	//	return;
+	
+	// src is an being-analyzed int-op, and progate is an convert-op, casting-op or phi-node
+	if(gimple_code(propagate) == GIMPLE_PHI)
+		lhs = gimple_phi_result(propagate);
+	else if(gimple_code(propagate) == GIMPLE_ASSIGN)
+		lhs = gimple_assign_lhs (propagate);
+	else
+	{
+		// stop the analysis, and set this path as TO-UNKWN
+		INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+		current_path->type = PATH_TO_UNKWN;
+		return 1;
+	}
+
+	// if LHS is not in ssa form, so we don't know its further use
+	// stop the analysis, and set this path as TO-UNKWN
+	if(TREE_CODE(lhs) != SSA_NAME)
+	{
+		INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+		current_path->type = PATH_TO_UNKWN;
+		return 1;
+	}
+	else	// traversal each use-var of lhs
+	{
+	// the number of IMM-USE for LHS
+	num_uses = num_imm_uses(lhs);
+
+	// if there is no further USE
+	// stop the analysis, and set this path as TO-UNUSE
+	if(num_uses == 0)
+	{
+		INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+		current_path->type = PATH_TO_UNUSE;
+		return 1;
+	}
+	
+	// else, track each USE
+	FOR_EACH_IMM_USE_STMT(use_stmt, iter, lhs)
+	{
+	///* if src has already been analyzed as FAIL-TO-PROPAGATE, we break. */
+	//if(INTFNS_INTOP_POOL_STATUS(src) == FAIL_PROPAGATE)
+	//	BREAK_FROM_IMM_USE_STMT (iter)
+
+	// we have to construct a copy-path of CURRENT-PATH
+	if(num_uses == 1)
+		new_path = current_path;
+	else
+	{
+		status = build_path((&new_path), path_pool);
+		if(status == -1)	// build err
+		{
+			// INTFNS_INTOP_POOL_STATUS(src) = FAIL_PROPAGATE;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}
+		copy_path(current_path,new_path);
+	}
+	num_uses --;	// reset the counter: NUM-USES
+	
+	// create a new path-node, and then add this new path-node into current-path
+	intfns_path_node new_node;
+	status = build_path_node((&new_node), path_node_pool, use_stmt);
+	if(status == -1)
+	{
+		//INTFNS_INTOP_POOL_STATUS(src) = FAIL_PROPAGATE;
+		BREAK_FROM_IMM_USE_STMT (iter)
+	}
+	VEC_safe_push(intfns_path_node, gc, (new_path->node_list), new_node);
+	
+	/*1.-------ASSIGN-----------------------------------------
+		1.1 at first check whether SRC is used at array-index, pointer-plus, cast-to-unint, equal-inequal
+			if so, set IN-POOL
+		1.2 check whether SRC is used at global var, set FAIL-PROPAGATE
+		1.3 check if SRC is used at +,-,* and <<
+			if so, check whehter this new intop is IN-POOL
+		1.4 check if SRC is used at propagate-stmt, Bit or Narrow, Relation
+			if so, recurvie call.
+		*/
+	if(gimple_code(use_stmt)== GIMPLE_ASSIGN)
+	{
+		// 1.1 check whether use-stmt is array[lhs] = xxxx.
+		use_lhs= gimple_assign_lhs(use_stmt);		
+		if((TREE_CODE(use_lhs) == ARRAY_REF)
+			&&(TREE_OPERAND(use_lhs, 1) == lhs))
+		{	// src is used at array-index, set INTO_SINK				
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_ARRAYREF_LHS;
+			continue;
+		}
+		
+		stmt_type = INTFNS_STMT_TYPE(use_stmt);
+		if(stmt_type == INTFNS_STMT_PTR_PLUS)
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_POINTER_PLUS;
+		}
+		else if(stmt_type == INTFNS_STMT_ARRAY_REF)
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_ARRAYREF;
+		}
+		else if((stmt_type == INTFNS_STMT_SMUL_OFFSET)
+			|| (stmt_type == INTFNS_STMT_UMUL_OFFSET))
+		{
+			gimple use1;
+			use_operand_p use1_p;
+			if(single_imm_use(use_lhs, &use1_p, &use1))
+			{
+				intfns_path_node new_node1;
+				status = build_path_node((&new_node1), path_node_pool, use1);			
+				VEC_safe_push(intfns_path_node, gc, (new_path->node_list), new_node1);
+			}
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_ARRAYREF_OFFSET;
+		}
+		// NEW ADD: IntEquiv, we also treat cast-to-unINT and equal-inequal as sinks.
+		else if(stmt_type == INTFNS_STMT_CAST_TO_unINT)
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_CAST_TO_unINT;
+		}
+		else if(stmt_type == INTFNS_STMT_EQUAL_INEQUAL)
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_EQUAL_INEQAUL;
+		}
+		// 1.2 global var
+		else if((stmt_type == INTFNS_STMT_LEFT_NOT_INT)
+			|| ((!INTFNS_STMT_LEFT_IS_SSA(use_stmt)) && (stmt_type != INTFNS_STMT_VAR_PROPAGATE)))
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_UNKWN;
+		}
+		//1.3 new intop, we have to check this 'use-stmt' is in-pool
+		else if((stmt_type >= INTFNS_STMT_UADD)
+			&& (stmt_type <= INTFNS_STMT_SSHL))
+		{
+			if(src == use_stmt)
+			{
+				new_path->status = PATH_INVALID;	// continue
+			}
+			else if(INTFNS_INTOP_POOL_STATUS(use_stmt) == IN_POOL)
+			{
+				INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+				new_path->type = PATH_TO_INTOP;
+				INTFNS_INTOP_TAILS(use_stmt)++;
+			}
+			else if(INTFNS_INTOP_POOL_STATUS(use_stmt) == UN_ANALYZED)
+			{	// if this new intop is un-analyuzed, we tag this path as INVALID
+				new_path->status = PATH_INVALID;
+				INTFNS_INTOP_TAILS(use_stmt)++;
+				continue;
+			}
+			else{
+				INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+				new_path->type = PATH_TO_UNKWN;
+				INTFNS_INTOP_TAILS(use_stmt)++;
+				//BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+		// 1.4 recursive call, PROPAGATE, VAR-PROPAGATE, BIT, NARROW, RELATION, MODE, SHR...
+		else if(
+			(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+			|| (stmt_type == INTFNS_STMT_PROPAGATE)
+			|| (stmt_type == INTFNS_STMT_BIT)
+			|| (stmt_type == INTFNS_STMT_MOD)
+			|| (stmt_type == INTFNS_STMT_RELATION)
+			|| (stmt_type == INTFNS_STMT_SHR)
+			)
+		{
+			// for var-propagate: var-decl = ssa-name; ssa-name-2 = var-decl;
+			// we should first get the next-use-stmt;
+			if(stmt_type == INTFNS_STMT_VAR_PROPAGATE)
+			{
+				// locate the new stmt
+				use_stmt = gimple_next(use_stmt);
+				// add this new stmt into the path
+				intfns_path_node new_node2;
+				status = build_path_node((&new_node2), path_node_pool, use_stmt);			
+				VEC_safe_push(intfns_path_node, gc, (new_path->node_list), new_node2);		
+			}
+			
+			// before propagate, we should check the analyze-status of this propagate-op.
+			// if this propagate-op is being analyzed, we should continue;
+			// else, we should set the status into being-analyzed.
+			// The reason why we do this is to eliminate the infinite calls
+			if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+			{
+				INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+				// propagate, recursive call
+				intfns_dep_stmt_intop(file, use_stmt, src, func, new_path, path_node_pool, path_pool);
+				INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+			
+				// check the result of propagate.
+				// if src has been analyzed as FAIL-PROPAGATE, return
+				//if(INTFNS_INTOP_POOL_STATUS(src) == FAIL_PROPAGATE)
+				//	BREAK_FROM_IMM_USE_STMT (iter)
+			}
+			else	// then we set this new-path as invalid
+				new_path->status = PATH_INVALID;	// continue
+		}
+		else{
+
+		// FIXME:
+		// If array[inx] = xxx;, in IntEquiv, we may also treat such stmt as one kind of SINKs.
+			/*if((TREE_CODE(use_lhs) == ARRAY_REF)
+				|| (TREE_CODE(use_lhs) == INDIRECT_REF))
+			{	// src is used at array-index, set INTO_SINK
+				INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+				new_path->type = PATH_TO_ARRAY_LHS_UNEXTEND;
+			}
+			else*/
+			{
+				INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+				new_path->type = PATH_TO_UNKWN;
+				//BREAK_FROM_IMM_USE_STMT (iter)
+			}
+		}
+	}
+
+	/*2.--------------COND----------------------------------*/
+	// set IN-POOL and continue
+	else if(gimple_code(use_stmt) == GIMPLE_COND)
+	{
+		INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+
+		// FIXME: if the GIMPLE-COND is like if(a == b) or if(a != b), we set the path-type as EQUAL-inEQUAL
+		if((gimple_cond_code(use_stmt) == EQ_EXPR)
+			|| (gimple_cond_code(use_stmt) == NE_EXPR))
+			new_path->type = PATH_TO_EQUAL_INEQAUL;
+		else
+			new_path->type = PATH_TO_COND;			
+	}
+	/*3.--------------CALL----------------------------------
+		3.1 if used at unciritcal-lib or external-lib, we set IN-POOL, and set path-STATUS as PATH-TO-UNCRITICAL
+		3.2 if used at normal-func:
+			if this func's UNCRITICAL tag is 1, then set IN-POOL and PATH-TO-UNCRITICAL
+			if this func's UNCRITICAL tag is 2 and use-stmt has no lhs, 
+				we also set IN-POOL and PATH-TO-UNCRITICAL
+			else
+				we set FAIL-TO-PROPAGATE
+		3.3 otherwise, we set FAIL-TO-PROPAGATE.*/
+	else if(gimple_code(use_stmt) == GIMPLE_CALL)
+	{
+		unsigned int call_type = INTFNS_STMT_STATUS(use_stmt);
+		if((call_type == INTFNS_CALL_UNCRITICAL_LIB)
+			||(call_type == INTFNS_CALL_EXTERNAL_UNCRITICAL))
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_UNCRITICAL;
+		}
+		else
+		{
+			INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+			new_path->type = PATH_TO_UNKWN;
+		}
+
+		/*
+		else if(call_type == INTFNS_CALL_NORMAL_FUNC)
+		{		
+			struct function* use_call = DECL_STRUCT_FUNCTION(gimple_call_fndecl(use_stmt));
+			if(use_call != NULL)
+			{
+				struct intfns_statistics * stat = INTFNS_STAT(use_call);
+				if(stat != NULL)
+				{
+					if(stat->is_uncritical == 1)
+					{
+						INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+						new_path->status = PATH_TO_UNCRITICAL;
+					}
+					else if((stat->is_uncritical == 2)
+						&& (!gimple_has_lhs(use_stmt)))
+					{
+						INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+						new_path->status = PATH_TO_UNCRITICAL;
+					}
+					else
+					{	// fixme: we may further conduct inter-p through the PARM
+						INTFNS_INTOP_POOL_STATUS(src) = FAIL_PROPAGATE;
+						BREAK_FROM_IMM_USE_STMT (iter)
+					}
+				}
+				else
+				{	// fixme: we may further conduct inter-p through the PARM
+					INTFNS_INTOP_POOL_STATUS(src) = FAIL_PROPAGATE;
+					BREAK_FROM_IMM_USE_STMT (iter)
+				}
+			}
+		}
+		else
+		{
+			// src is used at potential sensitive calls, set FAIL-PROPAGATE				
+			INTFNS_INTOP_POOL_STATUS(src) = FAIL_PROPAGATE;
+			BREAK_FROM_IMM_USE_STMT (iter)
+		}*/
+	}
+	/*4.------------------RET------------------------------
+		for RET, we just set IN-POOL */
+	else if(gimple_code(use_stmt) == GIMPLE_RETURN)
+	{
+		INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+		new_path->type = PATH_TO_RET;
+	}
+	/*5.------------------------------------------------*/
+	else if(gimple_code(use_stmt) == GIMPLE_PHI)
+	{	
+		// just like INTFNS-INTOP-PROPAGATE
+		// we should check analyzed-status of this gimple-phi
+		// in order to eliminate the infinite calls
+		if(INTFNS_PROPAGATE_STATUS(use_stmt) == INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST)
+		{
+			INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_IN_ANALYZED_LIST;
+			// propagate, recursive call
+			intfns_dep_stmt_intop(file, use_stmt, src, func, new_path, path_node_pool, path_pool);
+			INTFNS_PROPAGATE_STATUS(use_stmt) = INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST;
+			
+			// check the result of propagate.
+			// if src has been analyzed as flowing into sink immediately, return
+		}
+		else{
+			new_path->status = PATH_INVALID;	// continue
+		}
+	}
+	else
+	{
+		INTFNS_INTOP_POOL_STATUS(src) = IN_POOL;
+		new_path->type = PATH_TO_UNKWN;
+	}
+	
+	}
+	
+	}
+	
+	return;
+}
+
+/* to travesal each INTop in current FUNC in backward order */
+static unsigned int
+intfns_dep_func_intra (struct function * func)
+{
+  	basic_block bb;
+  	gimple_stmt_iterator gsi;
+	int ix, iy;
+	gimple stmt, stmt_start;
+	
+	// get the path/path-node pool
+	struct intfns_statistics * stat = INTFNS_STAT(func);
+	VEC(intfns_path_node, gc) ** path_node_pool_addr = &(stat->intfns_path_node_pool);
+	VEC(intfns_path, gc) ** path_pool_addr = &(stat->intfns_path_pool);
+	int status;
+	intfns_path_node path_node;
+	intfns_path path;
+	FILE * file_test =	fopen("/tmp/log_intfns_test.txt", "a");
+			
+	/* travesal each INTop (the LHS must be SSA-NAME) in a backward order
+	and conduct intfns-dep-intop for each one. */
+	FOR_EACH_BB_REVERSE_FN(bb,func)
+	{
+		// get the first stmt in bb
+		gsi = gsi_start_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt_start = gsi_stmt(gsi);
+
+		// get the last stmt in bb
+		gsi = gsi_last_bb(bb);
+		if(gsi_end_p(gsi))
+			continue;
+		stmt = gsi_stmt(gsi);
+		
+		// travesal the stmt in bb backward.
+		while(stmt != stmt_start)
+		{	
+			/* filter all the intop stmt*/
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)				
+				&&(INTFNS_STMT_LEFT_IS_SSA(stmt))// lhs must be in ssa form
+				// fixme: we may want to extract the data flow for UNUSE intop
+				//&& (!INTFNS_STMT_EXCLUDE_UNUSE(stmt))
+				)
+			{
+				// for intop
+				if((INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+					&&(INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL))
+				{
+					if(INTFNS_INTOP_POOL_STATUS(stmt) == UN_ANALYZED)
+					{
+						status = build_path_node((&path_node), path_node_pool_addr, stmt);
+						if(status == 1)
+						{
+							status = build_path((&path), path_pool_addr);
+							if(status == 1)
+							{
+								VEC_safe_push(intfns_path_node, gc, (path->node_list), path_node);
+								// if this STMT is OVF intop in consideration, mark this path
+								if(INTFNS_INTOP_OVF(stmt))
+									path->has_ovf_intop = 1;
+								
+								intfns_dep_stmt_intop(file_test, stmt, stmt, func, 
+									path, path_node_pool_addr, path_pool_addr);							
+							}
+						}
+					}
+				}
+			}
+			
+			gsi_prev(&gsi);
+			stmt = gsi_stmt(gsi);
+		}
+		
+		// here, stmt is stmt-start
+		if((stmt != NULL)
+			&&(gimple_code (stmt) == GIMPLE_ASSIGN)			
+			&&(INTFNS_STMT_LEFT_IS_SSA(stmt))	// lhs must be in ssa form
+			// fixme: we may want to extract the data flow for UNUSE intop
+			//&& (!INTFNS_STMT_EXCLUDE_UNUSE(stmt))
+			)
+		{
+			// for intop
+			if((INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+				&&(INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL))
+			{
+				if(INTFNS_INTOP_POOL_STATUS(stmt) == UN_ANALYZED)
+				{
+					status = build_path_node((&path_node), path_node_pool_addr, stmt);
+					if(status == 1)
+					{
+						status = build_path((&path), path_pool_addr);
+						if(status == 1)
+						{
+							VEC_safe_push(intfns_path_node, gc, (path->node_list), path_node);
+							// if this STMT is OVF intop in consideration, mark this path
+							if(INTFNS_INTOP_OVF(stmt))
+								path->has_ovf_intop = 1;
+							
+							intfns_dep_stmt_intop(file_test, stmt, stmt, func, 
+								path, path_node_pool_addr, path_pool_addr);
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	fclose(file_test);
+	
+	// update the pool: remove the path which is PATH-INVALID
+	gimple stmt_last;
+	for(ix = 0; VEC_iterate(intfns_path, (stat->intfns_path_pool), ix, path); ix++)
+	{
+		if((path != NULL)&&(path->node_list != NULL))
+		{
+			path_node = VEC_index(intfns_path_node, (path->node_list),0);
+			stmt_start = path_node->stmt;
+			// stmt is an INTop
+			if((stmt_start != NULL)
+				&& (gimple_code(stmt_start) == GIMPLE_ASSIGN)
+				&& (INTFNS_STMT_TYPE(stmt_start) >= INTFNS_STMT_UADD)
+				&& (INTFNS_STMT_TYPE(stmt_start) <= INTFNS_STMT_SSHL))
+			{
+				if(path->status == PATH_INVALID)
+				{
+					// the last node of this path, if it is an intop, we update its TAILS
+					path_node = VEC_last(intfns_path_node, (path->node_list));
+					stmt_last = path_node->stmt;
+					if((stmt_last != NULL)
+						&& (gimple_code(stmt_last) == GIMPLE_ASSIGN)
+						&& (INTFNS_STMT_TYPE(stmt_last) >= INTFNS_STMT_UADD)
+						&& (INTFNS_STMT_TYPE(stmt_last) <= INTFNS_STMT_SSHL))
+					{
+						if((INTFNS_INTOP_POOL_STATUS(stmt_last) == IN_POOL)
+							&& (INTFNS_INTOP_TAILS(stmt_last) > 0))
+							INTFNS_INTOP_TAILS(stmt_last) --;
+					}
+					//at last, remove this invalid path
+					VEC_ordered_remove(intfns_path, (stat->intfns_path_pool), ix);
+					ix --;
+					ggc_free(path);
+				}
+			}
+		}
+	}
+	
+	// dump all the VALID basic paths
+	FILE * file = fopen("/tmp/log_intfns_BASIC_paths.txt", "a");
+	fprintf(file, "========================\n========================\n");
+	fprintf(file,"FUNCTION %s(): \n", lang_hooks.decl_printable_name(func->decl, 2));
+	fprintf(file, "basic paths are as follows: \n");
+	for(ix = 0; VEC_iterate(intfns_path, (stat->intfns_path_pool), ix, path); ix++)
+	{
+		if((path != NULL) && (path->node_list != NULL))
+		{
+			path->index_in_pool = ix;
+			fprintf(file, "path %d:", ix);
+			// dump the type of this path
+			if(path->status == PATH_INVALID)
+				fprintf(file, "<invalid> ");
+			else
+				;
+
+			if(path->type == PATH_TO_ARRAYREF)
+				fprintf(file, "<to array ref> ");
+			else if(path->type == PATH_TO_ARRAYREF_OFFSET)
+				fprintf(file, "<to array ref offset> ");
+			else if(path->type == PATH_TO_ARRAYREF_LHS)
+				fprintf(file, "<to left array ref> ");
+			else if(path->type == PATH_TO_POINTER_PLUS)
+				fprintf(file, "<to ptr plus> ");
+			else if(path->type == PATH_TO_INTOP)
+				fprintf(file, "<to intop> ");
+			else if(path->type == PATH_TO_RET)
+				fprintf(file, "<to ret> ");
+			else if(path->type == PATH_TO_COND)
+				fprintf(file, "<to cond> ");
+			else if(path->type == PATH_TO_CAST_TO_unINT)
+				fprintf(file, "<to unINT> ");
+			else if(path->type == PATH_TO_EQUAL_INEQAUL)
+				fprintf(file, "<to equal-inequal> ");
+			else if(path->type == PATH_TO_UNKWN)
+				fprintf(file, "<to unknown> ");
+			else if(path->type == PATH_TO_UNUSE)
+				fprintf(file, "<to unuse> ");
+			else if(path->type == PATH_TO_UNCRITICAL)
+				fprintf(file, "<to uncritical> ");
+			else
+				fprintf(file, "<to void> ");			
+			
+			// dump the TAILS info of the stmt_start
+			path_node = VEC_index(intfns_path_node, (path->node_list),0);
+			stmt_start = path_node->stmt;
+			fprintf(file, "<Tail:%u>", INTFNS_INTOP_TAILS(stmt_start));			
+			
+			fprintf(file, "\n");
+			
+			for(iy = 0; VEC_iterate(intfns_path_node, (path->node_list), iy, path_node); iy++)
+			{
+				stmt = path_node->stmt;
+				if(stmt != NULL)			
+				{	
+					// if this stmt is INTOP and this INTOP is OVF, we set this path
+					if((gimple_code(stmt) == GIMPLE_ASSIGN)
+						&& (INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+						&& (INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL))
+					{
+						if(INTFNS_INTOP_OVF(stmt))
+							path->has_ovf_intop = 1;
+					}
+					// print the stmt in details
+					print_gimple_stmt (file, stmt, 0, TDF_LINENO);
+					fprintf(file, "=====>>>>\n");
+				}
+				else
+					fprintf(file, "NULL-NODE\n=====>>>>\n");
+			}
+			// dump whether this path has OVF intop
+			if(path->has_ovf_intop)
+				fprintf(file, "<ovf>\n");
+			
+			fprintf(file, "\n");
+		}
+	}
+	
+	// dump all the paths
+	int path_counter = 1;
+	VEC(intfns_path, gc) * dump_stack = VEC_alloc(intfns_path, gc, 10);
+	fprintf(file, "\n=================\npaths are as follows: \n=================\n");
+	for(ix = 0; VEC_iterate(intfns_path, (stat->intfns_path_pool), ix, path); ix++)
+	{
+		if((path != NULL) && (path->node_list != NULL)
+			&& (path->has_ovf_intop)	// In IntEQ, we only consider OVF path.
+			)
+		{
+			path_node = VEC_index(intfns_path_node, (path->node_list),0);
+			stmt_start = path_node->stmt;
+
+			// stmt is an INTop
+			if((stmt_start != NULL)
+				&& (gimple_code(stmt_start) == GIMPLE_ASSIGN)
+				&& (INTFNS_STMT_TYPE(stmt_start) >= INTFNS_STMT_UADD)
+				&& (INTFNS_STMT_TYPE(stmt_start) <= INTFNS_STMT_SSHL)
+				&& (INTFNS_INTOP_TAILS(stmt_start) == 0))
+			{
+				// FIXME: in inteq, we don't need such threshold
+				// it is a threshold.
+				if(path_counter > PATH_MAX)
+					break;
+				
+				// if -->>intop, we dump each subpath
+				if(path->type == PATH_TO_INTOP)
+				{				
+					// PUSH into STACK
+					VEC_safe_push(intfns_path, gc, dump_stack, path);
+					path->in_stack = 1;
+					
+					// the last node of this path, if it is an intop and IN-POOL, we dump the next path
+					path_node = VEC_last(intfns_path_node, (path->node_list));
+					stmt_last = path_node->stmt;
+					if((stmt_last != NULL)
+						&& (gimple_code(stmt_last) == GIMPLE_ASSIGN)
+						&& (INTFNS_STMT_TYPE(stmt_last) >= INTFNS_STMT_UADD)
+						&& (INTFNS_STMT_TYPE(stmt_last) <= INTFNS_STMT_SSHL)
+						&& (INTFNS_INTOP_POOL_STATUS(stmt_last) == IN_POOL))
+						dump_path_starting_with_stmt(file, stmt_last,
+						 	(stat->intfns_path_pool), (&dump_stack), 
+						 	(&path_counter), func, (&stat));
+					
+					// POP out from the STACK
+					VEC_pop(intfns_path, dump_stack);
+					path->in_stack = 0;
+				}
+				else
+				{	// print this start path directly	
+					// In IntEQ, we should check this path has OVF intop.
+					if(path->has_ovf_intop)
+					{
+					// at first we have to update the path, path-node and precision info.
+					stat->path ++;
+					unsigned int path_node_num = 0;
+					unsigned int path_intop_node_num = 0;
+					unsigned int precs = 32;
+
+					// add all the nodes of this PATH into new-path-nodes
+					VEC(intfns_path_node, gc)* new_path_nodes = VEC_alloc(intfns_path_node, gc, 4);
+					VEC(intfns_path_node, gc)* intop_nodes = VEC_alloc(intfns_path_node, gc, 1);
+					
+					intfns_path_node print_path_node;
+					for(iy = 0; VEC_iterate(intfns_path_node, (path->node_list), iy, print_path_node); iy++)
+					{
+						VEC_safe_push(intfns_path_node, gc, new_path_nodes, print_path_node);
+					}
+
+					// add the first INTOP of this PATH into intop-nodes
+					VEC_safe_push(intfns_path_node, gc, intop_nodes, 
+							VEC_index(intfns_path_node, (path->node_list), 0));	
+
+					// get path-node-num
+					path_node_num = VEC_length(intfns_path_node, new_path_nodes);
+					stat->path_node_num += path_node_num;
+					if(stat->path_node_min > path_node_num)
+						stat->path_node_min = path_node_num;
+					if(stat->path_node_max < path_node_num)
+						stat->path_node_max = path_node_num;
+
+					// get path-intop-node-num
+					path_intop_node_num = VEC_length(intfns_path_node, intop_nodes);
+					stat->path_intop_node_num += path_intop_node_num;
+					if(stat->path_intop_node_min > path_intop_node_num)
+						stat->path_intop_node_min = path_intop_node_num;
+					if(stat->path_intop_node_max < path_intop_node_num)
+						stat->path_intop_node_max = path_intop_node_num;					
+					
+					// get 'precs'
+					gimple stmt_intop;
+					for(iy = 0; VEC_iterate(intfns_path_node, intop_nodes, iy, print_path_node); iy++)
+					{
+						stmt_intop = print_path_node->stmt;
+						if((stmt_intop != NULL)
+							&& (gimple_code(stmt_intop) == GIMPLE_ASSIGN))
+						{
+							// ADD or SUB
+							if((INTFNS_STMT_TYPE(stmt_intop) >= INTFNS_STMT_UADD)
+								&& (INTFNS_STMT_TYPE(stmt_intop) <= INTFNS_STMT_SSUB))
+								precs ++;
+							else if((INTFNS_STMT_TYPE(stmt_intop) >= INTFNS_STMT_UMUL)
+								&& (INTFNS_STMT_TYPE(stmt_intop) <= INTFNS_STMT_SSHL))
+								precs += 32;
+						}
+					}
+					if(stat->precs_min > precs)
+						stat->precs_min = precs;
+					if(stat->precs_max < precs)
+						stat->precs_max = precs;
+					
+					
+					fprintf(file, "PATH-%d:\tpath %d\n", path_counter, ix);				
+					// dump work
+					dump_full_path(func, path_counter, path->type, new_path_nodes);
+					
+					dump_all_intop_for_path(func, path_counter, intop_nodes);
+					
+					dump_z3_for_path(func, path_counter, path->type, new_path_nodes);
+					
+					VEC_free(intfns_path_node, gc, new_path_nodes);
+					VEC_free(intfns_path_node, gc, intop_nodes);
+										
+					path_counter ++;
+					}
+				}
+			}
+		}
+	}
+		
+	// free the stack
+	VEC_free(intfns_path, gc, dump_stack);
+	fprintf(file, "\n\n\n");
+	fclose(file);
+	return 1;
+}
+
+/* execution function for pass_intfns_dep 
+intuitively, we may want to use the dominator tree to conduct our intfns-dep analysis.
+	please refer to domwalk.c for more details.
+	However, current the the dominator tree in gcc is at the basic block level.
+we may also refer some details from pass_dominator in tree-ssa-dom.c.*/
+static unsigned int
+execute_intfns_dep (void)
+{
+	struct cgraph_node *node;
+	struct function * func = NULL;
+	
+	// this container is used as the Worklist for inter-procedure dep analysis
+	//VEC(intfns_func, gc) * func_queue = VEC_alloc(intfns_func, gc, 10);
+
+	/*1. intra-p:  further mark and intra-dep analysis-----------------*/
+	for (node = cgraph_nodes; node; node = node->next)
+	{
+		/* Nodes without a body are not interesting.  */
+		if(node->decl == NULL)
+			continue;
+      	if (!gimple_has_body_p (node->decl)
+	  		|| node->clone_of)
+			continue;
+
+		//continue;
+		func = DECL_STRUCT_FUNCTION (node->decl);
+
+		if(func == NULL)
+			continue;
+
+		// if current func has no OVFed intop, we just pass.
+		struct intfns_statistics * stat = INTFNS_STAT(func);
+		if(stat->fun_ovf_flag == 0)
+			continue;
+		
+		// to further mark the STMT in FUNC: unused, santz-post and implicit type.
+		intfns_mark_func_further(func);
+		
+		// KEY SITE for IntEquiv
+		// dep analysis
+		intfns_dep_func_intra(func);
+	}
+	
+	// FIXME: in IntEquiv, we stop here
+	return 1;
+	
+	
+	/*2. using worklist algorithm to update the FUNC->is_santzd
+		for each CALL-SITE of FUNC: lhs = FUNC;
+		check the USE of lhs is excluded stmt
+		cgraph-node: cgraph.h 181
+		cgraph-edge: cgraph.h 314------------------------------*/	
+	struct intfns_statistics * stat;
+	struct cgraph_edge* edge;
+	gimple call_site;
+	tree result;
+	unsigned int is_santzd;
+	gimple use;
+	use_operand_p use_p;
+	for (node = cgraph_nodes; node; node = node->next)
+	{
+		/* Nodes without a body are not interesting.  */
+      	if (!gimple_has_body_p (node->decl)
+	  		|| node->clone_of)
+			continue;
+
+		func = DECL_STRUCT_FUNCTION (node->decl);
+
+		if(func == NULL)
+			continue;
+		
+		stat = INTFNS_STAT(func);
+		
+		
+		if(stat->in_queue)	// to update this func->is_santzd
+		{
+		is_santzd = 1;		
+		// travesal each call-site of NODE
+		for(edge = node->callers; edge; edge = edge->next_caller)
+		{
+			call_site = edge->call_stmt;
+			// lhs = FUNC;
+			if(gimple_has_lhs(call_site))
+			{
+				result = gimple_call_lhs(call_site);
+				if((TREE_CODE(result) == SSA_NAME)
+					&&(single_imm_use(result, &use_p, &use))
+					&&(gimple_code(use)== GIMPLE_ASSIGN)
+					&&((INTFNS_STMT_TYPE(use) == INTFNS_STMT_BIT)
+						||(INTFNS_STMT_TYPE(use) == INTFNS_STMT_NARROW)))
+				{
+					;
+				}
+				else
+				{
+					is_santzd = 0;
+					break;
+				}
+			}
+		}
+		
+		// if each call-site is santzd, we set FUNC->is_santzd as 1
+		if(is_santzd)
+			stat->is_santzd = 1;		
+		}
+	}
+
+	
+	/* 3. conduct intra-p dep analysis once again.--------------------------*/
+	for (node = cgraph_nodes; node; node = node->next)
+	{
+		/* Nodes without a body are not interesting.  */
+      	if (!gimple_has_body_p (node->decl)
+	  		|| node->clone_of)
+			continue;
+	
+		func = DECL_STRUCT_FUNCTION (node->decl);		
+		// dep analysis
+		;//intfns_dep_func_intra(func);
+	}
+
+	/* 4. at last, update the INTO-SINK, INTO-RET and EXCLUDE tag---------- */
+	for (node = cgraph_nodes; node; node = node->next)
+	{
+		/* Nodes without a body are not interesting.  */
+      	if (!gimple_has_body_p (node->decl)
+	  		|| node->clone_of)
+			continue;
+
+		func = DECL_STRUCT_FUNCTION (node->decl);
+
+		if(func == NULL)
+			continue;
+		
+		basic_block bb;
+	  	gimple_stmt_iterator gsi;
+		gimple stmt;
+		
+		FOR_EACH_BB_FN(bb, func)
+		for(gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))
+		{		
+			stmt = gsi_stmt(gsi);
+			if((stmt != NULL)
+				&&(gimple_code (stmt) == GIMPLE_ASSIGN)
+				&&
+				(((INTFNS_STMT_TYPE(stmt) >= INTFNS_STMT_UADD)
+					&&(INTFNS_STMT_TYPE(stmt) <= INTFNS_STMT_SSHL))
+				|| ((INTFNS_STMT_TYPE(stmt) == INTFNS_STMT_PROPAGATE) 
+					&& (INTFNS_SIGN_CAST_STATUS(stmt))))
+				&&(INTFNS_STMT_LEFT_IS_SSA(stmt)))
+			{
+				if((INTFNS_STMT_INTO_SINK(stmt))
+					|| (INTFNS_STMT_INTO_RET(stmt)))
+				{
+					INTFNS_STMT_EXCLUDE_UNUSE(stmt) = 0;
+					INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(stmt) = 0;
+					INTFNS_STMT_EXCLUDE_BIT(stmt) = 0;
+					INTFNS_STMT_EXCLUDE_NARROW(stmt) = 0;
+
+					if((INTFNS_STMT_EXCLUDE_CST(stmt))
+						|| (INTFNS_STMT_EXCLUDE_SANTZ_POST(stmt)))
+						INTFNS_STMT_EXCLUDE(stmt) = 1;
+					else
+						INTFNS_STMT_EXCLUDE(stmt) = 0;
+				}
+			}
+		}
+	}
+	
+	return 1;
+}
+
+/* pass_intfns_begin definition */
+struct ipa_opt_pass_d pass_intfns_dep =
+{
+ {
+  IPA_PASS,
+  "intfns_dep",		                /* name */
+  gate_intfns,					/* gate */
+  execute_intfns_dep,			        /* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_INTFNS_DEP,		/* tv_id */
+  PROP_ssa,	            /* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0                     /* todo_flags_finish */
+ },
+ NULL,		        /* generate_summary */
+ NULL,				/* write_summary */
+ NULL,				/* read_summary */
+ NULL,				/* function_read_summary */
+ 0,					/* TODOs */
+ NULL,			    /* function_transform */
+ NULL				/* variable_transform */
+};
+
+/*---------------------------------------------------------------------------------*/
+/*---------------------  intfns-insert, instrument runtime check code ---------------------*/
+/*---------------------------------------------------------------------------------*/
+/* todo: more details about this pass
+/**********************************************
+insert check code to detect integer overflows at runtime.
+
+default: instrument-all, invoked by -fintfns
+for each stmt in current func:	
+	if stmt is add, sub, mul and shl
+		if the operands are of integer type
+			insert check code for them.//intfns-instrument-intop
+
+invoked by -fintfns-intra or -fintfns-inter
+for all the stmts in the waitlist of current func:
+	// waitlist is generated by pass-intfns-intra or pass-intfns-inter
+	for each stmt in the waitlish
+		this stmt is selected as potential intop
+			insert check code for them.//intfns-instrument-intop
+	
+//intfns-instrument-intop:
+such process of instrumentation is executed using basic block information at the ipa analysis phase.
+therefore, the code instrumentation will break the CFG and 
+we do have to consider how to operate the Basic Block.
+
+we implement this function by learning the pass-mudflap-2 in tree-mudflap.c.
+the execution trace for pass-mudflap-2 is like:
+	execute_mudflap_function_ops -> mf_xform_statements -> mf_xform_derefs_1 
+	-> mf_build_check_statement_for
+and mf_build_check_statement_for() is the very function where we learn most.
+
+at the same time, we could also produce some statistics about integer operations.
+num_stmt: the number of all the stmt for current function
+num_sign_op_N: the number of integer operations which need instrumentation
+	here, op enums add/sub/mul/shl
+		sign enums signed and unsigned
+		and N enums 8 (char), 16 (short), 32 (int) and 64 (long long)
+**********************************************/
+/* Build a reference to a literal string.  */
+static tree
+intfns_build_string (const char *string)
+{
+  	size_t len = strlen (string);
+  	tree result = build_string (len + 1, string);
+
+  	TREE_TYPE (result) = build_array_type
+    	(char_type_node, build_index_type (build_int_cst (NULL_TREE, len)));
+  	TREE_CONSTANT (result) = 1;
+  	TREE_READONLY (result) = 1;
+  	TREE_STATIC (result) = 1;
+
+  	result = build1 (ADDR_EXPR, build_pointer_type (char_type_node), result);
+
+  	return result;
+}
+
+/* And another friend, for producing a simpler message.  */
+static tree
+intfns_file_function_line_tree (location_t location)
+{
+  	expanded_location xloc = expand_location (location);
+  	const char *file = NULL, *colon, *line, *op, *name, *cp;
+  	char linecolbuf[30]; /* Enough for two decimal numbers plus a colon.  */
+  	char *string;
+  	tree result;
+
+  	/* Add FILENAME[:LINENUMBER[:COLUMNNUMBER]].  */
+  	file = xloc.file;
+  	if (file == NULL && current_function_decl != NULL_TREE)
+    	file = DECL_SOURCE_FILE (current_function_decl);
+  	if (file == NULL)
+    	file = "<unknown file>";
+
+  	if (xloc.line > 0)
+    {
+      	if (xloc.column > 0)
+        	sprintf (linecolbuf, "%d:%d", xloc.line, xloc.column);
+      	else
+        	sprintf (linecolbuf, "%d", xloc.line);
+      	colon = ":";
+      	line = linecolbuf;
+    }
+  	else
+   	 	colon = line = "";
+
+  	/* Add (FUNCTION).  */
+  	name = lang_hooks.decl_printable_name (current_function_decl, 1);
+  	if (name)
+    {
+      	op = " (";
+      	cp = ")";
+    }
+  	else
+    	op = name = cp = "";
+
+  	string = concat (file, colon, line, op, name, cp, NULL);
+  	result = intfns_build_string (string);
+  	free (string);
+
+  	return result;
+}
+
+/* Helper for intfns_init: construct a decl with the given category,
+   name, and type, mark it an external reference, and pushdecl it.  */
+static inline tree
+intfns_make_builtin (enum tree_code category, const char *name, tree type)
+{
+  	/* tree decl = intsortfns_mark (build_decl (UNKNOWN_LOCATION,
+				   category, get_identifier (name), type)); */
+  	tree decl = build_decl (UNKNOWN_LOCATION, category, get_identifier (name), type);
+  	TREE_PUBLIC (decl) = 1;
+  	DECL_EXTERNAL (decl) = 1;
+  	lang_hooks.decls.pushdecl (decl);
+  	/* The decl was declared by the compiler.  */
+  	DECL_ARTIFICIAL (decl) = 1;
+  	/* And we don't want debug info for it.  */
+  	DECL_IGNORED_P (decl) = 1;
+  	return decl;
+}
+
+/* a function to insert 2 handler call */
+void intfns_insert_main (void)
+{
+	tree ctor_statements = NULL_TREE;
+	tree dtor_statements = NULL_TREE;
+	tree call2_stmt;
+	
+  	/* Insert a call to intfns_insert_init().  */
+  	{
+    	call2_stmt = build_call_expr (intfns_insert_init_fndecl, 0);
+    	append_to_statement_list (call2_stmt, &ctor_statements);
+  	}
+
+  	cgraph_build_static_cdtor ('I', ctor_statements,
+                             MAX_RESERVED_INIT_PRIORITY-1);
+
+  	/* Insert a call to intfns_insert_finish().  */
+  	{
+    	call2_stmt = build_call_expr (intfns_insert_finish_fndecl, 0);
+    	append_to_statement_list (call2_stmt, &dtor_statements);
+  	}
+
+  	cgraph_build_static_cdtor ('D', dtor_statements,
+                             MAX_RESERVED_INIT_PRIORITY-1);
+}
+
+
+/*a function to initialize the global tree nodes
+that may be used when instrumentation.  */
+void intfns_init (void)
+{
+	/* const-string type */
+	tree intfns_const_string_type;
+	
+	/* void intfns_io_printer(char* loc, rhs1, rhs2, print_type);  */
+	tree intfns_io_printer_8_fntype;
+	tree intfns_io_printer_16_fntype;
+	tree intfns_io_printer_32_fntype;
+	tree intfns_io_printer_64_fntype;
+	/* void intfns_io_counter(char* loc, print_type, static_type);  */
+	tree intfns_io_counter_fntype;
+	
+	/* void intfns_signcast_printer(char* loc, rhs1, print_type);  */
+	tree intfns_signcast_printer_8_fntype;
+	tree intfns_signcast_printer_16_fntype;
+	tree intfns_signcast_printer_32_fntype;
+	tree intfns_signcast_printer_64_fntype;
+	/* void intfns_signcast_counter(char* loc, print_type, static_type);  */
+	tree intfns_signcast_counter_fntype;
+	
+	/* void function type, intfns_insert_init(void), intfns_insert_finish(void) */
+	tree intfns_insert_void_fntype;
+	
+	/* const-string type */
+	intfns_const_string_type = build_pointer_type (build_qualified_type
+    	(char_type_node, TYPE_QUAL_CONST));
+	
+	/* void intfns_io_printer_xx(char* loc, rhs1, rhs2, print_type);  */
+	intfns_io_printer_8_fntype = build_function_type_list(void_type_node, intfns_const_string_type, char_type_node,
+	   	char_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_8_fndecl =
+	    intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_8",
+		         intfns_io_printer_8_fntype);
+	
+	intfns_io_printer_16_fntype = build_function_type_list(void_type_node, intfns_const_string_type, short_integer_type_node,
+	   	short_integer_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_16_fndecl =	
+	    intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_16",
+	         intfns_io_printer_16_fntype);
+	
+	intfns_io_printer_32_fntype = build_function_type_list(void_type_node, intfns_const_string_type, integer_type_node,
+       	integer_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_32_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_32",
+             intfns_io_printer_32_fntype);
+
+	intfns_io_printer_64_fntype = build_function_type_list(void_type_node, intfns_const_string_type, long_long_integer_type_node,
+       	long_long_integer_type_node, integer_type_node, NULL_TREE);
+	intfns_io_printer_64_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_printer_64",
+             intfns_io_printer_64_fntype);	
+
+	/* void intfns_io_counter(char* loc, print_type, static_type);  */
+	intfns_io_counter_fntype = build_function_type_list(void_type_node, intfns_const_string_type, 
+		integer_type_node, unsigned_type_node, NULL_TREE);
+	intfns_io_counter_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_counter",intfns_io_counter_fntype);
+
+	
+	/* void intfns_signcast_printer_xx(char* loc, rhs1, print_type);  */
+	intfns_signcast_printer_8_fntype = build_function_type_list(void_type_node, intfns_const_string_type, char_type_node,
+		integer_type_node, NULL_TREE);
+	intfns_signcast_printer_8_fndecl =
+		intfns_make_builtin (FUNCTION_DECL, "intfns_signcast_printer_8",
+				 intfns_signcast_printer_8_fntype);
+	
+	intfns_signcast_printer_16_fntype = build_function_type_list(void_type_node, intfns_const_string_type, short_integer_type_node,
+		integer_type_node, NULL_TREE);
+	intfns_signcast_printer_16_fndecl =	
+		intfns_make_builtin (FUNCTION_DECL, "intfns_signcast_printer_16",
+			 intfns_signcast_printer_16_fntype);
+	
+	intfns_signcast_printer_32_fntype = build_function_type_list(void_type_node, intfns_const_string_type, integer_type_node,
+		integer_type_node, NULL_TREE);
+	intfns_signcast_printer_32_fndecl =
+		intfns_make_builtin (FUNCTION_DECL, "intfns_signcast_printer_32",
+			 intfns_signcast_printer_32_fntype);
+
+	intfns_signcast_printer_64_fntype = build_function_type_list(void_type_node, intfns_const_string_type, long_long_integer_type_node,
+		integer_type_node, NULL_TREE);
+	intfns_signcast_printer_64_fndecl =
+		intfns_make_builtin (FUNCTION_DECL, "intfns_signcast_printer_64",
+			 intfns_signcast_printer_64_fntype);	
+
+	/* void intfns_signcast_counter(char* loc, print_type);  */
+	intfns_signcast_counter_fntype = build_function_type_list(void_type_node, 
+		intfns_const_string_type, integer_type_node, unsigned_type_node, NULL_TREE);
+	intfns_signcast_counter_fndecl =
+		intfns_make_builtin (FUNCTION_DECL, "intfns_signcast_counter",
+		intfns_signcast_counter_fntype);
+
+	/* void intfns_insert_init(void);  */
+	intfns_insert_void_fntype =	build_function_type_list(void_type_node, NULL_TREE);
+	intfns_insert_init_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_insert_init",
+             intfns_insert_void_fntype);
+
+	/* void intfns_insert_finish(void);  */
+	intfns_insert_finish_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_insert_finish",
+             intfns_insert_void_fntype);
+
+	/* void intfns_io_nop(void);  */
+	intfns_io_nop_fndecl =
+        intfns_make_builtin (FUNCTION_DECL, "intfns_io_nop",
+             intfns_insert_void_fntype);
+	
+	/* init the value of s-max, s-min and u-max, both in 8,16,32,64-bit. */
+	// refer to tree.h 3767 for integer_type_node and long_long_integer_type_node
+	intfns_smax_8 = build_int_cst (char_type_node, 0x7f);
+	intfns_smin_8 = build_int_cst (char_type_node, 0x80);
+	intfns_umax_8 = build_int_cstu (unsigned_char_type_node, 0xff);
+	intfns_u_smin_8 = build_int_cstu (unsigned_char_type_node, 0x80);
+	
+	intfns_smax_16 = build_int_cst (short_integer_type_node, 0x7fff);
+	intfns_smin_16 = build_int_cst (short_integer_type_node, 0x8000);
+	intfns_umax_16 = build_int_cstu (short_unsigned_type_node, 0xffff);
+	intfns_u_smin_16 = build_int_cstu (short_unsigned_type_node, 0x8000);	
+	
+	intfns_smax_32 = build_int_cst (integer_type_node, 0x7fffffff);
+	intfns_smin_32 = build_int_cst (integer_type_node, 0x80000000);
+	intfns_umax_32 = build_int_cstu (unsigned_type_node, 0xffffffff);
+	intfns_u_smin_32 = build_int_cstu (unsigned_type_node, 0x80000000);
+	
+	intfns_smax_64 = build_int_cst_wide (long_long_integer_type_node, 0xffffffff, 0x7fffffff);
+	intfns_smin_64 = build_int_cst_wide (long_long_integer_type_node, 0x00000000, 0x80000000);
+	intfns_umax_64 = build_int_cst_wide (long_long_unsigned_type_node, 0xffffffff, 0xffffffff);
+	intfns_u_smin_64 = build_int_cst_wide (long_long_unsigned_type_node, 0x00000000, 0x80000000);
+}
+
+/* insert check code before add, sub, in both signed and unsigned forms. */
+static unsigned int
+intfns_pre_instrument_intop_add_sub(gimple_stmt_iterator *instr_gsi,
+							location_t location, tree lhs, tree rhs1, tree rhs2, 
+							unsigned int type, int width, unsigned int static_type)
+{
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u, v, w, m, n;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree smax, smin, umax;
+
+	// current we focus on8,16,32,64-bit, and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme however in current implementation, we only fous on 32-bit and 64-bit cases
+		smax = intfns_smax_8;
+		smin = intfns_smin_8;
+		umax = intfns_umax_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		smax = intfns_smax_16;
+		smin = intfns_smin_16;
+		umax = intfns_umax_16;
+	}
+	else if(width == 32)
+	{	
+		smax = intfns_smax_32;
+		smin = intfns_smin_32;
+		umax = intfns_umax_32;
+	}
+	else if(width == 64)
+	{
+		smax = intfns_smax_64;
+		smin = intfns_smin_64;
+		umax = intfns_umax_64;
+	}
+	else
+		return;
+	
+	tree print_type = build_int_cst (integer_type_node, type);	
+	tree static_type_node = build_int_cst (unsigned_type_node, static_type);
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block (intfns-io-printer).	*/
+	then_bb = create_empty_bb (cond_bb);
+	make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+	}
+
+	/*-------------------2. create the io-check-cond and insert them into cond-bb---------------*/
+	seq = gimple_seq_alloc ();
+	/* 2.1 create the io-check-code for different intop, add/sub/mul/shl, in either sign/unsign.*/
+	if(type == INTFNS_STMT_UADD)
+	{	/*unsigned add c = a + b;, trigger cond is (a > umax -b)*/
+   		/*build tmp = umax - b */
+		if(width == 8)
+			u = build2 (MINUS_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			u = build2 (MINUS_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			u = build2 (MINUS_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			u = build2 (MINUS_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		/* build a > umax - b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_add_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == INTFNS_STMT_SADD)
+	{	/*signed add c = a + b;, trigger cond is (a>0&&b>0&&a>smax-b)||(a<0&&b<0&&a<smin-b)*/
+ 		/* build a > 0*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b > 0 */
+		v = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a > smax - b*/
+		if(width == 8)
+			w = build2 (MINUS_EXPR, char_type_node, smax, rhs2);
+		else if (width == 16)
+			w = build2 (MINUS_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width == 32)
+			w = build2 (MINUS_EXPR, integer_type_node, smax, rhs2);
+		else
+			w = build2 (MINUS_EXPR, long_long_integer_type_node, smax, rhs2);
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a>0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b>0'&&'a>smax-b''******************/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, v);
+
+		/* build a < 0*/
+		u = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b < 0 */
+		v = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a < smin - b*/
+		if(width == 8)
+			w = build2 (MINUS_EXPR, char_type_node, smin, rhs2);
+		else if(width == 16)
+			w = build2 (MINUS_EXPR, short_integer_type_node, smin, rhs2);
+		else if(width == 32)
+			w = build2 (MINUS_EXPR, integer_type_node, smin, rhs2);
+		else
+			w = build2 (MINUS_EXPR, long_long_integer_type_node, smin, rhs2);
+		m = build2 (LT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a<0 && b < 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b>0'&&'a>smax-b''*******************/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, m, v);
+
+		/*build ---||---*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, n);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_add_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+		
+	}
+	else if(type == INTFNS_STMT_USUB)
+	{	/*unsigned sub: c = a - b;, trigger cond is if(a<b)*/
+		t = build2 (LT_EXPR, boolean_type_node, rhs1, rhs2);		
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_sub_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == INTFNS_STMT_SSUB)
+	{	/*signed sub: c = a - b;, trigger cond is (a<0&&b>0&&a<smin+b)||(a>0&&b<0&&a>smax+b)*/
+		/* build a < 0*/
+		u = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b > 0 */
+		v = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a < smin + b*/
+		if(width == 8)
+			w = build2 (PLUS_EXPR, char_type_node, smin, rhs2);
+		else if(width == 16)
+			w = build2 (PLUS_EXPR, short_integer_type_node, smin, rhs2);
+		else if(width == 32)
+			w = build2 (PLUS_EXPR, integer_type_node, smin, rhs2);
+		else
+			w = build2 (PLUS_EXPR, long_long_integer_type_node, smin, rhs2);
+		t = build2 (LT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a<0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a<0'&&'b>0'&&'a<smin+b''******************/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, t, v);
+
+		/* build a > 0*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/* build b < 0 */
+		v = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build a > smax + b*/
+		if(width == 8)
+			w = build2 (PLUS_EXPR, char_type_node, smax, rhs2);
+		else if(width == 16)
+			w = build2 (PLUS_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width == 32)
+			w = build2 (PLUS_EXPR, integer_type_node, smax, rhs2);
+		else
+			w = build2 (PLUS_EXPR, long_long_integer_type_node, smax, rhs2);
+		m = build2 (GT_EXPR, boolean_type_node, rhs1, w);
+
+		/*build a>0 && b < 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+		/*build 'a>0'&&'b<0'&&'a>smax+b''*******************/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, m, v);
+
+		/*build ---||---*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, n);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_sub_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else
+		return 0;	// error
+
+	/* 2.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 2.3 insert these code into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------3. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_io_counter_fndecl, 3, 
+			intfns_file_function_line_tree (location), print_type, static_type_node);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();	// it is a 'nop' to calculate the overhead
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_io_printer_8_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else if(width == 16)
+			gg = gimple_build_call (intfns_io_printer_16_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+		else if(width == 32)
+			gg = gimple_build_call (intfns_io_printer_32_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else
+			gg = gimple_build_call (intfns_io_printer_64_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------4. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* insert check code before mul, in both signed and unsigned forms. */
+static unsigned int
+intfns_pre_instrument_intop_mul_shl(gimple_stmt_iterator *instr_gsi,
+							location_t location, tree lhs, tree rhs1, tree rhs2, 
+							unsigned int type, int width, unsigned int static_type)
+{
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, cond_nonzero_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u, v, w, m, n;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree smax, smin, umax;
+
+	// current we only focus on 32-bit and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme, in current implementation, we only focus on 32-bit and 64-bit cases.
+		smax = intfns_smax_8;
+		smin = intfns_smin_8;
+		umax = intfns_umax_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		smax = intfns_smax_16;
+		smin = intfns_smin_16;
+		umax = intfns_umax_16;
+	}
+	else if(width == 32)
+	{	
+		smax = intfns_smax_32;
+		smin = intfns_smin_32;
+		umax = intfns_umax_32;
+	}
+	else if(width == 64)
+	{
+		smax = intfns_smax_64;
+		smin = intfns_smin_64;
+		umax = intfns_umax_64;
+	}
+	else
+		return;
+	
+	tree print_type = build_int_cst (integer_type_node, type);	
+	tree static_type_node = build_int_cst (unsigned_type_node, static_type);
+
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block */
+	cond_nonzero_bb = create_empty_bb (cond_bb);
+	then_bb = create_empty_bb (cond_nonzero_bb);
+	make_edge (cond_bb, cond_nonzero_bb, EDGE_TRUE_VALUE);
+	make_edge (cond_nonzero_bb, then_bb, EDGE_TRUE_VALUE);
+	make_edge (cond_nonzero_bb, join_bb, EDGE_FALSE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, cond_nonzero_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_nonzero_bb);
+	}
+
+	/*-------------------2. create the (b!=0) && (b!=-1) and insert it into cond-bb---------------*/
+	/*fixme: b!=-1 would bypass the overflow (smin*(-1)), we would handle it when free.*/
+	seq = gimple_seq_alloc ();
+	if(type == INTFNS_STMT_SMUL)
+	{
+		/* build b!=0*/
+		u = build2 (NE_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/* build b!=-1*/
+		v = build2 (NE_EXPR, boolean_type_node, rhs2, integer_minus_one_node);	
+		/*build b!=0 && b!=-1*/
+		t = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+	}
+	else
+	{
+		/* build b!=0*/
+		t = build2 (NE_EXPR, boolean_type_node, rhs2, integer_zero_node);
+	}	
+	t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+ 	gimple_seq_add_seq (&seq, stmts);
+ 	cond = make_rename_temp (boolean_type_node, "__intfns_mul_cond_nonzero");
+ 	gg = gimple_build_assign  (cond, t);
+	gimple_set_location (gg, location);
+  	gimple_seq_add_stmt (&seq, gg);
+
+	/* build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* insert it into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+	
+
+	/*-------------------3. create mul-io check code and insert them into cond-nonzero-bb---------------*/
+	seq = gimple_seq_alloc ();
+	
+	/* 3.1 create the io-check-code for different intop, add/sub/mul/shl, in either sign/unsign.*/
+	if(type == INTFNS_STMT_UMUL)
+	{	/*unsigned mul: c = a * b;, trigger cond is (a > umax/b)*/		
+		/* build a > umax/b*/
+		if(width == 8)
+			v = build2 (TRUNC_DIV_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			v = build2 (TRUNC_DIV_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			v = build2 (TRUNC_DIV_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			v = build2 (TRUNC_DIV_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, v);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_mul_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == INTFNS_STMT_SMUL)
+	{	/*signed mul: c = a * b;, trigger cond is
+			(a>0&&b>0&&a>smax/b)||(a<0&&b<0&&a<smax/b)
+				||(a>0&&b<0&&a>smin/b)||(a<0&&b>0&&a<smin/b)*/
+		tree uu, vv, ww, mm, nn, tt;
+		
+		/*build a > 0*/
+		uu = build2 (GT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/*build a < 0*/
+		vv = build2 (LT_EXPR, boolean_type_node, rhs1, integer_zero_node);
+		/*build b > 0*/
+		ww = build2 (GT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/*build b < 0*/
+		mm = build2 (LT_EXPR, boolean_type_node, rhs2, integer_zero_node);
+		/*build smax/b*/
+		if(width == 8)
+			nn = build2 (TRUNC_DIV_EXPR, char_type_node, smax, rhs2);
+		else if(width ==16)
+			nn = build2 (TRUNC_DIV_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width == 32)
+			nn = build2 (TRUNC_DIV_EXPR, integer_type_node, smax, rhs2);
+		else
+			nn = build2 (TRUNC_DIV_EXPR, long_long_integer_type_node, smax, rhs2);
+		/*build smin/b*/
+		if(width == 8)
+			tt = build2 (TRUNC_DIV_EXPR, char_type_node, smin, rhs2);
+		else if(width == 16)
+			tt = build2 (TRUNC_DIV_EXPR, short_integer_type_node, smin, rhs2);
+		else if(width == 32)
+			tt = build2 (TRUNC_DIV_EXPR, integer_type_node, smin, rhs2);
+		else
+			tt = build2 (TRUNC_DIV_EXPR, long_long_integer_type_node, smin, rhs2);
+
+		/*build a>smax/b*/
+		u = build2 (GT_EXPR, boolean_type_node, rhs1, nn);
+		/*build a>0 && b > 0*/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, uu, ww);
+		/*build 1':(a>0&&b>0&&a>smax/b)*******************/
+		u = build2 (TRUTH_AND_EXPR, boolean_type_node, u, v);
+
+		/*build a<smax/b*/
+		v = build2 (LT_EXPR, boolean_type_node, rhs1, nn);
+		/*build a<0 && b < 0*/
+		w = build2 (TRUTH_AND_EXPR, boolean_type_node, vv, mm);
+		/*build 2':(a<0&&b<0&&a<smax/b)*******************/
+		v = build2 (TRUTH_AND_EXPR, boolean_type_node, v, w);
+
+		/*build a>smin/b*/
+		w = build2 (GT_EXPR, boolean_type_node, rhs1, tt);
+		/*build a>0 && b < 0*/
+		m = build2 (TRUTH_AND_EXPR, boolean_type_node, uu, mm);
+		/*build 3':(a>0&&b<0&&a>smin/b)*******************/
+		w = build2 (TRUTH_AND_EXPR, boolean_type_node, w, m);
+
+		/*build a<smin/b*/
+		m = build2 (LT_EXPR, boolean_type_node, rhs1, tt);
+		/*build a<0 && b > 0*/
+		n = build2 (TRUTH_AND_EXPR, boolean_type_node, vv, ww);
+		/*build 4':(a<0&&b>0&&a<smin/b)*******************/
+		m = build2 (TRUTH_AND_EXPR, boolean_type_node, m, n);
+
+		/*build 1' || 2' || 3' || 4'*/
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, u, v);
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, w);
+		t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, m);	
+		
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_mul_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);	
+	}
+	else if(type == INTFNS_STMT_USHL)
+	{	/*left shift: c = a << b;, trigger cond is a > umax>>b)*/
+		/*build umax>>b*/
+		if(width == 8)
+			u = build2 (RSHIFT_EXPR, unsigned_char_type_node, umax, rhs2);
+		else if(width == 16)
+			u = build2 (RSHIFT_EXPR, short_unsigned_type_node, umax, rhs2);
+		else if(width == 32)
+			u = build2 (RSHIFT_EXPR, unsigned_type_node, umax, rhs2);
+		else
+			u = build2 (RSHIFT_EXPR, long_long_unsigned_type_node, umax, rhs2);
+		/*build a > umax>>b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_shl_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(type == INTFNS_STMT_SSHL)
+	{	/*left shift: c = a << b;, trigger cond is a > smax>>b)*/
+		/*build smax>>b*/
+		if(width == 8)
+			u = build2 (RSHIFT_EXPR, char_type_node, smax, rhs2);
+		else if(width == 16)
+			u = build2 (RSHIFT_EXPR, short_integer_type_node, smax, rhs2);
+		else if(width ==32)
+			u = build2 (RSHIFT_EXPR, integer_type_node, smax, rhs2);
+		else
+			u = build2 (RSHIFT_EXPR, long_long_integer_type_node, smax, rhs2);
+		/*build a > smax>>b*/
+		t = build2 (GT_EXPR, boolean_type_node, rhs1, u);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_shl_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else
+		return 0;
+
+	/* 3.2 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 3.3 insert these code into cond-nonzero-bb */
+	gsi = gsi_start_bb (cond_nonzero_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+
+	/*-------------------4. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_io_counter_fndecl, 3, 
+			intfns_file_function_line_tree (location), print_type, static_type_node);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_io_printer_8_fndecl, 4, 	
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+		else if(width == 16)
+			gg = gimple_build_call (intfns_io_printer_16_fndecl, 4, 
+					intfns_file_function_line_tree (location), rhs1, rhs2, print_type);	
+		else if(width == 32)
+			gg = gimple_build_call (intfns_io_printer_32_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);
+		else
+			gg = gimple_build_call (intfns_io_printer_64_fndecl, 4, 
+				intfns_file_function_line_tree (location), rhs1, rhs2, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------5. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* insert check code before sign-cast, type: 1 sign->unsign, 2 unsign->sign
+for sign->unsign: c = (unsign) a;
+	we check if a < 0
+for unsign->sign: c = (sign) a;
+	we check if a > 0x7fff,ffff (it is a value based on the 'width') */
+static unsigned int
+intfns_pre_instrument_sign_cast(gimple_stmt_iterator *instr_gsi,
+	location_t location, tree lhs, tree rhs1, unsigned int type, int width,
+	unsigned int static_type)
+{
+	gimple_stmt_iterator gsi;
+	basic_block cond_bb, then_bb, join_bb;
+	edge e;
+	tree cond, t, u;
+	gimple gg;
+	gimple_seq seq, stmts;
+	tree mask;
+	
+	tree print_type = build_int_cst (integer_type_node, type);
+	tree static_type_node = build_int_cst (unsigned_type_node, static_type);
+	
+	// current we focus on8,16,32,64-bit, and we could expand to other width easily.
+	if(width == 8)
+	{
+		return;	//fixme however in current implementation, we only fous on 32-bit and 64-bit cases
+		mask = intfns_u_smin_8;
+	}
+	else if(width == 16)
+	{	
+		return;	// fixme;
+		mask = intfns_u_smin_16;
+	}
+	else if(width == 32)
+	{	
+		mask = intfns_u_smin_32;
+	}
+	else if(width == 64)
+	{	return;
+		mask = intfns_u_smin_64;
+	}
+	else
+		return;
+	
+	/*--------------------------1. split the current block-----------------------------------*/
+	/* We first need to split the current basic block, and start altering
+		the CFG.  This allows us to insert the statements we're about to
+		construct into the right basic blocks.  */
+	cond_bb = gimple_bb (gsi_stmt (*instr_gsi));
+  	gsi = *instr_gsi;
+  	gsi_prev (&gsi);
+  	if (! gsi_end_p (gsi))
+    	e = split_block (cond_bb, gsi_stmt (gsi));
+  	else
+    	e = split_block_after_labels (cond_bb);
+	cond_bb = e->src;
+	join_bb = e->dest;
+	
+	/* Create the bb that contains the overflow-handler block (intfns-io-printer).	*/
+	then_bb = create_empty_bb (cond_bb);
+	make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);
+ 	make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);
+	
+	/* Mark the pseudo-fallthrough edge from cond_bb to join_bb. */
+	e = find_edge (cond_bb, join_bb);
+	e->flags = EDGE_FALSE_VALUE;
+	e->count = cond_bb->count;
+	e->probability = REG_BR_PROB_BASE;
+	
+	/* Update dominance info.  Note that bb_join's data was updated by split_block.  */
+	if (dom_info_available_p (CDI_DOMINATORS))
+	{
+		set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);
+		set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);
+	}
+	
+	/*-------------------2. create the signcast-check-cond and insert them into cond-bb---------------*/
+	seq = gimple_seq_alloc ();
+
+	tree rhs1_copy;
+	
+	if (TREE_CODE (TREE_TYPE (rhs1)) == ENUMERAL_TYPE)
+	{
+		tree rhs1_copy2, rhs1_nop;
+		
+		rhs1_copy2 = create_tmp_var (TREE_TYPE (rhs1), "rhs1_copy2");
+		gg = gimple_build_assign (rhs1_copy2, unshare_expr (rhs1));
+		gimple_set_location (gg, location);
+		gimple_seq_add_stmt (&seq, gg);
+
+		rhs1_nop = fold_build1 (NOP_EXPR, TREE_TYPE (rhs1), rhs1_copy2);
+		rhs1_copy = create_tmp_var (TREE_TYPE (rhs1), "rhs1_copy");
+		gg = gimple_build_assign (rhs1_copy, rhs1_nop);
+		gimple_set_location (gg, location);
+		gimple_seq_add_stmt (&seq, gg);
+	}
+	else if(TREE_CODE(rhs1) == SSA_NAME)
+		rhs1_copy = rhs1;
+	else
+	/* copy lhs to local variable */
+	{
+		rhs1_copy = create_tmp_var (TREE_TYPE (rhs1), "rhs1_copy");
+		gg = gimple_build_assign (rhs1_copy, unshare_expr (rhs1));
+		gimple_set_location (gg, location);
+		gimple_seq_add_stmt (&seq, gg);
+	}
+
+	/* 2.2 create the signcast-check-code sign->unsign and unsign->sign */
+	if(type == INTFNS_STMT_SIGN_TO_UNSIGN)
+	{	/*c = unsign a, trigger cond is (a < 0)*/
+		t = build2 (LT_EXPR, boolean_type_node, rhs1_copy, integer_zero_node);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_sign_to_unsign_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+	else	//(type == INTFNS_STMT_UNSIGN_TO_SIGN) use bit-wise op
+	{	/*c = sign a, trigger cond is if(a > smax)*/
+		/* build u = a&mask*/
+		if(width == 8)
+			u = build2 (BIT_AND_EXPR, unsigned_char_type_node, rhs1_copy, mask);
+		else if (width == 16)
+			u = build2 (BIT_AND_EXPR, short_unsigned_type_node, rhs1_copy, mask);
+		else if(width == 32)
+			u = build2 (BIT_AND_EXPR, unsigned_type_node, rhs1_copy, mask);
+		else
+			u = build2 (BIT_AND_EXPR, long_long_unsigned_type_node, rhs1_copy, mask);
+			
+		/* build a&mask != 0*/
+		t = build2 (NE_EXPR, boolean_type_node, u, integer_zero_node);
+		t = force_gimple_operand (t, &stmts, false, NULL_TREE);
+	 	gimple_seq_add_seq (&seq, stmts);
+	 	cond = make_rename_temp (boolean_type_node, "__intfns_unsign_to_sign_cond");
+	 	gg = gimple_build_assign  (cond, t);
+		gimple_set_location (gg, location);
+	  	gimple_seq_add_stmt (&seq, gg);
+	}
+
+	/* 2.3 build the IF-cond expr*/
+	gg = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE, NULL_TREE);
+	gimple_set_location (gg, location);
+	gimple_seq_add_stmt (&seq, gg);
+
+	/* 2.4 insert these code into cond-bb */
+	gsi = gsi_last_bb (cond_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);
+	
+	/*-------------------3. create the io-handler and insert them into then-bb---------------*/
+	/* insert label-true, build T-branch */
+	seq = gimple_seq_alloc ();
+
+	if(flag_intfns_handler_counter)	// counter, do statistics for runtime io
+		gg = gimple_build_call (intfns_signcast_counter_fndecl, 3,
+			intfns_file_function_line_tree (location), print_type, static_type_node);
+	else if(flag_intfns_handler_nop)
+		gg = gimple_build_nop();	// it is a 'nop' to calculate the overhead
+		//gg = gimple_build_call (intfns_io_nop_fndecl, 0);
+	else	/*to print the detailed location*/
+	{
+		if(width == 8)
+			gg = gimple_build_call (intfns_signcast_printer_8_fndecl, 3, 
+				intfns_file_function_line_tree (location), rhs1, print_type);
+		else if(width == 16)
+			gg = gimple_build_call (intfns_signcast_printer_16_fndecl, 3, 
+				intfns_file_function_line_tree (location), rhs1, print_type);		
+		else if(width == 32)
+			gg = gimple_build_call (intfns_signcast_printer_32_fndecl, 3, 
+				intfns_file_function_line_tree (location), rhs1, print_type);
+		else
+			gg = gimple_build_call (intfns_signcast_printer_64_fndecl, 3, 
+				intfns_file_function_line_tree (location), rhs1, print_type);		
+	}
+	gimple_set_location (gg, location);
+ 	gimple_seq_add_stmt (&seq, gg);
+
+	/* Insert the check code in the THEN block.  */
+  	gsi = gsi_start_bb (then_bb);
+  	gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);	
+
+	/*--------------------------4. update the gsi---------------------------------------*/
+	*instr_gsi = gsi_start_bb (join_bb);
+
+	return 1;
+}
+
+/* main func for INSERT */
+static unsigned int
+execute_intfns_insert (void)
+{
+	struct intfns_statistics * stat = (struct intfns_statistics*) (cfun->intfns_info);
+		
+	// to dump each EXCLUDEd stmt and STAT info
+	FILE* file = fopen("/tmp/log_intfns_EXCLUDEd_stmt.txt", "a");
+	fprintf(file, "$intfns-insert %s():\n",
+		lang_hooks.decl_printable_name(current_function_decl, 2));
+	if(DECL_STRUCT_FUNCTION(current_function_decl) == NULL)
+	{
+		fprintf(file, "$NO function* field.\n");
+		fprintf(file, "$intfns-insert ends here.\n\n");
+		fclose(file);
+		return 0;
+	}	
+
+	/*4. dump STAT info----------------------------------------------------------*/
+/*	fprintf (file, "\n\ttotal stmt: %d, mul-offset: %d, intop: %d\n", 
+		stat->stmt_total, stat->intop_mul_offset, stat->intop_total);
+	
+	fprintf(file, "\tamong these intops, %d is left-not-ssa and %d is implicit\n",
+		stat->intop_left_not_ssa, stat->intop_implicit);
+
+	fprintf(file, "\ttotally %d intops are exlcuded, specifically CST:%d, UNUSE:%d\n",
+		stat->intop_exclude, stat->intop_exclude_cst, stat->intop_exclude_unuse);
+
+	fprintf(file, "\t\tUNCRITICAL:%d, SANTZ:%d, BIT:%d, NARROW:%d\n",
+		stat->intop_exclude_uncritical_use, stat->intop_exclude_santz_post,
+		stat->intop_exclude_bit, stat->intop_exclude_narrow);
+
+	fprintf(file, "\tsign-cast in array: %d, sign-cast: %d, among these sign-casts, %d is implicit, %d is useless\n",
+		stat->sign_cast_in_array, stat->sign_cast_total, stat->sign_cast_implicit, stat->sign_cast_useless);
+
+	fprintf(file, "\ttotally %d sign-casts are exlcuded, specifically CST:%d, UNUSE:%d\n",
+		stat->sign_cast_exclude, stat->sign_cast_exclude_cst, stat->sign_cast_exclude_unuse);
+
+	fprintf(file, "\t\tUNCRITICAL:%d, SANTZ:%d, BIT:%d, NARROW:%d\n",
+		stat->sign_cast_exclude_uncritical_use, stat->sign_cast_exclude_santz_post,
+		stat->sign_cast_exclude_bit, stat->sign_cast_exclude_narrow);
+
+	fprintf(file, "\tThis function is is_uncritical:%d, is_santzd:%d, has_global_var:%d\n\n",
+		stat->is_uncritical, stat->is_santzd, stat->has_global_var);
+	*/
+	fclose(file);
+
+	// dump into BIN file
+	file = fopen("/tmp/log_intfns_finish.bin","ab");
+	if(fwrite(stat, sizeof(struct intfns_statistics), 1, file) != 1)
+		printf("file_bin ERROR");
+	fclose(file);
+
+	// at last, free the path-node-pool and path-pool
+	int ix;
+	intfns_path_node path_node;
+	intfns_path path;
+	for(ix = 0; VEC_iterate(intfns_path_node, (stat->intfns_path_node_pool), ix, path_node); ix++)
+	{
+		if(path_node != NULL)
+			ggc_free(path_node);
+	}
+
+	for(ix = 0; VEC_iterate(intfns_path, (stat->intfns_path_pool), ix, path); ix++)
+	{
+		if(path != NULL)
+		{
+			if(path->node_list != NULL)
+				VEC_free(intfns_path_node, gc, (path->node_list));
+			ggc_free(path);
+		}
+	}
+	
+	VEC_free(intfns_path_node, gc, (stat->intfns_path_node_pool));
+	VEC_free(intfns_path, gc, (stat->intfns_path_pool));
+	
+	// at last, free FUNC->STAT
+	ggc_free(stat);
+	return 1;
+}
+
+/* pass_intfns_insert definition */
+struct gimple_opt_pass pass_intfns_insert =
+{
+ 	{
+  		GIMPLE_PASS,
+  		"intfns_insert",			/* name */
+  		gate_intfns,			/* gate */
+  		execute_intfns_insert,		/* execute */
+  		NULL,						/* sub */
+  		NULL,						/* next */
+  		0,							/* static_pass_number */
+  		TV_INTFNS_INSERT,			/* tv_id */
+  		PROP_ssa, 					/* properties_required */
+  		0,							/* properties_provided */
+  		0,							/* properties_destroyed */
+  		0,							/* todo_flags_start */
+  		TODO_update_ssa 			/* todo_flags_finish */
+ 	}
+};
+
+/*----------------------------------------------------------*/
+/* execution function for pass_intfns_finish */
+static unsigned int
+execute_intfns_finish (void)
+{
+	return 1;
+}
+
+/* pass_intfns_finish definition */
+struct ipa_opt_pass_d pass_intfns_finish =
+{
+ {
+  IPA_PASS,
+  "intfns_finish",		                /* name */
+  gate_intfns,							/* gate */
+  execute_intfns_finish,			   	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_INTFNS_FINISH,		/* tv_id */
+  PROP_ssa,	            /* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_update_ssa     	/* todo_flags_finish */
+ },
+ NULL,		        /* generate_summary */
+ NULL,				/* write_summary */
+ NULL,				/* read_summary */
+ NULL,				/* function_read_summary */
+ 0,					/* TODOs */
+ NULL,			    /* function_transform */
+ NULL				/* variable_transform */
+};
+
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-extern-func-specs.def /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-extern-func-specs.def
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-extern-func-specs.def	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-extern-func-specs.def	2014-05-27 18:40:48.000000000 -0400
@@ -0,0 +1,25 @@
+/*this file is used to specify the external functions,
+where the parameters might be used at lib-sinks.
+as the current version of intfns has not implemented the LTO(link time optimization),
+external functions in different files can not be obtained during the inter-p analysis for
+current file (compilation unit).
+therefore, we need this specs to tell the characteristics for some key external functions.
+
+specifically, there are about 2 kinds of extern-func.
+	1.it would use its arguements sensitively. we can treat it as sink-lib call.
+	2.it would not use its arguements sensitively. we can treat it as uncritical lib call.
+here, we just give detailed cases for 4th sinks-memory operations.
+
+struct intfns_func_specs_node
+{
+	char name[MAX_NAME_LENGTH];
+	int arg;	// 1 for sink, 0 for unciritical
+};
+*/
+
+
+/* printIntLine(int result ); */ 
+{
+	"PrintIntLine",
+	0
+}
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-extern-func-specs.def~ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-extern-func-specs.def~
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-extern-func-specs.def~	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-extern-func-specs.def~	2014-05-19 22:26:18.000000000 -0400
@@ -0,0 +1,25 @@
+/*this file is used to specify the external functions,
+where the parameters might be used at lib-sinks.
+as the current version of intfns has not implemented the LTO(link time optimization),
+external functions in different files can not be obtained during the inter-p analysis for
+current file (compilation unit).
+therefore, we need this specs to tell the characteristics for some key external functions.
+
+specifically, there are about 2 kinds of extern-func.
+	1.it would use its arguements sensitively. we can treat it as sink-lib call.
+	2.it would not use its arguements sensitively. we can treat it as uncritical lib call.
+here, we just give detailed cases for 4th sinks-memory operations.
+
+struct intfns_func_specs_node
+{
+	char name[MAX_NAME_LENGTH];
+	int arg;	// 1 for sink, 0 for unciritical
+};
+*/
+
+
+/* printIntLine(char *dest,char *src, int n); */ 
+{
+	"PrintIntLine",
+	0
+}
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns.h /home/haosun/intchecker/gcc-4.5.0/gcc/intfns.h
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns.h	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns.h	2015-08-23 14:28:16.545334853 -0400
@@ -0,0 +1,364 @@
+/* to include *.h files */
+#include "hashtab.h"
+#include "vec.h"
+#include "tree.h"
+
+/*----------------------------------------------------------------------*/
+/*--------------------1. infor for statistics for each func---------------------*/
+/*----------------------------------------------------------------------*/
+/* intfns-path: each node is a gimple stmt */
+struct intfns_path_node_def
+{
+	gimple stmt;
+	unsigned int arg;
+};
+typedef struct intfns_path_node_def * intfns_path_node;
+DEF_VEC_P(intfns_path_node);
+DEF_VEC_ALLOC_P(intfns_path_node,gc);
+
+/* intfns-path */
+struct intfns_path_def
+{
+	VEC(intfns_path_node, gc) * node_list;
+	unsigned int index_in_pool;
+	unsigned int status : 2;
+	unsigned int type : 4;
+	unsigned int in_stack : 1;	// to indicate whether this path is in the PRINT-STACK
+	unsigned int has_ovf_intop : 1;
+	unsigned int spare : 24;
+};
+// the STATUS of this path
+#define PATH_INVALID 1
+//#define PATH_TO_UNCRITICAL 2
+// the TYPE of this path
+#define PATH_TO_ARRAYREF 1
+#define PATH_TO_ARRAYREF_LHS 2
+#define PATH_TO_POINTER_PLUS 3
+#define PATH_TO_INTOP 4
+#define PATH_TO_RET 5
+#define PATH_TO_COND 6
+#define PATH_TO_ARRAYREF_OFFSET 7
+#define PATH_TO_CAST_TO_unINT 8
+#define PATH_TO_EQUAL_INEQAUL 9
+#define PATH_TO_UNKWN 10
+#define PATH_TO_ARRAY_LHS_UNEXTEND 11
+#define PATH_TO_UNUSE 12
+#define PATH_TO_UNCRITICAL 13
+
+// Tree.h : 395, 6 bits are used to indicate the status of TREE NODE in the process of IntEquiv
+/* used to tag this TREE NODE is in our container */
+#define INTFNS_TREE_NODE_INLIST(NODE) ((NODE)->base.intfns_tree_node_inlist_flag)
+/* used to tag the SSA-id of the TREE NODE under our z3 format */
+#define INTFNS_TREE_NODE_SSAID(NODE) ((NODE)->base.intfns_tree_node_ssaid_flag)
+/* used to tag this TREE NODE is the definition site */
+#define INTFNS_TREE_NODE_ISLEFT(NODE) ((NODE)->base.intfns_tree_node_isleft_flag)
+
+
+// a threshold to the max number of PATHs for each function
+#define PATH_MAX 1000000
+
+typedef struct intfns_path_def * intfns_path;
+DEF_VEC_P(intfns_path);
+DEF_VEC_ALLOC_P(intfns_path,gc);
+
+
+struct intfns_statistics
+{
+	char func_name[128];
+
+	/* stats for intop stmt */
+	unsigned int stmt_total;
+
+	/* intop */
+	unsigned int intop_total;
+	unsigned int intop_mul_offset;
+	unsigned int intop_left_not_ssa;
+	unsigned int intop_implicit;
+	
+	unsigned int intop_exclude_cst;
+	unsigned int intop_exclude_unuse;
+	unsigned int intop_exclude_uncritical_use;
+	unsigned int intop_exclude_santz_post;
+	unsigned int intop_exclude_bit;
+	unsigned int intop_exclude_narrow;
+	unsigned int intop_exclude;
+
+	/* sign-casting */
+	unsigned int sign_cast_total;
+	unsigned int sign_cast_implicit;
+	unsigned int sign_cast_in_array;
+	unsigned int sign_cast_useless;
+	unsigned int sign_cast_exclude_cst;
+	unsigned int sign_cast_exclude_unuse;
+	unsigned int sign_cast_exclude_uncritical_use;
+	unsigned int sign_cast_exclude_santz_post;
+	unsigned int sign_cast_exclude_bit;
+	unsigned int sign_cast_exclude_narrow;
+	unsigned int sign_cast_exclude;
+	
+	/* status for this func */
+	unsigned int is_uncritical;
+	unsigned int is_santzd;
+	unsigned int has_global_var;
+	unsigned int in_queue;
+
+	/* a container to store all the path */
+	VEC(intfns_path_node, gc) * intfns_path_node_pool;
+	VEC(intfns_path, gc) * intfns_path_pool;
+
+	/* for inteq */
+	unsigned int fun_ovf_flag;	// this func has OVFed intop
+	unsigned int intop_ovf;		// num of intop marked as OVF
+	unsigned int path;			// num of paths extracted
+	unsigned int path_node_num;	// num of path node
+	unsigned int path_node_min;
+	unsigned int path_node_max;	// (min, max) for number of node per path
+	unsigned int path_intop_node_num;	// num of integer operation node 
+	unsigned int path_intop_node_min;	
+	unsigned int path_intop_node_max;	// (min, max) for number of intop node per path
+	unsigned int precs_min;	
+	unsigned int precs_max;		// (min, max) for the high precision version
+};
+
+/* using a new field 'intfns-info' (function.h:530) to 
+store all the info produced during our static analysis. */
+#define INTFNS_STAT(FUN)	(struct intfns_statistics*)(FUN->intfns_info)
+
+/*----------------------------------------------------------------------*/
+/*---------------------------2. gimple-stmt-------------------------------*/
+/*----------------------------------------------------------------------*/
+/* using 15 bits (gimple.h:310) to indicate the type and status of stmt.*/
+
+/*-------------1---------*/
+/* there are a number of GIMPLE stmt type, as shown in gimple.h:734.
+in intfns, we only consider GIMPLE_ASSIGN, GIMPLE_COND, GIMPLE_CALL, GIMPLE_RET, and
+GIMPLE_PHI.
+the first 4 gimple-stmts are structed as gss-with-ops or gss-with-mem-ops, 
+and they share the field 'gsbase'. 
+therefore, we insert intfns-type-flag:5bits into 'gsbase', and use INTFNS-STMT-TYPE
+to identify these 4 gimple-stmts.
+and the last (propagate-op) are structed as gss-stmt-base, 
+and can be identified by their gimple-code.
+****for gimple stmt type: 5 bits */
+#define INTFNS_STMT_TYPE(NODE) NODE->gsbase.intfns_stmt_type_flag
+
+/* +, -, * AND <<. they are potential intop, which may ovf */
+#define INTFNS_STMT_UADD 1
+#define INTFNS_STMT_SADD 2
+#define INTFNS_STMT_USUB 3
+#define INTFNS_STMT_SSUB 4
+#define INTFNS_STMT_UMUL 5
+#define INTFNS_STMT_SMUL 6
+#define INTFNS_STMT_USHL 7
+#define INTFNS_STMT_SSHL 8
+
+/* other basic type */
+#define INTFNS_STMT_PTR_PLUS	9		// POINTER PLUS  stmt
+#define INTFNS_STMT_CALL 10				// FUNC CALL stmt
+#define INTFNS_STMT_UMUL_OFFSET 11	
+#define INTFNS_STMT_SMUL_OFFSET 12		// MUL introduced by ARRAY[inx]
+#define INTFNS_STMT_IF	13				// IF stmt
+#define INTFNS_STMT_WHILE	14			// WHILE stmt
+#define INTFNS_STMT_RET	15				// RET stmt
+#define INTFNS_STMT_MOD	16				// MOD stmt
+#define INTFNS_STMT_NARROW 17			// Narrow: a%cst, a>>cst, a&0xffff
+#define INTFNS_STMT_BIT	18				// BIT stmt, bitwise-and, bitwise-or and bitwise-not
+#define INTFNS_STMT_RELATION	19		// RELATION stmt, and, or, not
+#define INTFNS_STMT_PROPAGATE 20		// A = B;
+#define INTFNS_STMT_SHR 21				// RIGHT SHIFT stmt
+#define INTFNS_STMT_LEFT_NOT_INT 22		// the LHS of an BIN op is not of integer type
+#define INTFNS_STMT_ARRAY_REF 23		// A = array[inx];
+#define INTFNS_STMT_VAR_PROPAGATE 24	// VAR-DECL = SSA-NAME
+#define INTFNS_STMT_EQUAL_INEQUAL 25	// a == b, a != b
+#define INTFNS_STMT_CAST_TO_unINT 26	// int b; float a = (float) b;
+
+/*#define INTFNS_STMT_DENIED	16
+#define INTFNS_STMT_SANTZ_AND_CONST 28
+#define INTFNS_STMT_SANTZ_MOD_CONST 29
+#define INTFNS_STMT_SANTZ_AND_ARRAY 30
+#define INTFNS_STMT_SANTZ_MOD_ARRAY 31
+#define INTFNS_STMT_SANTZ_AND_IF 32
+#define INTFNS_STMT_SANTZ_OR_IF 33
+#define INTFNS_STMT_SANTZ_AND_MASK 34
+#define INTFNS_STMT_SANTZ_MOD_SIZEOF 35
+#define INTFNS_STMT_SANTZ_AND_VAR_CONST 36
+#define INTFNS_STMT_SANTZ_MOD_VAR_CONST 37
+#define INTFNS_STMT_ADDRESS_GLOBAL 38
+#define INTFNS_STMT_ADDRESS_ARRAY_REF 39
+#define INTFNS_STMT_ADDRESS_STRUCT_REF 40*/
+
+
+/*-------------2---------*/
+/* we further use 1 bit to indicate, the LHS of stmt is a ssa-name */
+#define INTFNS_STMT_LEFT_IS_SSA(NODE) NODE->gsbase.intfns_stmt_left_ssa_flag
+
+/*-------------3---------*/
+/* we further use 3 bits to provide more details */
+#define INTFNS_STMT_STATUS(NODE) NODE->gsbase.intfns_stmt_status_flag
+
+/* for FUNC CALL stmt, to tell the 'LIB', 'SINK' 'UNCRITICAL' and 'EXTERNAL' */
+#define INTFNS_CALL_SINK_LIB	1
+#define INTFNS_CALL_UNCRITICAL_LIB	2
+#define INTFNS_CALL_NORMAL_FUNC	3
+#define INTFNS_CALL_EXTERNAL_SINK 4
+#define INTFNS_CALL_EXTERNAL_UNCRITICAL 5
+
+/* for status of intop at the process of DEP analysis, 0: un-analyzed, 1: being-analyzed, 2: been-analyzed 
+such status flag is used when analyzing intop recursively to break loops. */
+#define INTFNS_INTOP_DEP_STATUS(NODE) NODE->gsbase.intfns_stmt_status_flag
+#define INTFNS_INTOP_UN_ANALYZED 0
+#define INTFNS_INTOP_BEING_ANALYZED 1
+#define INTFNS_INTOP_BEEN_ANALYZED 2
+
+/*  for STMT-PROPAGATE: a = b, we use this status-flag to indicate
+whether this propagate is a sign-casting: 1 for sign->unsign and 2 for unsign->sign */
+#define INTFNS_SIGN_CAST_STATUS(NODE) NODE->gsbase.intfns_stmt_status_flag
+#define INTFNS_STMT_SIGN_TO_UNSIGN 1
+#define INTFNS_STMT_UNSIGN_TO_SIGN 2
+#define INTFNS_STMT_SIGN_CAST_IN_ARRAY 3 // we don't count sign-casts, used as array indexing
+
+
+/*-------------4---------*/
+/* we further use 7 bits to indicate the EXCLUDE status for an INTOP*/
+#define INTFNS_STMT_EXCLUDE(NODE) NODE->gsbase.intfns_stmt_exclude_flag
+#define INTFNS_STMT_EXCLUDE_CST(NODE) NODE->gsbase.intfns_stmt_exclude_cst_flag
+#define INTFNS_STMT_EXCLUDE_UNUSE(NODE) NODE->gsbase.intfns_stmt_exclude_unuse_flag
+#define INTFNS_STMT_EXCLUDE_UNCRITICAL_USE(NODE) NODE->gsbase.intfns_stmt_exclude_uncritical_use_flag
+#define INTFNS_STMT_EXCLUDE_SANTZ_POST(NODE) NODE->gsbase.intfns_stmt_exclude_santz_post_flag
+#define INTFNS_STMT_EXCLUDE_BIT(NODE) NODE->gsbase.intfns_stmt_exclude_bit_flag
+#define INTFNS_STMT_EXCLUDE_NARROW(NODE) NODE->gsbase.intfns_stmt_exclude_narrow_flag
+
+/*----------------------------------------------------------------------*/
+/*---------------------------3. cst propagation ---------------------------*/
+/*----------------------------------------------------------------------*/
+/* used to tag whether the corresponding TREE NODE is CST or not */
+#define INTFNS_TREE_NODE_CST(NODE) ((NODE)->base.intfns_cst_flag)
+
+
+/*----------------------------------------------------------------------*/
+/*---------------------------4. dep analysis--- ---------------------------*/
+/*----------------------------------------------------------------------*/
+/* 4 bits (gimple.h:310): used to tag whether an intop is implicit or not */
+#define INTFNS_INTOP_IMPLICIT_TYPE(NODE) NODE->gsbase.intfns_intop_implicit_flag
+#define INTFNS_INTOP_IMPLICIT_ADD_USU 1
+#define INTFNS_INTOP_IMPLICIT_ADD_UUS 2
+#define INTFNS_INTOP_IMPLICIT_ADD_SSU 3
+#define INTFNS_INTOP_IMPLICIT_ADD_SUS 4
+
+#define INTFNS_INTOP_IMPLICIT_SUB_SSU 5
+#define INTFNS_INTOP_IMPLICIT_SUB_USU 6
+#define INTFNS_INTOP_IMPLICIT_SUB_SUS 7
+#define INTFNS_INTOP_IMPLICIT_SUB_UUS 8
+
+#define INTFNS_INTOP_IMPLICIT_MUL_USU 9
+#define INTFNS_INTOP_IMPLICIT_MUL_SSU 10
+#define INTFNS_INTOP_IMPLICIT_MUL_UUS 11
+#define INTFNS_INTOP_IMPLICIT_MUL_SUS 12
+
+#define INTFNS_INTOP_IMPLICIT_SUB_SUU 13
+
+#define INTFNS_SIGN_CAST_IN_IMPLICIT(NODE) NODE->gsbase.intfns_intop_implicit_flag
+
+/* 1 bit (gimple.h: 310): used to tag this sign cast is useless */
+#define INTFNS_SIGN_CAST_USELESS(NODE) NODE->gsbase.intfns_signcast_useless_flag
+
+/* 1 bit (gimple.h:310): used to tag this intop flows into sinks. */
+#define INTFNS_STMT_INTO_SINK(NODE) NODE->gsbase.intfns_stmt_sink_flag
+
+/* 1 bit (gimple.h:310): used to tag this intop flows into RET. */
+#define INTFNS_STMT_INTO_RET(NODE) NODE->gsbase.intfns_stmt_ret_flag
+
+/* 2 bits (gimple.h) used to tag the status of IntEquiv */
+#define INTFNS_INTOP_POOL_STATUS(NODE) NODE->gsbase.intfns_intop_equiv_pool_flag
+#define UN_ANALYZED 0
+#define IN_POOL 1
+#define FAIL_PROPAGATE 2
+
+/* 5 bits used to tag the number of TAILS of an intop: at most 31*/
+#define INTFNS_INTOP_TAILS(NODE) NODE->gsbase.intfns_intop_equiv_tail_flag
+
+/*------------------------------------*/
+/* used at inter-procedure dep analysis
+define an vector type for struct function* */
+/*typedef struct function * intfns_func;
+DEF_VEC_P (intfns_func);
+DEF_VEC_ALLOC_P(intfns_func, gc);*/
+
+
+/* 1 bit (gimple.h:310): used to tag status of propagate,
+	0: not being analyzed, 1: being analyzed */
+#define INTFNS_PROPAGATE_STATUS(NODE) NODE->gsbase.intfns_stmt_being_analyzed_flag
+#define INTFNS_PROPAGATE_NOT_IN_ANALYZED_LIST 0
+#define INTFNS_PROPAGATE_IN_ANALYZED_LIST 1
+
+/*----------------------------------------------------------------------*/
+/*-------------------5. instrument module helpers.------ --------------------*/
+/*----------------------------------------------------------------------*/
+
+/* Global function decls used as handlers.  */
+/* extern void intfns_io_printer_xx (char* loc, tree rhs1, tree rhs2, tree print_type);  */
+static tree intfns_io_printer_8_fndecl;
+static tree intfns_io_printer_16_fndecl;
+static tree intfns_io_printer_32_fndecl;
+static tree intfns_io_printer_64_fndecl;
+/* extern void intfns_io_counter (char* loc, tree print_type);  */
+static tree intfns_io_counter_fndecl;
+/* extern void intfns_signcast_printer_xx (char* loc, tree rhs1, tree print_type);  */
+static tree intfns_signcast_printer_8_fndecl;
+static tree intfns_signcast_printer_16_fndecl;
+static tree intfns_signcast_printer_32_fndecl;
+static tree intfns_signcast_printer_64_fndecl;
+/* extern void intfns_signcast_counter (char* loc, tree print_type);  */
+static tree intfns_signcast_counter_fndecl;
+
+/* extern void intfns_io_nop (void);  */
+static tree intfns_io_nop_fndecl;
+/* extern void intfns_insert_init(void);  */
+static tree intfns_insert_init_fndecl;
+/* extern void intfns_insert_finish(void);  */
+static tree intfns_insert_finish_fndecl;
+
+/* Global values used in instrument-intop*/
+static tree intfns_smax_8, intfns_smin_8, intfns_umax_8, intfns_u_smin_8;
+static tree intfns_smax_16, intfns_smin_16, intfns_umax_16, intfns_u_smin_16;
+static tree intfns_smax_32, intfns_smin_32, intfns_umax_32, intfns_u_smin_32;
+static tree intfns_smax_64, intfns_smin_64, intfns_umax_64, intfns_u_smin_64;
+
+/* static mask */
+#define MASK_IMPLICIT 0x1
+#define MASK_CST 0x10
+#define MASK_UNUSE 0x100
+#define MASK_UNCRITICAL 0x1000
+#define MASK_SANTZ 0x10000
+#define MASK_BIT 0x100000
+#define MASK_NARROW 0x1000000
+
+/*----------------------------------------------------------------------*/
+/*-------------------6. integer overflow locations.------ --------------------*/
+/*----------------------------------------------------------------------*/
+
+#define MAX_NAME_LENGTH 128
+struct intfns_ios_node
+{
+	char filename[MAX_NAME_LENGTH];
+	int lineno;
+	int colno;	// column no.
+	int sign;	// 1: unsigned, 2: signed
+	int op;		// 1: add, 2: sub, 3: mul, 4: shl
+};
+
+/* global var to store integer overflows*/
+struct intfns_ios_node io_info[] = 
+{
+	#include "/tmp/ios.def"
+};
+
+unsigned int io_num;// = 0;	// to indicate the number of INTEGER OVERFLOWS
+
+
+/* used to tag whether the INTOP overflows according to the reports from third-party tool */
+/* gimple.h:310 */
+#define INTFNS_INTOP_OVF(NODE) NODE->gsbase.intfns_intop_ovf_flag
+
+
+
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-sink-lib-specs.def /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-sink-lib-specs.def
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-sink-lib-specs.def	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-sink-lib-specs.def	2014-05-27 16:03:36.000000000 -0400
@@ -0,0 +1,93 @@
+/*this file is used to specify the sinks, where overflow data might be exploited.
+specifically, there are about 5 kinds of integer sinks.
+	1.array index
+	2.pointer offset
+	3.while
+	4.memory operations
+	5.if-condition
+here, we just give detailed cases for 4th sinks-memory operations.
+
+struct intfns_func_specs_node
+{
+	char name[MAX_NAME_LENGTH];
+	int arg;
+};
+*/
+
+/* void bcopy(const void *src, void *dest, int n); */
+{
+	"bcopy",
+	2
+},
+
+/* void bzero(void *s, int n); */
+{
+	"bzero",
+	1
+},
+
+/* void *calloc(int num_elems, int elem_size); */
+{
+	"calloc",
+	0
+},
+
+/* void *malloc(unsigned int num_bytes); */ 
+{
+	"malloc",
+	0
+},
+
+/* void *memmove(void *dest, const void *src, unsigned int count); */ 
+{
+	"memmove",
+	2
+},
+
+/* void *memset(void *s,  int c, size_t n); */ 
+{
+	"memset",
+	2
+},
+
+/* void *memcpy(void *dest, void *src, unsigned int count); */
+{
+	"memcpy",
+	2
+},
+
+/* void movmem(void *src, void *dest, unsigned int count); */
+{
+	"movmem",
+	2
+},
+
+/* void *realloc(void *mem_address, unsigned int newsize); */
+{
+	"realloc",
+	1
+},
+
+/* char *strncat(char *dest,char *src, int n); */ 
+{
+	"strncat",
+	2
+},
+
+/* char *strncpy(char *destin, char *source, int maxlen); */ 
+{
+	"strncpy",
+	2
+},
+
+/* void swab(char *from, char *to, int nbytes); */ 
+{
+	"swab",
+	2
+},
+
+/* char/int... * new[] */
+{
+	"operator new []",
+	0
+}
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-sink-lib-specs.def~ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-sink-lib-specs.def~
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/intfns-sink-lib-specs.def~	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/intfns-sink-lib-specs.def~	2014-05-07 19:37:03.000000000 -0400
@@ -0,0 +1,71 @@
+/*this file is used to specify the sinks, where overflow data might be exploited.
+specifically, there are about 5 kinds of integer sinks.
+	1.array index
+	2.pointer offset
+	3.while
+	4.memory operations
+	5.if-condition
+here, we just give detailed cases for 4th sinks-memory operations.
+
+struct intfns_sink_lib_specs_node
+{
+	char name[MAX_NAME_LENGTH];
+	int arg;
+};
+*/
+
+/* void bcopy(const void *src, void *dest, int n); */
+{
+	"bcopy",
+	2
+},
+
+/* void bzero(void *s, int n); */
+{
+	"bzero",
+	1
+},
+
+/* void *calloc(int num_elems, int elem_size); */
+{
+	"calloc",
+	0
+},
+
+/* void *malloc(unsigned int num_bytes); */ 
+{
+	"malloc",
+	0
+},
+
+/* void *memmove(void *dest, const void *src, unsigned int count); */ 
+{
+	"memmove",
+	2
+},
+
+/* void *memset(void *s,  int c, size_t n); */ 
+{
+	"memset",
+	2
+},
+
+/* void *memcpy(void *dest, void *src, unsigned int count); */
+{
+	"memcpy",
+	2
+},
+
+/* void movmem(void *src, void *dest, unsigned int count); */
+{
+	"movmem",
+	2
+},
+
+/* void *realloc(void *mem_address, unsigned int newsize); */ 2nd param
+
+/* char *strncat(char *dest,char *src, int n); */ 3rd param
+
+/* char *strncpy(char *destin, char *source, int maxlen); */ 3rd param
+
+/* void swab(char *from, char *to, int nbytes); */ 3rd param
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/Makefile.in /home/haosun/intchecker/gcc-4.5.0/gcc/Makefile.in
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/Makefile.in	2010-04-02 03:49:06.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/Makefile.in	2014-05-05 08:23:50.000000000 -0400
@@ -1226,6 +1226,7 @@
 	init-regs.o \
 	integrate.o \
 	intl.o \
+	intfns.o \
 	ira.o \
 	ira-build.o \
 	ira-costs.o \
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/Makefile.in~ /home/haosun/intchecker/gcc-4.5.0/gcc/Makefile.in~
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/Makefile.in~	1969-12-31 19:00:00.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/Makefile.in~	2010-04-02 03:49:06.000000000 -0400
@@ -0,0 +1,4962 @@
+# Makefile for GNU Compiler Collection
+# Run 'configure' to generate Makefile from Makefile.in
+
+# Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
+# 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
+# 2008, 2009, 2010 Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify
+#it under the terms of the GNU General Public License as published by
+#the Free Software Foundation; either version 3, or (at your option)
+#any later version.
+
+#GCC is distributed in the hope that it will be useful,
+#but WITHOUT ANY WARRANTY; without even the implied warranty of
+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#GNU General Public License for more details.
+
+#You should have received a copy of the GNU General Public License
+#along with GCC; see the file COPYING3.  If not see
+#<http://www.gnu.org/licenses/>.
+
+# The targets for external use include:
+# all, doc, install, install-cross, install-cross-rest,
+# uninstall, TAGS, mostlyclean, clean, distclean, maintainer-clean.
+
+# This is the default target.
+# Set by autoconf to "all.internal" for a native build, or
+# "all.cross" to build a cross compiler.
+all: @ALL@
+
+# Depend on this to specify a phony target portably.
+force:
+
+# This tells GNU make version 3 not to export the variables
+# defined in this file into the environment (and thus recursive makes).
+.NOEXPORT:
+# And this tells it not to automatically pass command-line variables
+# to recursive makes.
+MAKEOVERRIDES =
+
+# Suppress smart makes who think they know how to automake yacc and flex file
+.y.c:
+.l.c:
+
+# The only suffixes we want for implicit rules are .c and .o, so clear
+# the list and add them.  This speeds up GNU Make, and allows -r to work.
+# For i18n support, we also need .gmo, .po, .pox.
+# This must come before the language makefile fragments to allow them to
+# add suffixes and rules of their own.
+.SUFFIXES:
+.SUFFIXES: .c .o .po .pox .gmo
+
+# -------------------------------
+# Standard autoconf-set variables
+# -------------------------------
+
+build=@build@
+host=@host@
+target=@target@
+target_noncanonical:=@target_noncanonical@
+
+# Sed command to transform gcc to installed name.
+program_transform_name := @program_transform_name@
+
+# -----------------------------
+# Directories used during build
+# -----------------------------
+
+# Directory where sources are, from where we are.
+srcdir = @srcdir@
+gcc_docdir = @srcdir@/doc
+
+# Directory where sources are, absolute.
+abs_srcdir = @abs_srcdir@
+abs_docdir = @abs_srcdir@/doc
+
+# Top build directory for this package, relative to here.
+top_builddir = .
+
+# The absolute path to the current directory.
+objdir := $(shell pwd)
+
+host_subdir=@host_subdir@
+build_subdir=@build_subdir@
+target_subdir=@target_subdir@
+build_libsubdir=@build_libsubdir@
+
+# Top build directory for the "Cygnus tree", relative to $(top_builddir).
+ifeq ($(host_subdir),.)
+toplevel_builddir := ..
+else
+toplevel_builddir := ../..
+endif
+
+build_objdir := $(toplevel_builddir)/$(build_subdir)
+build_libobjdir := $(toplevel_builddir)/$(build_libsubdir)
+target_objdir := $(toplevel_builddir)/$(target_subdir)
+
+# --------
+# Defined vpaths
+# --------
+
+# Directory where sources are, from where we are.
+VPATH = @srcdir@
+
+# We define a vpath for the sources of the .texi files here because they
+# are split between multiple directories and we would rather use one implicit
+# pattern rule for everything.
+# This vpath could be extended within the Make-lang fragments.
+
+vpath %.texi $(gcc_docdir)
+vpath %.texi $(gcc_docdir)/include
+
+# --------
+# UNSORTED
+# --------
+
+# Variables that exist for you to override.
+# See below for how to change them for certain systems.
+
+# List of language subdirectories.
+SUBDIRS =@subdirs@ build
+
+# Selection of languages to be made.
+CONFIG_LANGUAGES = @all_selected_languages@
+LANGUAGES = c gcov$(exeext) gcov-dump$(exeext) $(CONFIG_LANGUAGES)
+
+# Default values for variables overridden in Makefile fragments.
+# CFLAGS is for the user to override to, e.g., do a cross build with -O2.
+# TCFLAGS is used for compilations with the GCC just built.
+# T_CFLAGS is used for all compilations and is overridden by t-* files.
+T_CFLAGS =
+TCFLAGS =
+CFLAGS = @CFLAGS@
+CXXFLAGS = @CXXFLAGS@
+LDFLAGS = @LDFLAGS@
+
+# Flags to determine code coverage. When coverage is disabled, this will
+# contain the optimization flags, as you normally want code coverage
+# without optimization.
+COVERAGE_FLAGS = @coverage_flags@
+coverageexts = .{gcda,gcno}
+
+# The warning flags are separate from CFLAGS because people tend to
+# override optimization flags and we'd like them to still have warnings
+# turned on.  These flags are also used to pass other stage dependent
+# flags from configure.  The user is free to explicitly turn these flags
+# off if they wish.
+# LOOSE_WARN are the warning flags to use when compiling something
+# which is only compiled with gcc, such as libgcc.
+# C_LOOSE_WARN is similar, but with C-only warnings.
+# STRICT_WARN are the additional warning flags to
+# apply to the back end and some front ends, which may be compiled
+# with other compilers.
+# C_STRICT_WARN is similar, with C-only warnings.
+LOOSE_WARN = @loose_warn@
+C_LOOSE_WARN = @c_loose_warn@
+STRICT_WARN = @strict_warn@
+C_STRICT_WARN = @c_strict_warn@
+
+# This is set by --enable-checking.  The idea is to catch forgotten
+# "extern" tags in header files.
+NOCOMMON_FLAG = @nocommon_flag@
+
+# This is set by --disable-maintainer-mode (default) to "#"
+MAINT := @MAINT@
+
+# These are set by --enable-checking=valgrind.
+RUN_GEN = @valgrind_command@
+VALGRIND_DRIVER_DEFINES = @valgrind_path_defines@
+
+# This is how we control whether or not the additional warnings are applied.
+.-warn = $(STRICT_WARN)
+build-warn = $(STRICT_WARN)
+GCC_WARN_CFLAGS = $(LOOSE_WARN) $(C_LOOSE_WARN) $($(@D)-warn) $(if $(filter-out $(STRICT_WARN),$($(@D)-warn)),,$(C_STRICT_WARN)) $(NOCOMMON_FLAG) $($@-warn)
+GCC_WARN_CXXFLAGS = $(LOOSE_WARN) $($(@D)-warn) $(NOCOMMON_FLAG) $($@-warn)
+
+# These files are to have specific diagnostics suppressed, or are not to
+# be subject to -Werror:
+# flex output may yield harmless "no previous prototype" warnings
+build/gengtype-lex.o-warn = -Wno-error
+# mips-tfile.c contains -Wcast-qual warnings.
+mips-tfile.o-warn = -Wno-error
+
+# All warnings have to be shut off in stage1 if the compiler used then
+# isn't gcc; configure determines that.  WARN_CFLAGS will be either
+# $(GCC_WARN_CFLAGS), or nothing.  Similarly, WARN_CXXFLAGS will be
+# either $(GCC_WARN_CXXFLAGS), or nothing.
+WARN_CFLAGS = @warn_cflags@
+WARN_CXXFLAGS = @warn_cxxflags@
+
+CPPFLAGS = @CPPFLAGS@
+
+AWK = @AWK@
+CC = @CC@
+CXX = @CXX@
+BISON = @BISON@
+BISONFLAGS =
+FLEX = @FLEX@
+FLEXFLAGS =
+AR = @AR@
+AR_FLAGS = rc
+NM = @NM@
+RANLIB = @RANLIB@
+RANLIB_FLAGS = @ranlib_flags@
+
+# Libraries to use on the host.
+HOST_LIBS = @HOST_LIBS@
+
+# The name of the compiler to use.
+ENABLE_BUILD_WITH_CXX = @ENABLE_BUILD_WITH_CXX@
+ifneq ($(ENABLE_BUILD_WITH_CXX),yes)
+COMPILER = $(CC)
+COMPILER_FLAGS = $(CFLAGS)
+LINKER = $(CC)
+LINKER_FLAGS = $(CFLAGS)
+else
+COMPILER = $(CXX)
+COMPILER_FLAGS = $(CXXFLAGS)
+# If HOST_LIBS is set, then the user is controlling the libraries to
+# link against.  In that case, link with $(CC) so that the -lstdc++
+# library is not introduced.  If HOST_LIBS is not set, link with
+# $(CXX) to pick up -lstdc++.
+ifeq ($(HOST_LIBS),)
+LINKER = $(CXX)
+LINKER_FLAGS = $(CXXFLAGS)
+else
+LINKER = $(CC)
+LINKER_FLAGS = $(CFLAGS)
+endif
+endif
+
+# -------------------------------------------
+# Programs which operate on the build machine
+# -------------------------------------------
+
+SHELL = @SHELL@
+# pwd command to use.  Allow user to override default by setting PWDCMD in
+# the environment to account for automounters.  The make variable must not
+# be called PWDCMD, otherwise the value set here is passed to make
+# subprocesses and overrides the setting from the user's environment.
+# Don't use PWD since it is a common shell environment variable and we
+# don't want to corrupt it.
+PWD_COMMAND = $${PWDCMD-pwd}
+# on sysV, define this as cp.
+INSTALL = @INSTALL@
+# Some systems may be missing symbolic links, regular links, or both.
+# Allow configure to check this and use "ln -s", "ln", or "cp" as appropriate.
+LN=@LN@
+LN_S=@LN_S@
+# These permit overriding just for certain files.
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL@
+MAKEINFO = @MAKEINFO@
+MAKEINFOFLAGS = --no-split
+TEXI2DVI = texi2dvi
+TEXI2PDF = texi2pdf
+TEXI2HTML = $(MAKEINFO) --html
+TEXI2POD = perl $(srcdir)/../contrib/texi2pod.pl
+POD2MAN = pod2man --center="GNU" --release="gcc-$(version)"
+# Some versions of `touch' (such as the version on Solaris 2.8)
+# do not correctly set the timestamp due to buggy versions of `utime'
+# in the kernel.  So, we use `echo' instead.
+STAMP = echo timestamp >
+# If necessary (e.g., when using the MSYS shell on Microsoft Windows)
+# translate the shell's notion of absolute pathnames to the native
+# spelling.
+build_file_translate = @build_file_translate@
+
+# Make sure the $(MAKE) variable is defined.
+@SET_MAKE@
+
+# Locate mkinstalldirs.
+mkinstalldirs=$(SHELL) $(srcdir)/../mkinstalldirs
+
+# write_entries_to_file - writes each entry in a list
+# to the specified file.  Entries are written in chunks of
+# $(write_entries_to_file_split) to accomodate systems with
+# severe command-line-length limitations.
+# Parameters:
+# $(1): variable containing entries to iterate over
+# $(2): output file
+write_entries_to_file_split = 50
+write_entries_to_file = $(shell rm -f $(2) || :) $(shell touch $(2)) \
+	$(foreach range, \
+	  $(shell i=1; while test $$i -le $(words $(1)); do \
+	     echo $$i; i=`expr $$i + $(write_entries_to_file_split)`; done), \
+	  $(shell echo "$(wordlist $(range), \
+			  $(shell expr $(range) + $(write_entries_to_file_split) - 1), $(1))" \
+	     | tr ' ' '\012' >> $(2)))
+
+# --------
+# UNSORTED
+# --------
+
+# Some compilers can't handle cc -c blah.c -o foo/blah.o.
+# In stage2 and beyond, we force this to "-o $@" since we know we're using gcc.
+OUTPUT_OPTION = @OUTPUT_OPTION@
+
+# This is where we get zlib from.  zlibdir is -L../zlib and zlibinc is
+# -I../zlib, unless we were configured with --with-system-zlib, in which
+# case both are empty.
+ZLIB = @zlibdir@ -lz
+ZLIBINC = @zlibinc@
+
+# How to find GMP
+GMPLIBS = @GMPLIBS@
+GMPINC = @GMPINC@
+
+# How to find PPL
+PPLLIBS = @PPLLIBS@
+PPLINC = @PPLINC@
+
+# How to find CLOOG
+CLOOGLIBS = @CLOOGLIBS@
+CLOOGINC = @CLOOGINC@
+
+# How to find libelf
+LIBELFLIBS = @LIBELFLIBS@
+LIBELFINC = @LIBELFINC@
+
+# Set to 'yes' if the LTO front end is enabled.
+enable_lto = @enable_lto@
+
+# Compiler needed for plugin support
+PLUGINCC = @CC@
+
+# Flags needed for plugin support
+PLUGINCFLAGS = @CFLAGS@
+
+# Libs and linker options needed for plugin support
+PLUGINLIBS = @pluginlibs@
+
+enable_plugin = @enable_plugin@
+
+CPPLIB = ../libcpp/libcpp.a
+CPPINC = -I$(srcdir)/../libcpp/include
+
+# Where to find decNumber
+enable_decimal_float = @enable_decimal_float@
+DECNUM = $(srcdir)/../libdecnumber
+DECNUMFMT = $(srcdir)/../libdecnumber/$(enable_decimal_float)
+DECNUMINC = -I$(DECNUM) -I$(DECNUMFMT) -I../libdecnumber
+LIBDECNUMBER = ../libdecnumber/libdecnumber.a
+
+# Target to use when installing include directory.  Either
+# install-headers-tar, install-headers-cpio or install-headers-cp.
+INSTALL_HEADERS_DIR = @build_install_headers_dir@
+
+# Header files that are made available under the same name
+# to programs compiled with GCC.
+USER_H = $(srcdir)/ginclude/float.h \
+	 $(srcdir)/ginclude/iso646.h \
+	 $(srcdir)/ginclude/stdarg.h \
+	 $(srcdir)/ginclude/stdbool.h \
+	 $(srcdir)/ginclude/stddef.h \
+	 $(srcdir)/ginclude/varargs.h \
+	 $(srcdir)/ginclude/stdfix.h \
+	 $(EXTRA_HEADERS)
+
+UNWIND_H = $(srcdir)/unwind-generic.h
+
+# The GCC to use for compiling crt*.o.
+# Usually the one we just built.
+# Don't use this as a dependency--use $(GCC_PASSES).
+GCC_FOR_TARGET = $(STAGE_CC_WRAPPER) ./xgcc -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include -L$(objdir)/../ld
+
+# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.
+# It specifies -B./.
+# It also specifies -isystem ./include to find, e.g., stddef.h.
+GCC_CFLAGS=$(CFLAGS_FOR_TARGET) $(INTERNAL_CFLAGS) $(T_CFLAGS) $(LOOSE_WARN) $(C_LOOSE_WARN) -Wold-style-definition $($@-warn) -isystem ./include $(TCFLAGS)
+
+# ---------------------------------------------------
+# Programs which produce files for the target machine
+# ---------------------------------------------------
+
+AR_FOR_TARGET := $(shell \
+  if [ -f $(objdir)/../binutils/ar ] ; then \
+    echo $(objdir)/../binutils/ar ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo $(AR); \
+    else \
+       t='$(program_transform_name)'; echo ar | sed -e $$t ; \
+    fi; \
+  fi)
+AR_FLAGS_FOR_TARGET =
+AR_CREATE_FOR_TARGET = $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) rc
+AR_EXTRACT_FOR_TARGET = $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) x
+LIPO_FOR_TARGET = lipo
+ORIGINAL_AS_FOR_TARGET = @ORIGINAL_AS_FOR_TARGET@
+RANLIB_FOR_TARGET := $(shell \
+  if [ -f $(objdir)/../binutils/ranlib ] ; then \
+    echo $(objdir)/../binutils/ranlib ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo $(RANLIB); \
+    else \
+       t='$(program_transform_name)'; echo ranlib | sed -e $$t ; \
+    fi; \
+  fi)
+ORIGINAL_LD_FOR_TARGET = @ORIGINAL_LD_FOR_TARGET@
+ORIGINAL_NM_FOR_TARGET = @ORIGINAL_NM_FOR_TARGET@
+NM_FOR_TARGET = ./nm
+STRIP_FOR_TARGET := $(shell \
+  if [ -f $(objdir)/../binutils/strip ] ; then \
+    echo $(objdir)/../binutils/strip ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo strip; \
+    else \
+       t='$(program_transform_name)'; echo strip | sed -e $$t ; \
+    fi; \
+  fi)
+
+# --------
+# UNSORTED
+# --------
+
+# Where to find some libiberty headers.
+HASHTAB_H   = $(srcdir)/../include/hashtab.h
+OBSTACK_H   = $(srcdir)/../include/obstack.h
+SPLAY_TREE_H= $(srcdir)/../include/splay-tree.h
+FIBHEAP_H   = $(srcdir)/../include/fibheap.h
+PARTITION_H = $(srcdir)/../include/partition.h
+MD5_H	    = $(srcdir)/../include/md5.h
+DWARF2_H    = $(srcdir)/../include/dwarf2.h
+
+# Linker plugin API headers
+LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h
+LTO_SYMTAB_H = $(srcdir)/../include/lto-symtab.h
+
+# Default native SYSTEM_HEADER_DIR, to be overridden by targets.
+NATIVE_SYSTEM_HEADER_DIR = /usr/include
+# Default cross SYSTEM_HEADER_DIR, to be overridden by targets.
+CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@
+
+# autoconf sets SYSTEM_HEADER_DIR to one of the above.
+# Purge it of unneccessary internal relative paths
+# to directories that might not exist yet.
+# The sed idiom for this is to repeat the search-and-replace until it doesn't match, using :a ... ta.
+# Use single quotes here to avoid nested double- and backquotes, this
+# macro is also used in a double-quoted context.
+SYSTEM_HEADER_DIR = `echo @SYSTEM_HEADER_DIR@ | sed -e :a -e 's,[^/]*/\.\.\/,,' -e ta`
+
+# Control whether to run fixincludes.
+STMP_FIXINC = @STMP_FIXINC@
+
+# Test to see whether <limits.h> exists in the system header files.
+LIMITS_H_TEST = [ -f $(SYSTEM_HEADER_DIR)/limits.h ]
+
+# Directory for prefix to system directories, for
+# each of $(system_prefix)/usr/include, $(system_prefix)/usr/lib, etc.
+TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
+
+xmake_file=@xmake_file@
+tmake_file=@tmake_file@
+TM_ENDIAN_CONFIG=@TM_ENDIAN_CONFIG@
+TM_MULTILIB_CONFIG=@TM_MULTILIB_CONFIG@
+TM_MULTILIB_EXCEPTIONS_CONFIG=@TM_MULTILIB_EXCEPTIONS_CONFIG@
+out_file=$(srcdir)/config/@out_file@
+out_object_file=@out_object_file@
+md_file=$(srcdir)/config/@md_file@
+tm_file_list=@tm_file_list@
+tm_include_list=@tm_include_list@
+tm_defines=@tm_defines@
+tm_p_file_list=@tm_p_file_list@
+tm_p_include_list=@tm_p_include_list@
+build_xm_file_list=@build_xm_file_list@
+build_xm_include_list=@build_xm_include_list@
+build_xm_defines=@build_xm_defines@
+host_xm_file_list=@host_xm_file_list@
+host_xm_include_list=@host_xm_include_list@
+host_xm_defines=@host_xm_defines@
+xm_file_list=@xm_file_list@
+xm_include_list=@xm_include_list@
+xm_defines=@xm_defines@
+lang_checks=check-gcc
+lang_checks_parallelized=check-gcc
+# This lists a couple of test files that take most time during check-gcc.
+# When doing parallelized check-gcc, these can run in parallel with the
+# remaining tests.  Each word in this variable stands for work for one
+# make goal and one extra make goal is added to handle all the *.exp
+# files not handled explicitly already.  If multiple *.exp files
+# should be run in the same runtest invocation (usually if they aren't
+# very long running, but still should be split of from the check-parallel-$lang
+# remaining tests runtest invocation), they should be concatenated with commas.
+# Note that [a-zA-Z] wildcards need to have []s prefixed with \ (needed
+# by tcl) and as the *.exp arguments are mached both as is and with
+# */ prefixed to it in runtest_file_p, it is usually desirable to include
+# a subdirectory name.
+check_gcc_parallelize=execute.exp=execute/2* \
+		      execute.exp=execute/\[013-9a-zA-Z\]* \
+		      compile.exp dg.exp \
+		      dg-torture.exp,builtins.exp \
+		      struct-layout-1.exp,unsorted.exp,stackalign.exp,i386.exp
+lang_opt_files=@lang_opt_files@ $(srcdir)/c.opt $(srcdir)/common.opt
+lang_specs_files=@lang_specs_files@
+lang_tree_files=@lang_tree_files@
+target_cpu_default=@target_cpu_default@
+GCC_THREAD_FILE=@thread_file@
+OBJC_BOEHM_GC=@objc_boehm_gc@
+GTHREAD_FLAGS=@gthread_flags@
+extra_modes_file=@extra_modes_file@
+extra_opt_files=@extra_opt_files@
+host_hook_obj=@out_host_hook_obj@
+
+# ------------------------
+# Installation directories
+# ------------------------
+
+# Common prefix for installation directories.
+# NOTE: This directory must exist when you start installation.
+prefix = @prefix@
+# Directory in which to put localized header files. On the systems with
+# gcc as the native cc, `local_prefix' may not be `prefix' which is
+# `/usr'.
+# NOTE: local_prefix *should not* default from prefix.
+local_prefix = @local_prefix@
+# Directory in which to put host dependent programs and libraries
+exec_prefix = @exec_prefix@
+# Directory in which to put the executable for the command `gcc'
+bindir = @bindir@
+# Directory in which to put the directories used by the compiler.
+libdir = @libdir@
+# Directory in which GCC puts its executables.
+libexecdir = @libexecdir@
+
+# --------
+# UNSORTED
+# --------
+
+# Directory in which the compiler finds libraries etc.
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(version)
+# Directory in which the compiler finds executables
+libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(version)
+# Directory in which plugin headers are installed
+plugin_includedir = $(libsubdir)/plugin/include
+# Used to produce a relative $(gcc_tooldir) in gcc.o
+unlibsubdir = ../../..
+# $(prefix), expressed as a path relative to $(libsubdir).
+#
+# An explanation of the sed strings:
+#  -e 's|^$(prefix)||'   matches and eliminates 'prefix' from 'exec_prefix'
+#  -e 's|/$$||'          match a trailing forward slash and eliminates it
+#  -e 's|^[^/]|/|'       forces the string to start with a forward slash (*)
+#  -e 's|/[^/]*|../|g'   replaces each occurrence of /<directory> with ../
+#
+# (*) Note this pattern overwrites the first character of the string
+# with a forward slash if one is not already present.  This is not a
+# problem because the exact names of the sub-directories concerned is
+# unimportant, just the number of them matters.
+#
+# The practical upshot of these patterns is like this:
+#
+#  prefix     exec_prefix        result
+#  ------     -----------        ------
+#   /foo        /foo/bar          ../
+#   /foo/       /foo/bar          ../
+#   /foo        /foo/bar/         ../
+#   /foo/       /foo/bar/         ../
+#   /foo        /foo/bar/ugg      ../../
+libsubdir_to_prefix := \
+  $(unlibsubdir)/$(shell echo "$(libdir)" | \
+    sed -e 's|^$(prefix)||' -e 's|/$$||' -e 's|^[^/]|/|' \
+        -e 's|/[^/]*|../|g')
+# $(exec_prefix), expressed as a path relative to $(prefix).
+prefix_to_exec_prefix := \
+  $(shell echo "$(exec_prefix)" | \
+    sed -e 's|^$(prefix)||' -e 's|^/||' -e '/./s|$$|/|')
+# Directory in which to find other cross-compilation tools and headers.
+dollar = @dollar@
+# Used in install-cross.
+gcc_tooldir = @gcc_tooldir@
+# Used to install the shared libgcc.
+slibdir = @slibdir@
+# Since gcc_tooldir does not exist at build-time, use -B$(build_tooldir)/bin/
+build_tooldir = $(exec_prefix)/$(target_noncanonical)
+# Directory in which the compiler finds target-independent g++ includes.
+gcc_gxx_include_dir = @gcc_gxx_include_dir@
+# Directory to search for site-specific includes.
+local_includedir = $(local_prefix)/include
+includedir = $(prefix)/include
+# where the info files go
+infodir = @infodir@
+# Where cpp should go besides $prefix/bin if necessary
+cpp_install_dir = @cpp_install_dir@
+# where the locale files go
+datadir = @datadir@
+localedir = $(datadir)/locale
+# Extension (if any) to put in installed man-page filename.
+man1ext = .1
+man7ext = .7
+objext = .o
+exeext = @host_exeext@
+build_exeext = @build_exeext@
+
+# Directory in which to put man pages.
+mandir = @mandir@
+man1dir = $(mandir)/man1
+man7dir = $(mandir)/man7
+# Dir for temp files.
+tmpdir = /tmp
+
+datarootdir = @datarootdir@
+docdir = @docdir@
+# Directory in which to build HTML
+build_htmldir = $(objdir)/HTML/gcc-$(version)
+# Directory in which to put HTML
+htmldir = @htmldir@
+
+# Whether we were configured with NLS.
+USE_NLS = @USE_NLS@
+
+# Internationalization library.
+LIBINTL = @LIBINTL@
+LIBINTL_DEP = @LIBINTL_DEP@
+
+# Character encoding conversion library.
+LIBICONV = @LIBICONV@
+LIBICONV_DEP = @LIBICONV_DEP@
+
+# The GC method to be used on this system.
+GGC=@GGC@.o
+
+# If a supplementary library is being used for the GC.
+GGC_LIB=
+
+# "true" if the target C library headers are unavailable; "false"
+# otherwise.
+inhibit_libc = @inhibit_libc@
+ifeq ($(inhibit_libc),true)
+INHIBIT_LIBC_CFLAGS = -Dinhibit_libc
+endif
+
+# Options to use when compiling libgcc2.a.
+#
+LIBGCC2_DEBUG_CFLAGS = -g
+LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) \
+		 $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) \
+		 -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED \
+		 $(INHIBIT_LIBC_CFLAGS)
+
+# Additional options to use when compiling libgcc2.a.
+# Some targets override this to -isystem include
+LIBGCC2_INCLUDES =
+
+# Additional target-dependent options for compiling libgcc2.a.
+TARGET_LIBGCC2_CFLAGS =
+
+# Options to use when compiling crtbegin/end.
+CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
+  -finhibit-size-directive -fno-inline -fno-exceptions \
+  -fno-zero-initialized-in-bss -fno-toplevel-reorder -fno-tree-vectorize \
+  $(INHIBIT_LIBC_CFLAGS)
+
+# Additional sources to handle exceptions; overridden by targets as needed.
+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
+   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
+LIB2ADDEHSTATIC = $(LIB2ADDEH)
+LIB2ADDEHSHARED = $(LIB2ADDEH)
+LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h
+
+# Don't build libunwind by default.
+LIBUNWIND =
+LIBUNWINDDEP =
+SHLIBUNWIND_LINK =
+SHLIBUNWIND_INSTALL =
+
+# nm flags to list global symbols in libgcc object files.
+SHLIB_NM_FLAGS = -pg
+
+# List of extra executables that should be compiled for this target machine
+# that are used for compiling from source code to object code.
+# The rules for compiling them should be in the t-* file for the machine.
+EXTRA_PASSES =@extra_passes@
+
+# Like EXTRA_PASSES, but these are used when linking.
+EXTRA_PROGRAMS = @extra_programs@
+
+# List of extra object files that should be compiled for this target machine.
+# The rules for compiling them should be in the t-* file for the machine.
+EXTRA_PARTS = @extra_parts@
+
+# List of extra object files that should be compiled and linked with
+# compiler proper (cc1, cc1obj, cc1plus).
+EXTRA_OBJS = @extra_objs@
+
+# List of extra object files that should be compiled and linked with
+# the gcc driver.
+EXTRA_GCC_OBJS =@extra_gcc_objs@
+
+# List of additional header files to install.
+EXTRA_HEADERS =@extra_headers_list@
+
+# How to handle <stdint.h>.
+USE_GCC_STDINT = @use_gcc_stdint@
+
+# The configure script will set this to collect2$(exeext), except on a
+# (non-Unix) host which can not build collect2, for which it will be
+# set to empty.
+COLLECT2 = @collect2@
+
+# List of extra C and assembler files to add to static and shared libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_EXTRA =
+
+# List of extra C and assembler files to add to static libgcc2.
+# Assembler files should have names ending in `.asm'.
+LIB2FUNCS_STATIC_EXTRA =
+
+# List of functions not to build from libgcc2.c.
+LIB2FUNCS_EXCLUDE =
+
+# Target sfp-machine.h file.
+SFP_MACHINE =
+
+# Program to convert libraries.
+LIBCONVERT =
+
+# Control whether header files are installed.
+INSTALL_HEADERS=install-headers install-mkheaders
+
+# Control whether Info documentation is built and installed.
+BUILD_INFO = @BUILD_INFO@
+
+# Control whether manpages generated by texi2pod.pl can be rebuilt.
+GENERATED_MANPAGES = @GENERATED_MANPAGES@
+
+# Additional directories of header files to run fixincludes on.
+# These should be directories searched automatically by default
+# just as /usr/include is.
+# *Do not* use this for directories that happen to contain
+# header files, but are not searched automatically by default.
+# On most systems, this is empty.
+OTHER_FIXINCLUDES_DIRS=
+
+# A list of all the language-specific executables.
+COMPILERS = cc1$(exeext) @all_compilers@
+
+# List of things which should already be built whenever we try to use xgcc
+# to compile anything (without linking).
+GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
+
+# Directory to link to, when using the target `maketest'.
+DIR = ../gcc
+
+# Native compiler for the build machine and its switches.
+CC_FOR_BUILD = @CC_FOR_BUILD@
+BUILD_CFLAGS= @BUILD_CFLAGS@ -DGENERATOR_FILE
+
+# Native compiler that we use.  This may be C++ some day.
+COMPILER_FOR_BUILD = $(CC_FOR_BUILD)
+BUILD_COMPILERFLAGS = $(BUILD_CFLAGS)
+
+# Native linker that we use.
+LINKER_FOR_BUILD = $(CC_FOR_BUILD)
+BUILD_LINKERFLAGS = $(BUILD_CFLAGS)
+
+# Native linker and preprocessor flags.  For x-fragment overrides.
+BUILD_LDFLAGS=@BUILD_LDFLAGS@
+BUILD_CPPFLAGS=$(ALL_CPPFLAGS)
+
+# Actual name to use when installing a native compiler.
+GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')
+GCC_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gcc|sed '$(program_transform_name)')
+CPP_INSTALL_NAME := $(shell echo cpp|sed '$(program_transform_name)')
+GCOV_INSTALL_NAME := $(shell echo gcov|sed '$(program_transform_name)')
+GCCBUG_INSTALL_NAME := $(shell echo gccbug|sed '$(program_transform_name)')
+
+# Setup the testing framework, if you have one
+EXPECT = `if [ -f $${rootme}/../expect/expect ] ; then \
+            echo $${rootme}/../expect/expect ; \
+          else echo expect ; fi`
+
+RUNTEST = `if [ -f $${srcdir}/../dejagnu/runtest ] ; then \
+	       echo $${srcdir}/../dejagnu/runtest ; \
+	    else echo runtest; fi`
+RUNTESTFLAGS =
+
+# Extra flags to use when compiling crt{begin,end}.o.
+CRTSTUFF_T_CFLAGS =
+
+# Extra flags to use when compiling [m]crt0.o.
+CRT0STUFF_T_CFLAGS =
+
+# "t" or nothing, for building multilibbed versions of, say, crtbegin.o.
+T =
+
+# Should T contain a `=', libgcc/Makefile will make T_TARGET, setting
+# $(T_TARGET) to the name of the actual target filename.
+T_TARGET =
+T_TARGET : $(T_TARGET)
+
+# This should name the specs file that we're going to install.  Target
+# Makefiles may override it and name another file to be generated from
+# the built-in specs and installed as the default spec, as long as
+# they also introduce a rule to generate a file name specs, to be used
+# at build time.
+SPECS = specs
+
+# End of variables for you to override.
+
+# GTM_H lists the config files that the generator files depend on,
+# while TM_H lists the ones ordinary gcc files depend on, which
+# includes several files generated by those generators.
+BCONFIG_H = bconfig.h $(build_xm_file_list)
+CONFIG_H  = config.h  $(host_xm_file_list)
+TCONFIG_H = tconfig.h $(xm_file_list)
+TM_P_H    = tm_p.h    $(tm_p_file_list)
+GTM_H     = tm.h      $(tm_file_list)
+TM_H      = $(GTM_H) insn-constants.h insn-flags.h options.h
+
+# Variables for version information.
+BASEVER     := $(srcdir)/BASE-VER  # 4.x.y
+DEVPHASE    := $(srcdir)/DEV-PHASE # experimental, prerelease, ""
+DATESTAMP   := $(srcdir)/DATESTAMP # YYYYMMDD or empty
+REVISION    := $(srcdir)/REVISION  # [BRANCH revision XXXXXX]
+
+BASEVER_c   := $(shell cat $(BASEVER))
+DEVPHASE_c  := $(shell cat $(DEVPHASE))
+DATESTAMP_c := $(shell cat $(DATESTAMP))
+
+ifeq (,$(wildcard $(REVISION)))
+REVISION_c  :=
+else
+REVISION_c  := $(shell cat $(REVISION))
+endif
+
+version     := $(BASEVER_c)
+
+# For use in version.c - double quoted strings, with appropriate
+# surrounding punctuation and spaces, and with the datestamp and
+# development phase collapsed to the empty string in release mode
+# (i.e. if DEVPHASE_c is empty).  The space immediately after the
+# comma in the $(if ...) constructs is significant - do not remove it.
+BASEVER_s   := "\"$(BASEVER_c)\""
+DEVPHASE_s  := "\"$(if $(DEVPHASE_c), ($(DEVPHASE_c)))\""
+DATESTAMP_s := "\"$(if $(DEVPHASE_c), $(DATESTAMP_c))\""
+PKGVERSION_s:= "\"@PKGVERSION@\""
+BUGURL_s    := "\"@REPORT_BUGS_TO@\""
+
+PKGVERSION  := @PKGVERSION@
+BUGURL_TEXI := @REPORT_BUGS_TEXI@
+
+ifdef REVISION_c
+REVISION_s  := "\"$(if $(DEVPHASE_c), $(REVISION_c))\""
+else
+REVISION_s  := "\"\""
+endif
+
+# Shorthand variables for dependency lists.
+EXCEPT_H = except.h sbitmap.h vecprim.h
+TOPLEV_H = toplev.h $(INPUT_H) bversion.h
+TARGET_H = $(TM_H) target.h insn-modes.h
+MACHMODE_H = machmode.h mode-classes.def insn-modes.h
+HOOKS_H = hooks.h $(MACHMODE_H)
+HOSTHOOKS_DEF_H = hosthooks-def.h $(HOOKS_H)
+LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)
+TARGET_DEF_H = target-def.h $(HOOKS_H) targhooks.h
+RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \
+  $(INPUT_H) $(REAL_H) statistics.h vec.h $(FIXED_VALUE_H) alias.h
+FIXED_VALUE_H = fixed-value.h $(MACHMODE_H) double-int.h
+RTL_H = $(RTL_BASE_H) genrtl.h
+PARAMS_H = params.h params.def
+BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def
+TREE_H = tree.h all-tree.def tree.def c-common.def $(lang_tree_files) \
+          $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \
+          $(INPUT_H) statistics.h vec.h treestruct.def $(HASHTAB_H) \
+          double-int.h alias.h $(SYMTAB_H) options.h
+BASIC_BLOCK_H = basic-block.h $(BITMAP_H) sbitmap.h varray.h $(PARTITION_H) \
+          hard-reg-set.h $(PREDICT_H) vec.h $(FUNCTION_H) \
+          cfghooks.h $(OBSTACK_H)
+GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h vec.h \
+	$(GGC_H) $(BASIC_BLOCK_H) $(TM_H) $(TARGET_H) tree-ssa-operands.h
+GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h
+COVERAGE_H = coverage.h $(GCOV_IO_H)
+DEMANGLE_H = $(srcdir)/../include/demangle.h
+RECOG_H = recog.h
+ALIAS_H = alias.h coretypes.h
+EMIT_RTL_H = emit-rtl.h
+FLAGS_H = flags.h coretypes.h options.h
+FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) vecprim.h
+EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)
+OPTABS_H = optabs.h insn-codes.h
+REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)
+RESOURCE_H = resource.h hard-reg-set.h
+SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) vecprim.h
+SEL_SCHED_IR_H = sel-sched-ir.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) \
+	$(GGC_H) $(BITMAP_H) vecprim.h $(SCHED_INT_H) $(CFGLOOP_H)
+SEL_SCHED_DUMP_H = sel-sched-dump.h $(SEL_SCHED_IR_H)
+INTEGRATE_H = integrate.h $(VARRAY_H)
+CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)
+CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H) vecprim.h double-int.h
+IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)
+IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)
+IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)
+CGRAPH_H = cgraph.h $(TREE_H) $(BASIC_BLOCK_H) cif-code.def
+DF_H = df.h $(BITMAP_H) $(BASIC_BLOCK_H) alloc-pool.h $(TIMEVAR_H)
+RESOURCE_H = resource.h hard-reg-set.h $(DF_H)
+DDG_H = ddg.h sbitmap.h $(DF_H)
+GCC_H = gcc.h version.h
+GGC_H = ggc.h gtype-desc.h statistics.h
+TIMEVAR_H = timevar.h timevar.def
+INSN_ATTR_H = insn-attr.h $(INSN_ADDR_H) $(srcdir)/varray.h
+INSN_ADDR_H = $(srcdir)/insn-addr.h vecprim.h
+C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H)
+C_PRAGMA_H = c-pragma.h $(CPPLIB_H)
+C_TREE_H = c-tree.h $(C_COMMON_H) $(TOPLEV_H) $(DIAGNOSTIC_H)
+SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h \
+	$(srcdir)/../include/safe-ctype.h $(srcdir)/../include/filenames.h
+PREDICT_H = predict.h predict.def
+CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \
+	$(srcdir)/../libcpp/include/cpplib.h
+INPUT_H = $(srcdir)/../libcpp/include/line-map.h input.h
+DECNUM_H = $(DECNUM)/decContext.h $(DECNUM)/decDPD.h $(DECNUM)/decNumber.h \
+	$(DECNUMFMT)/decimal32.h $(DECNUMFMT)/decimal64.h \
+	$(DECNUMFMT)/decimal128.h $(DECNUMFMT)/decimal128Local.h
+MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h
+SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)
+CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h
+CPP_INTERNAL_H = $(srcdir)/../libcpp/internal.h $(CPP_ID_DATA_H)
+TREE_PASS_H = tree-pass.h $(TIMEVAR_H)
+TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H) $(TREE_PASS_H)
+TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \
+		$(BITMAP_H) $(BASIC_BLOCK_H) hard-reg-set.h $(GIMPLE_H) \
+		$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H) \
+		tree-ssa-alias.h
+TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H) vecprim.h
+TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)
+SSAEXPAND_H = ssaexpand.h $(TREE_SSA_LIVE_H)
+PRETTY_PRINT_H = pretty-print.h $(INPUT_H) $(OBSTACK_H)
+DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H) options.h
+C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)
+SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)
+LAMBDA_H = lambda.h $(TREE_H) vec.h $(GGC_H)
+TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h graphds.h $(SCEV_H)
+VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)
+TREE_INLINE_H = tree-inline.h $(GIMPLE_H)
+REAL_H = real.h $(MACHMODE_H)
+IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h
+DBGCNT_H = dbgcnt.h dbgcnt.def
+EBITMAP_H = ebitmap.h sbitmap.h
+LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \
+		$(CGRAPH_H) vec.h vecprim.h $(TREE_H) $(GIMPLE_H)
+TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)
+IPA_PROP_H = ipa-prop.h $(TREE_H) vec.h $(CGRAPH_H)
+GSTAB_H = gstab.h stab.def
+BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h
+GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h $(CONFIG_H) $(SYSTEM_H) \
+		$(HASHTAB_H)
+PLUGIN_H = plugin.h $(GCC_PLUGIN_H)
+PLUGIN_VERSION_H = plugin-version.h configargs.h
+
+#
+# Now figure out from those variables how to compile and link.
+
+# IN_GCC distinguishes between code compiled into GCC itself and other
+# programs built during a bootstrap.
+# autoconf inserts -DCROSS_DIRECTORY_STRUCTURE if we are building a
+# cross compiler which does not use the native headers and libraries.
+INTERNAL_CFLAGS = -DIN_GCC @CROSS@
+
+# This is the variable actually used when we compile. If you change this,
+# you probably want to update BUILD_CFLAGS in configure.ac
+ALL_CFLAGS = $(T_CFLAGS) \
+  $(CFLAGS) $(INTERNAL_CFLAGS) $(COVERAGE_FLAGS) $(WARN_CFLAGS) @DEFS@
+
+# The C++ version.
+ALL_CXXFLAGS = $(T_CFLAGS) $(CXXFLAGS) $(INTERNAL_CFLAGS) \
+  $(COVERAGE_FLAGS) $(WARN_CXXFLAGS) @DEFS@
+
+# Likewise.  Put INCLUDES at the beginning: this way, if some autoconf macro
+# puts -I options in CPPFLAGS, our include files in the srcdir will always
+# win against random include files in /usr/include.
+ALL_CPPFLAGS = $(INCLUDES) $(CPPFLAGS)
+
+# This is the variable to use when using $(COMPILER).
+ifneq ($(ENABLE_BUILD_WITH_CXX),yes)
+ALL_COMPILERFLAGS = $(ALL_CFLAGS)
+else
+ALL_COMPILERFLAGS = $(ALL_CXXFLAGS)
+endif
+
+# This is the variable to use when using $(LINKER).
+ifneq ($(ENABLE_BUILD_WITH_CXX),yes)
+ALL_LINKERFLAGS = $(ALL_CFLAGS)
+else
+ALL_LINKERFLAGS = $(ALL_CXXFLAGS)
+endif
+
+# Build and host support libraries.
+LIBIBERTY = ../libiberty/libiberty.a
+BUILD_LIBIBERTY = $(build_libobjdir)/libiberty/libiberty.a
+
+# Dependencies on the intl and portability libraries.
+LIBDEPS= $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) $(LIBDECNUMBER)
+
+# Likewise, for use in the tools that must run on this machine
+# even if we are cross-building GCC.
+BUILD_LIBDEPS= $(BUILD_LIBIBERTY)
+
+# How to link with both our special library facilities
+# and the system's installed libraries.
+LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) \
+	$(HOST_LIBS)
+BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \
+	$(ZLIB) $(LIBELFLIBS)
+# Any system libraries needed just for GNAT.
+SYSLIBS = @GNAT_LIBEXC@
+
+# Used from ada/Make-lang.in
+GNATBIND = @GNATBIND@
+GNATMAKE = @GNATMAKE@
+
+# Libs needed (at present) just for jcf-dump.
+LDEXP_LIB = @LDEXP_LIB@
+
+# Likewise, for use in the tools that must run on this machine
+# even if we are cross-building GCC.
+BUILD_LIBS = $(BUILD_LIBIBERTY)
+
+BUILD_RTL = build/rtl.o build/read-rtl.o build/ggc-none.o build/vec.o \
+	    build/min-insn-modes.o build/gensupport.o build/print-rtl.o
+BUILD_ERRORS = build/errors.o
+
+# Specify the directories to be searched for header files.
+# Both . and srcdir are used, in that order,
+# so that *config.h will be found in the compilation
+# subdirectory rather than in the source directory.
+# -I$(@D) and -I$(srcdir)/$(@D) cause the subdirectory of the file
+# currently being compiled, in both source trees, to be examined as well.
+# libintl.h will be found in ../intl if we are using the included libintl.
+INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
+	   -I$(srcdir)/../include @INCINTL@ \
+	   $(CPPINC) $(GMPINC) $(DECNUMINC) \
+	   $(PPLINC) $(CLOOGINC) $(LIBELFINC)
+
+.c.o:
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
+
+#
+# Support for additional languages (other than C).
+# C can be supported this way too (leave for later).
+
+LANG_MAKEFRAGS = @all_lang_makefrags@
+LANG_MAKEFILES = @all_lang_makefiles@
+
+# Flags to pass to recursive makes.
+# CC is set by configure.
+# ??? The choices here will need some experimenting with.
+
+export AR_FOR_TARGET
+export AR_CREATE_FOR_TARGET
+export AR_FLAGS_FOR_TARGET
+export AR_EXTRACT_FOR_TARGET
+export AWK
+export DESTDIR
+export GCC_FOR_TARGET
+export INCLUDES
+export INSTALL_DATA
+export LIB1ASMSRC
+export LIBGCC2_CFLAGS
+export LIPO_FOR_TARGET
+export MACHMODE_H
+export NM_FOR_TARGET
+export STRIP_FOR_TARGET
+export RANLIB_FOR_TARGET
+export libsubdir
+export slibdir
+
+FLAGS_TO_PASS = \
+	"ADA_CFLAGS=$(ADA_CFLAGS)" \
+	"BISON=$(BISON)" \
+	"BISONFLAGS=$(BISONFLAGS)" \
+	"CFLAGS=$(CFLAGS) $(WARN_CFLAGS)" \
+	"LDFLAGS=$(LDFLAGS)" \
+	"FLEX=$(FLEX)" \
+	"FLEXFLAGS=$(FLEXFLAGS)" \
+	"LN=$(LN)" \
+	"LN_S=$(LN_S)" \
+	"MAKEINFO=$(MAKEINFO)" \
+	"MAKEINFOFLAGS=$(MAKEINFOFLAGS)" \
+	"MAKEOVERRIDES=" \
+	"SHELL=$(SHELL)" \
+	"exeext=$(exeext)" \
+	"build_exeext=$(build_exeext)" \
+	"objext=$(objext)" \
+	"exec_prefix=$(exec_prefix)" \
+	"prefix=$(prefix)" \
+	"local_prefix=$(local_prefix)" \
+	"gxx_include_dir=$(gcc_gxx_include_dir)" \
+	"build_tooldir=$(build_tooldir)" \
+	"gcc_tooldir=$(gcc_tooldir)" \
+	"bindir=$(bindir)" \
+	"libexecsubdir=$(libsubdir)" \
+	"datarootdir=$(datarootdir)" \
+	"datadir=$(datadir)" \
+	"localedir=$(localedir)"
+#
+# Lists of files for various purposes.
+
+# All option source files
+ALL_OPT_FILES=$(lang_opt_files) $(extra_opt_files)
+
+# Target specific, C specific object file
+C_TARGET_OBJS=@c_target_objs@
+
+# Target specific, C++ specific object file
+CXX_TARGET_OBJS=@cxx_target_objs@
+
+# Target specific, Fortran specific object file
+FORTRAN_TARGET_OBJS=@fortran_target_objs@
+
+# Object files for gcc driver.
+GCC_OBJS = gcc.o opts-common.o gcc-options.o
+
+# Language-specific object files for C and Objective C.
+C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
+  c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
+  c-ppoutput.o c-cppbuiltin.o \
+  c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \
+  c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o
+
+# Language-specific object files for C.
+C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)
+
+# Language-independent object files.
+# We put the insn-*.o files first so that a parallel make will build
+# them sooner, because they are large and otherwise tend to be the
+# last objects to finish building.
+OBJS-common = \
+	insn-attrtab.o \
+	insn-automata.o \
+	insn-emit.o \
+	insn-extract.o \
+	insn-modes.o \
+	insn-opinit.o \
+	insn-output.o \
+	insn-peep.o \
+	insn-preds.o \
+	insn-recog.o \
+	$(GGC) \
+	alias.o \
+	alloc-pool.o \
+	auto-inc-dec.o \
+	bb-reorder.o \
+	bitmap.o \
+	bt-load.o \
+	builtins.o \
+	caller-save.o \
+	calls.o \
+	cfg.o \
+	cfganal.o \
+	cfgbuild.o \
+	cfgcleanup.o \
+	cfgexpand.o \
+	cfghooks.o \
+	cfglayout.o \
+	cfgloop.o \
+	cfgloopanal.o \
+	cfgloopmanip.o \
+	cfgrtl.o \
+	combine.o \
+	combine-stack-adj.o \
+	convert.o \
+	coverage.o \
+	cse.o \
+	cselib.o \
+	dbxout.o \
+	dbgcnt.o \
+	dce.o \
+	ddg.o \
+	debug.o \
+	df-byte-scan.o \
+	df-core.o \
+	df-problems.o \
+	df-scan.o \
+	dfp.o \
+	diagnostic.o \
+	dojump.o \
+	dominance.o \
+	domwalk.o \
+	double-int.o \
+	dse.o \
+	dwarf2asm.o \
+	dwarf2out.o \
+	ebitmap.o \
+	emit-rtl.o \
+	et-forest.o \
+	except.o \
+	explow.o \
+	expmed.o \
+	expr.o \
+	final.o \
+	fixed-value.o \
+	fold-const.o \
+	function.o \
+	fwprop.o \
+	gcse.o \
+	genrtl.o \
+	ggc-common.o \
+	gimple.o \
+	gimple-iterator.o \
+	gimple-low.o \
+	gimple-pretty-print.o \
+	gimplify.o \
+	graph.o \
+	graphds.o \
+	graphite.o \
+	graphite-blocking.o \
+	graphite-clast-to-gimple.o \
+	graphite-dependences.o \
+	graphite-interchange.o \
+	graphite-poly.o \
+	graphite-ppl.o \
+	graphite-scop-detection.o \
+	graphite-sese-to-poly.o \
+	gtype-desc.o \
+	haifa-sched.o \
+	hooks.o \
+	ifcvt.o \
+	init-regs.o \
+	integrate.o \
+	intl.o \
+	ira.o \
+	ira-build.o \
+	ira-costs.o \
+	ira-conflicts.o \
+	ira-color.o \
+	ira-emit.o \
+	ira-lives.o \
+	jump.o \
+	lambda-code.o \
+	lambda-mat.o \
+	lambda-trans.o \
+	langhooks.o \
+	lcm.o \
+	lists.o \
+	loop-doloop.o \
+	loop-init.o \
+	loop-invariant.o \
+	loop-iv.o \
+	loop-unroll.o \
+	loop-unswitch.o \
+	lower-subreg.o \
+	lto-cgraph.o \
+	lto-streamer-in.o \
+	lto-streamer-out.o \
+	lto-section-in.o \
+	lto-section-out.o \
+	lto-symtab.o \
+	lto-opts.o \
+	lto-streamer.o \
+	lto-wpa-fixup.o \
+	lto-compress.o \
+	mcf.o \
+	mode-switching.o \
+	modulo-sched.o \
+	omega.o \
+	omp-low.o \
+	optabs.o \
+	options.o \
+	opts-common.o \
+	opts.o \
+	params.o \
+	passes.o \
+	plugin.o \
+	pointer-set.o \
+	postreload-gcse.o \
+	postreload.o \
+	predict.o \
+	pretty-print.o \
+	print-rtl.o \
+	print-tree.o \
+	profile.o \
+	real.o \
+	recog.o \
+	reg-stack.o \
+	regcprop.o \
+	reginfo.o \
+	regmove.o \
+	regrename.o \
+	regstat.o \
+	reload.o \
+	reload1.o \
+	reorg.o \
+	resource.o \
+	rtl-error.o \
+	rtl.o \
+	rtlanal.o \
+	rtlhooks.o \
+	sbitmap.o \
+	sched-deps.o \
+	sched-ebb.o \
+	sched-rgn.o \
+	sched-vis.o \
+	sdbout.o \
+	sel-sched-ir.o \
+	sel-sched-dump.o \
+	sel-sched.o \
+	sese.o \
+	simplify-rtx.o \
+	sparseset.o \
+	sreal.o \
+	stack-ptr-mod.o \
+	statistics.o \
+	stmt.o \
+	stor-layout.o \
+	store-motion.o \
+	stringpool.o \
+	targhooks.o \
+	timevar.o \
+	toplev.o \
+	tracer.o \
+	tree-affine.o \
+	tree-call-cdce.o \
+	tree-cfg.o \
+	tree-cfgcleanup.o \
+	tree-chrec.o \
+	tree-complex.o \
+	tree-data-ref.o \
+	tree-dfa.o \
+	tree-dump.o \
+	tree-eh.o \
+	tree-if-conv.o \
+	tree-into-ssa.o \
+	tree-iterator.o \
+	tree-loop-distribution.o \
+	tree-loop-linear.o \
+	tree-nested.o \
+	tree-nrv.o \
+	tree-object-size.o \
+	tree-optimize.o \
+	tree-outof-ssa.o \
+	tree-parloops.o \
+	tree-phinodes.o \
+	tree-predcom.o \
+	tree-pretty-print.o \
+	tree-profile.o \
+	tree-scalar-evolution.o \
+	tree-sra.o \
+	tree-switch-conversion.o \
+	tree-ssa-address.o \
+	tree-ssa-alias.o \
+	tree-ssa-ccp.o \
+	tree-ssa-coalesce.o \
+	tree-ssa-copy.o \
+	tree-ssa-copyrename.o \
+	tree-ssa-dce.o \
+	tree-ssa-dom.o \
+	tree-ssa-dse.o \
+	tree-ssa-forwprop.o \
+	tree-ssa-ifcombine.o \
+	tree-ssa-live.o \
+	tree-ssa-loop-ch.o \
+	tree-ssa-loop-im.o \
+	tree-ssa-loop-ivcanon.o \
+	tree-ssa-loop-ivopts.o \
+	tree-ssa-loop-manip.o \
+	tree-ssa-loop-niter.o \
+	tree-ssa-loop-prefetch.o \
+	tree-ssa-loop-unswitch.o \
+	tree-ssa-loop.o \
+	tree-ssa-math-opts.o \
+	tree-ssa-operands.o \
+	tree-ssa-phiopt.o \
+	tree-ssa-phiprop.o \
+	tree-ssa-pre.o \
+	tree-ssa-propagate.o \
+	tree-ssa-reassoc.o \
+	tree-ssa-sccvn.o \
+	tree-ssa-sink.o \
+	tree-ssa-structalias.o \
+	tree-ssa-ter.o \
+	tree-ssa-threadedge.o \
+	tree-ssa-threadupdate.o \
+	tree-ssa-uncprop.o \
+	tree-ssa.o \
+	tree-ssanames.o \
+	tree-stdarg.o \
+	tree-tailcall.o \
+	tree-vect-generic.o \
+	tree-vect-patterns.o \
+        tree-vect-data-refs.o \
+        tree-vect-stmts.o \
+        tree-vect-loop.o \
+        tree-vect-loop-manip.o \
+        tree-vect-slp.o \
+	tree-vectorizer.o \
+	tree-vrp.o \
+	tree.o \
+	value-prof.o \
+	var-tracking.o \
+	varasm.o \
+	varray.o \
+	vec.o \
+	version.o \
+	vmsdbgout.o \
+	web.o \
+	xcoffout.o
+
+# Target object files.
+OBJS-md = $(out_object_file)
+
+# Language independent object files which are not used by all languages.
+OBJS-archive = \
+	$(EXTRA_OBJS) \
+	$(host_hook_obj) \
+	cgraph.o \
+	cgraphbuild.o \
+	cgraphunit.o \
+	cppdefault.o \
+	incpath.o \
+	ipa-cp.o \
+	ipa-inline.o \
+	ipa-prop.o \
+	ipa-pure-const.o \
+	ipa-reference.o \
+	ipa-struct-reorg.o \
+	ipa-type-escape.o \
+	ipa-utils.o \
+	ipa.o \
+	matrix-reorg.o \
+	prefix.o \
+	tree-inline.o \
+	tree-nomudflap.o \
+	varpool.o
+
+OBJS = $(OBJS-common) $(OBJS-md) $(OBJS-archive)
+
+OBJS-onestep = libbackend.o $(OBJS-archive)
+
+# This lists all host object files, whether they are included in this
+# compilation or not.
+ALL_HOST_OBJS = $(GCC_OBJS) $(C_OBJS) $(OBJS) libbackend.o \
+  @TREEBROWSER@ main.o gccspec.o version.o intl.o prefix.o cppspec.o \
+  $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS)) \
+  $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) \
+  mips-tfile.o mips-tdump.o \
+  $(GCOV_OBJS) $(GCOV_DUMP_OBJS)
+
+BACKEND = main.o @TREEBROWSER@ libbackend.a $(CPPLIB) $(LIBDECNUMBER)
+
+MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \
+ insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \
+ insn-attr.h insn-attrtab.c insn-opinit.c insn-preds.c insn-constants.h \
+ tm-preds.h tm-constrs.h \
+ tree-check.h min-insn-modes.c insn-modes.c insn-modes.h \
+ genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-input.list \
+ xgcc$(exeext) cpp$(exeext) cc1$(exeext) cc1*-dummy$(exeext) $(EXTRA_PASSES) \
+ $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) \
+ $(SPECS) collect2$(exeext) lto-wrapper$(exeext) \
+ gcov-iov$(build_exeext) gcov$(exeext) gcov-dump$(exeext) \
+ *.[0-9][0-9].* *.[si] *-checksum.c libbackend.a libgcc.mk
+
+# Defined in libgcc2.c, included only in the static library.
+LIB2FUNCS_ST = _eprintf __gcc_bcmp
+
+# Defined in libgcov.c, included only in gcov library
+LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \
+    _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \
+    _gcov_execv _gcov_execvp _gcov_execve \
+    _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \
+    _gcov_indirect_call_profiler _gcov_average_profiler _gcov_ior_profiler \
+    _gcov_merge_ior
+
+FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \
+    _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \
+    _lt_sf _le_sf _unord_sf _si_to_sf _sf_to_si _negate_sf _make_sf \
+    _sf_to_df _sf_to_tf _thenan_sf _sf_to_usi _usi_to_sf
+
+DPBIT_FUNCS = _pack_df _unpack_df _addsub_df _mul_df _div_df \
+    _fpcmp_parts_df _compare_df _eq_df _ne_df _gt_df _ge_df \
+    _lt_df _le_df _unord_df _si_to_df _df_to_si _negate_df _make_df \
+    _df_to_sf _df_to_tf _thenan_df _df_to_usi _usi_to_df
+
+TPBIT_FUNCS = _pack_tf _unpack_tf _addsub_tf _mul_tf _div_tf \
+    _fpcmp_parts_tf _compare_tf _eq_tf _ne_tf _gt_tf _ge_tf \
+    _lt_tf _le_tf _unord_tf _si_to_tf _tf_to_si _negate_tf _make_tf \
+    _tf_to_df _tf_to_sf _thenan_tf _tf_to_usi _usi_to_tf
+
+D32PBIT_FUNCS = _addsub_sd _div_sd _mul_sd _plus_sd _minus_sd \
+	_eq_sd _ne_sd _lt_sd _gt_sd _le_sd _ge_sd \
+	_sd_to_si _sd_to_di _sd_to_usi _sd_to_udi \
+	_si_to_sd _di_to_sd _usi_to_sd _udi_to_sd \
+	_sd_to_sf _sd_to_df _sd_to_xf _sd_to_tf \
+	_sf_to_sd _df_to_sd _xf_to_sd _tf_to_sd \
+	_sd_to_dd _sd_to_td _unord_sd _conv_sd
+
+D64PBIT_FUNCS = _addsub_dd _div_dd _mul_dd _plus_dd _minus_dd \
+	_eq_dd _ne_dd _lt_dd _gt_dd _le_dd _ge_dd \
+	_dd_to_si _dd_to_di _dd_to_usi _dd_to_udi \
+	_si_to_dd _di_to_dd _usi_to_dd _udi_to_dd \
+	_dd_to_sf _dd_to_df _dd_to_xf _dd_to_tf \
+	_sf_to_dd _df_to_dd _xf_to_dd _tf_to_dd \
+	_dd_to_sd _dd_to_td _unord_dd _conv_dd
+
+D128PBIT_FUNCS = _addsub_td _div_td _mul_td _plus_td _minus_td \
+	_eq_td _ne_td _lt_td _gt_td _le_td _ge_td \
+	_td_to_si _td_to_di _td_to_usi _td_to_udi \
+	_si_to_td _di_to_td _usi_to_td _udi_to_td \
+	_td_to_sf _td_to_df _td_to_xf _td_to_tf \
+	_sf_to_td _df_to_td _xf_to_td _tf_to_td \
+	_td_to_sd _td_to_dd _unord_td _conv_td
+
+# These might cause a divide overflow trap and so are compiled with
+# unwinder info.
+LIB2_DIVMOD_FUNCS = _divdi3 _moddi3 _udivdi3 _umoddi3 _udiv_w_sdiv _udivmoddi4
+
+#
+# Language makefile fragments.
+
+# The following targets define the interface between us and the languages.
+#
+# all.cross, start.encap, rest.encap,
+# install-common, install-info, install-man,
+# uninstall,
+# mostlyclean, clean, distclean, maintainer-clean,
+#
+# Each language is linked in with a series of hooks.  The name of each
+# hooked is "lang.${target_name}" (eg: lang.info).  Configure computes
+# and adds these here.  We use double-colon rules for some of the hooks;
+# double-colon rules should be preferred for any new hooks.
+
+# language hooks, generated by configure
+@language_hooks@
+
+# per-language makefile fragments
+ifneq ($(LANG_MAKEFRAGS),)
+include $(LANG_MAKEFRAGS)
+endif
+
+# target and host overrides must follow the per-language makefile fragments
+# so they can override or augment language-specific variables
+
+# target overrides
+ifneq ($(tmake_file),)
+include $(tmake_file)
+endif
+
+# host overrides
+ifneq ($(xmake_file),)
+include $(xmake_file)
+endif
+
+# all-tree.def includes all the tree.def files.
+all-tree.def: s-alltree; @true
+s-alltree: Makefile
+	rm -f tmp-all-tree.def
+	echo '#include "tree.def"' > tmp-all-tree.def
+	echo 'END_OF_BASE_TREE_CODES' >> tmp-all-tree.def
+	echo '#include "c-common.def"' >> tmp-all-tree.def
+	ltf="$(lang_tree_files)"; for f in $$ltf; do \
+	  echo "#include \"$$f\""; \
+	done | sed 's|$(srcdir)/||' >> tmp-all-tree.def
+	$(SHELL) $(srcdir)/../move-if-change tmp-all-tree.def all-tree.def
+	$(STAMP) s-alltree
+
+#
+
+# -----------------------------
+# Rebuilding this configuration
+# -----------------------------
+
+# On the use of stamps:
+# Consider the example of tree-check.h. It is constructed with build/gencheck.
+# A simple rule to build tree-check.h would be
+# tree-check.h: build/gencheck$(build_exeext)
+#	$(RUN_GEN) build/gencheck$(build_exeext) > tree-check.h
+#
+# but tree-check.h doesn't change every time gencheck changes. It would the
+# nice if targets that depend on tree-check.h wouldn't be rebuild
+# unnecessarily when tree-check.h is unchanged. To make this, tree-check.h
+# must not be overwritten with a identical copy. One solution is to use a
+# temporary file
+# tree-check.h: build/gencheck$(build_exeext)
+#	$(RUN_GEN) build/gencheck$(build_exeext) > tmp-check.h
+#	$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h
+#
+# This solution has a different problem. Since the time stamp of tree-check.h
+# is unchanged, make will try to update tree-check.h every time it runs.
+# To prevent this, one can add a stamp
+# tree-check.h: s-check
+# s-check : build/gencheck$(build_exeext)
+#	$(RUN_GEN) build/gencheck$(build_exeext) > tmp-check.h
+#	$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h
+#	$(STAMP) s-check
+#
+# The problem with this solution is that make thinks that tree-check.h is
+# always unchanged. Make must be deceived into thinking that tree-check.h is
+# rebuild by the "tree-check.h: s-check" rule. To do this, add a dummy command:
+# tree-check.h: s-check; @true
+# s-check : build/gencheck$(build_exeext)
+#	$(RUN_GEN) build/gencheck$(build_exeext) > tmp-check.h
+#	$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h
+#	$(STAMP) s-check
+#
+# This is what is done in this makefile. Note that mkconfig.sh has a
+# move-if-change built-in
+
+Makefile: config.status $(srcdir)/Makefile.in $(LANG_MAKEFRAGS)
+	LANGUAGES="$(CONFIG_LANGUAGES)" \
+	CONFIG_HEADERS= \
+	CONFIG_SHELL="$(SHELL)" \
+	CONFIG_FILES=$@ $(SHELL) config.status
+
+config.h: cs-config.h ; @true
+bconfig.h: cs-bconfig.h ; @true
+tconfig.h: cs-tconfig.h ; @true
+tm.h: cs-tm.h ; @true
+tm_p.h: cs-tm_p.h ; @true
+
+cs-config.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(host_xm_include_list)" DEFINES="$(host_xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh config.h
+
+cs-bconfig.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(build_xm_include_list)" DEFINES="$(build_xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh bconfig.h
+
+cs-tconfig.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(xm_include_list)" DEFINES="USED_FOR_TARGET $(xm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh tconfig.h
+
+cs-tm.h: Makefile
+	TARGET_CPU_DEFAULT="$(target_cpu_default)" \
+	HEADERS="$(tm_include_list)" DEFINES="$(tm_defines)" \
+	$(SHELL) $(srcdir)/mkconfig.sh tm.h
+
+cs-tm_p.h: Makefile
+	TARGET_CPU_DEFAULT="" \
+	HEADERS="$(tm_p_include_list)" DEFINES="" \
+	$(SHELL) $(srcdir)/mkconfig.sh tm_p.h
+
+# Don't automatically run autoconf, since configure.ac might be accidentally
+# newer than configure.  Also, this writes into the source directory which
+# might be on a read-only file system.  If configured for maintainer mode
+# then do allow autoconf to be run.
+
+AUTOCONF = autoconf
+ACLOCAL = aclocal
+ACLOCAL_AMFLAGS = -I ../config -I ..
+aclocal_deps = \
+	$(srcdir)/../libtool.m4 \
+	$(srcdir)/../ltoptions.m4 \
+	$(srcdir)/../ltsugar.m4 \
+	$(srcdir)/../ltversion.m4 \
+	$(srcdir)/../lt~obsolete.m4 \
+	$(srcdir)/../config/acx.m4 \
+	$(srcdir)/../config/codeset.m4 \
+	$(srcdir)/../config/extensions.m4 \
+	$(srcdir)/../config/gettext-sister.m4 \
+	$(srcdir)/../config/iconv.m4 \
+	$(srcdir)/../config/lcmessage.m4 \
+	$(srcdir)/../config/lib-ld.m4 \
+	$(srcdir)/../config/lib-link.m4 \
+	$(srcdir)/../config/lib-prefix.m4 \
+	$(srcdir)/../config/override.m4 \
+	$(srcdir)/../config/progtest.m4 \
+        $(srcdir)/../config/stdint.m4 \
+	$(srcdir)/../config/unwind_ipinfo.m4 \
+	$(srcdir)/../config/warnings.m4 \
+	$(srcdir)/acinclude.m4
+
+$(srcdir)/configure: @MAINT@ $(srcdir)/configure.ac $(srcdir)/aclocal.m4
+	(cd $(srcdir) && $(AUTOCONF))
+
+$(srcdir)/aclocal.m4 : @MAINT@ $(aclocal_deps)
+	(cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS))
+
+gccbug:	$(srcdir)/gccbug.in
+	CONFIG_FILES=gccbug CONFIG_HEADERS= ./config.status
+
+# cstamp-h.in controls rebuilding of config.in.
+# It is named cstamp-h.in and not stamp-h.in so the mostlyclean rule doesn't
+# delete it.  A stamp file is needed as autoheader won't update the file if
+# nothing has changed.
+# It remains in the source directory and is part of the distribution.
+# This follows what is done in shellutils, fileutils, etc.
+# "echo timestamp" is used instead of touch to be consistent with other
+# packages that use autoconf (??? perhaps also to avoid problems with patch?).
+# ??? Newer versions have a maintainer mode that may be useful here.
+
+# Don't run autoheader automatically either.
+# Only run it if maintainer mode is enabled.
+@MAINT@ AUTOHEADER = autoheader
+@MAINT@ $(srcdir)/config.in: $(srcdir)/cstamp-h.in
+@MAINT@ $(srcdir)/cstamp-h.in: $(srcdir)/configure.ac
+@MAINT@	(cd $(srcdir) && $(AUTOHEADER))
+@MAINT@	@rm -f $(srcdir)/cstamp-h.in
+@MAINT@	echo timestamp > $(srcdir)/cstamp-h.in
+auto-host.h: cstamp-h ; @true
+cstamp-h: config.in config.status
+	CONFIG_HEADERS=auto-host.h:config.in \
+	CONFIG_FILES= \
+	LANGUAGES="$(CONFIG_LANGUAGES)" $(SHELL) config.status
+
+# Really, really stupid make features, such as SUN's KEEP_STATE, may force
+# a target to build even if it is up-to-date.  So we must verify that
+# config.status does not exist before failing.
+config.status: $(srcdir)/configure $(srcdir)/config.gcc
+	@if [ ! -f config.status ] ; then \
+	  echo You must configure gcc.  Look at http://gcc.gnu.org/install/ for details.; \
+	  false; \
+	else \
+	  LANGUAGES="$(CONFIG_LANGUAGES)" $(SHELL) config.status --recheck; \
+	fi
+
+# --------
+# UNSORTED
+# --------
+
+# Provide quickstrap as a target that people can type into the gcc directory,
+# and that fails if you're not into it.
+quickstrap: all
+	cd $(toplevel_builddir) && $(MAKE) all-target-libgcc
+
+all.internal: start.encap rest.encap doc
+# This is what to compile if making a cross-compiler.
+all.cross: native gcc-cross$(exeext) cpp$(exeext) specs \
+	libgcc-support lang.all.cross doc @GENINSRC@ srcextra
+# This is what must be made before installing GCC and converting libraries.
+start.encap: native xgcc$(exeext) cpp$(exeext) specs \
+	libgcc-support lang.start.encap @GENINSRC@ srcextra
+# These can't be made until after GCC can run.
+rest.encap: lang.rest.encap
+# This is what is made with the host's compiler
+# whether making a cross compiler or not.
+native: config.status auto-host.h build-@POSUB@ $(LANGUAGES) \
+	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(COLLECT2) lto-wrapper$(exeext)
+
+# Define the names for selecting languages in LANGUAGES.
+c: cc1$(exeext)
+
+# Tell GNU make these are phony targets.
+.PHONY: c
+
+# On the target machine, finish building a cross compiler.
+# This does the things that can't be done on the host machine.
+rest.cross: specs
+
+# Recompile all the language-independent object files.
+# This is used only if the user explicitly asks for it.
+compilations: $(BACKEND)
+
+# This archive is strictly for the host.
+libbackend.a: $(OBJS@onestep@)
+	-rm -rf libbackend.a
+	$(AR) $(AR_FLAGS) libbackend.a $(OBJS@onestep@)
+	-$(RANLIB) $(RANLIB_FLAGS) libbackend.a
+
+# We call this executable `xgcc' rather than `gcc'
+# to avoid confusion if the current directory is in the path
+# and CC is `gcc'.  It is renamed to `gcc' when it is installed.
+xgcc$(exeext): $(GCC_OBJS) gccspec.o version.o intl.o prefix.o \
+   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
+	  gccspec.o intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+
+# cpp is to cpp0 as gcc is to cc1.
+# The only difference from xgcc is that it's linked with cppspec.o
+# instead of gccspec.o.
+cpp$(exeext): $(GCC_OBJS) cppspec.o version.o intl.o prefix.o \
+   version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
+	  cppspec.o intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+
+# Dump a specs file to make -B./ read these specs over installed ones.
+$(SPECS): xgcc$(exeext)
+	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
+	mv tmp-specs $(SPECS)
+
+# We do want to create an executable named `xgcc', so we can use it to
+# compile libgcc2.a.
+# Also create gcc-cross, so that install-common will install properly.
+gcc-cross$(exeext): xgcc$(exeext)
+	cp xgcc$(exeext) gcc-cross$(exeext)
+
+dummy-checksum.o : dummy-checksum.c $(CONFIG_H) $(SYSTEM_H)
+
+cc1-dummy$(exeext): $(C_OBJS) dummy-checksum.o $(BACKEND) $(LIBDEPS)
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) \
+	  dummy-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
+
+cc1-checksum.c : cc1-dummy$(exeext) build/genchecksum$(build_exeext)
+	build/genchecksum$(build_exeext) cc1-dummy$(exeext) > $@
+
+cc1-checksum.o : cc1-checksum.c $(CONFIG_H) $(SYSTEM_H)
+
+cc1$(exeext): $(C_OBJS) cc1-checksum.o $(BACKEND) $(LIBDEPS)
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) \
+	  cc1-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
+
+#
+# Build libgcc.a.
+
+LIB2ADD = $(LIB2FUNCS_EXTRA)
+LIB2ADD_ST = $(LIB2FUNCS_STATIC_EXTRA)
+
+# All source files for libgcc are either in the source directory (in
+# which case they will start with $(srcdir)), or generated into the build
+# directory (in which case they will be relative paths).
+srcdirify = $(patsubst $(srcdir)%,$$(gcc_srcdir)%,$(filter $(srcdir)%,$(1))) \
+            $(patsubst %,$$(gcc_objdir)/%,$(filter-out $(srcdir)%,$(1)))
+
+# The distinction between these two variables is no longer relevant,
+# so we combine them.  Sort removes duplicates.
+GCC_EXTRA_PARTS := $(sort $(EXTRA_MULTILIB_PARTS) $(EXTRA_PARTS))
+
+libgcc-support: libgcc.mvars stmp-int-hdrs $(TCONFIG_H) \
+	$(MACHMODE_H) $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
+	$(LIB2ADD_ST) $(LIB2ADDEH) $(srcdir)/emutls.c gcov-iov.h $(SFP_MACHINE)
+
+libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \
+		xgcc$(exeext)
+	: > tmp-libgcc.mvars
+	echo LIB1ASMFUNCS = '$(LIB1ASMFUNCS)' >> tmp-libgcc.mvars
+	echo LIB1ASMSRC = '$(LIB1ASMSRC)' >> tmp-libgcc.mvars
+	echo LIB2FUNCS_ST = '$(LIB2FUNCS_ST)' >> tmp-libgcc.mvars
+	echo LIB2FUNCS_EXCLUDE = '$(LIB2FUNCS_EXCLUDE)' >> tmp-libgcc.mvars
+	echo LIBGCOV = '$(LIBGCOV)' >> tmp-libgcc.mvars
+	echo LIB2ADD = '$(call srcdirify,$(LIB2ADD))' >> tmp-libgcc.mvars
+	echo LIB2ADD_ST = '$(call srcdirify,$(LIB2ADD_ST))' >> tmp-libgcc.mvars
+	echo LIB2ADDEH = '$(call srcdirify,$(LIB2ADDEH) $(srcdir)/emutls.c)' >> tmp-libgcc.mvars
+	echo LIB2ADDEHSTATIC = '$(call srcdirify,$(LIB2ADDEHSTATIC) $(srcdir)/emutls.c)' >> tmp-libgcc.mvars
+	echo LIB2ADDEHSHARED = '$(call srcdirify,$(LIB2ADDEHSHARED) $(srcdir)/emutls.c)' >> tmp-libgcc.mvars
+	echo LIB2_SIDITI_CONV_FUNCS = '$(LIB2_SIDITI_CONV_FUNCS)' >> tmp-libgcc.mvars
+	echo LIBUNWIND = '$(call srcdirify,$(LIBUNWIND))' >> tmp-libgcc.mvars
+	echo SHLIBUNWIND_LINK = '$(SHLIBUNWIND_LINK)' >> tmp-libgcc.mvars
+	echo SHLIBUNWIND_INSTALL = '$(SHLIBUNWIND_INSTALL)' >> tmp-libgcc.mvars
+	echo FPBIT = '$(FPBIT)' >> tmp-libgcc.mvars
+	echo FPBIT_FUNCS = '$(FPBIT_FUNCS)' >> tmp-libgcc.mvars
+	echo LIB2_DIVMOD_FUNCS = '$(LIB2_DIVMOD_FUNCS)' >> tmp-libgcc.mvars
+	echo DPBIT = '$(DPBIT)' >> tmp-libgcc.mvars
+	echo DPBIT_FUNCS = '$(DPBIT_FUNCS)' >> tmp-libgcc.mvars
+	echo TPBIT = '$(TPBIT)' >> tmp-libgcc.mvars
+	echo TPBIT_FUNCS = '$(TPBIT_FUNCS)' >> tmp-libgcc.mvars
+	echo DFP_ENABLE = '$(DFP_ENABLE)' >> tmp-libgcc.mvars
+	echo DFP_CFLAGS='$(DFP_CFLAGS)' >> tmp-libgcc.mvars
+	echo D32PBIT='$(D32PBIT)' >> tmp-libgcc.mvars
+	echo D32PBIT_FUNCS='$(D32PBIT_FUNCS)' >> tmp-libgcc.mvars
+	echo D64PBIT='$(D64PBIT)' >> tmp-libgcc.mvars
+	echo D64PBIT_FUNCS='$(D64PBIT_FUNCS)' >> tmp-libgcc.mvars
+	echo D128PBIT='$(D128PBIT)' >> tmp-libgcc.mvars
+	echo D128PBIT_FUNCS='$(D128PBIT_FUNCS)' >> tmp-libgcc.mvars
+	echo GCC_EXTRA_PARTS = '$(GCC_EXTRA_PARTS)' >> tmp-libgcc.mvars
+	echo SHLIB_LINK = '$(subst $(GCC_FOR_TARGET),$$(GCC_FOR_TARGET),$(SHLIB_LINK))' >> tmp-libgcc.mvars
+	echo SHLIB_INSTALL = '$(SHLIB_INSTALL)' >> tmp-libgcc.mvars
+	echo SHLIB_EXT = '$(SHLIB_EXT)' >> tmp-libgcc.mvars
+	echo SHLIB_MKMAP = '$(call srcdirify,$(SHLIB_MKMAP))' >> tmp-libgcc.mvars
+	echo SHLIB_MKMAP_OPTS = '$(SHLIB_MKMAP_OPTS)' >> tmp-libgcc.mvars
+	echo SHLIB_MAPFILES = '$(call srcdirify,$(SHLIB_MAPFILES))' >> tmp-libgcc.mvars
+	echo SHLIB_NM_FLAGS = '$(SHLIB_NM_FLAGS)' >> tmp-libgcc.mvars
+	echo LIBGCC2_CFLAGS = '$(LIBGCC2_CFLAGS)' >> tmp-libgcc.mvars
+	echo TARGET_LIBGCC2_CFLAGS = '$(TARGET_LIBGCC2_CFLAGS)' >> tmp-libgcc.mvars
+	echo LIBGCC_SYNC = '$(LIBGCC_SYNC)' >> tmp-libgcc.mvars
+	echo LIBGCC_SYNC_CFLAGS = '$(LIBGCC_SYNC_CFLAGS)' >> tmp-libgcc.mvars
+	echo CRTSTUFF_CFLAGS = '$(CRTSTUFF_CFLAGS)' >> tmp-libgcc.mvars
+	echo CRTSTUFF_T_CFLAGS = '$(CRTSTUFF_T_CFLAGS)' >> tmp-libgcc.mvars
+	echo CRTSTUFF_T_CFLAGS_S = '$(CRTSTUFF_T_CFLAGS_S)' >> tmp-libgcc.mvars
+	echo TARGET_SYSTEM_ROOT = '$(TARGET_SYSTEM_ROOT)' >> tmp-libgcc.mvars
+
+	mv tmp-libgcc.mvars libgcc.mvars
+
+# Use the genmultilib shell script to generate the information the gcc
+# driver program needs to select the library directory based on the
+# switches.
+multilib.h: s-mlib; @true
+s-mlib: $(srcdir)/genmultilib Makefile
+	if test @enable_multilib@ = yes \
+	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
+	  $(SHELL) $(srcdir)/genmultilib \
+	    "$(MULTILIB_OPTIONS)" \
+	    "$(MULTILIB_DIRNAMES)" \
+	    "$(MULTILIB_MATCHES)" \
+	    "$(MULTILIB_EXCEPTIONS)" \
+	    "$(MULTILIB_EXTRA_OPTS)" \
+	    "$(MULTILIB_EXCLUSIONS)" \
+	    "$(MULTILIB_OSDIRNAMES)" \
+	    "@enable_multilib@" \
+	    > tmp-mlib.h; \
+	else \
+	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
+	    > tmp-mlib.h; \
+	fi
+	$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h
+	$(STAMP) s-mlib
+
+# Compile two additional files that are linked with every program
+# linked using GCC on systems using COFF or ELF, for the sake of C++
+# constructors.
+$(T)crtbegin.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  -c $(srcdir)/crtstuff.c -DCRT_BEGIN \
+	  -o $(T)crtbegin$(objext)
+
+$(T)crtend.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  -c $(srcdir)/crtstuff.c -DCRT_END \
+	  -o $(T)crtend$(objext)
+
+# These are versions of crtbegin and crtend for shared libraries.
+$(T)crtbeginS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS_S) \
+	  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFS_O \
+	  -o $(T)crtbeginS$(objext)
+
+$(T)crtendS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS_S) \
+	  -c $(srcdir)/crtstuff.c -DCRT_END -DCRTSTUFFS_O \
+	  -o $(T)crtendS$(objext)
+
+# This is a version of crtbegin for -static links.
+$(T)crtbeginT.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \
+  gbl-ctors.h stmp-int-hdrs tsystem.h coretypes.h $(TM_H)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) \
+	  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFT_O \
+	  -o $(T)crtbeginT$(objext)
+
+# Compile the start modules crt0.o and mcrt0.o that are linked with
+# every program
+$(T)crt0.o: s-crt0 ; @true
+$(T)mcrt0.o: s-crt0; @true
+
+s-crt0:	$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \
+	  -o $(T)crt0.o -c $(CRT0_S)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(CRT0STUFF_T_CFLAGS) \
+	  -o $(T)mcrt0.o -c $(MCRT0_S)
+	$(STAMP) s-crt0
+#
+# Compiling object files from source files.
+
+# Note that dependencies on obstack.h are not written
+# because that file is not part of GCC.
+
+# C language specific files.
+
+c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TM_P_H)
+c-parser.o : c-parser.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(GGC_H) $(TIMEVAR_H) $(C_TREE_H) $(INPUT_H) $(FLAGS_H) $(TOPLEV_H) output.h \
+    $(CPPLIB_H) gt-c-parser.h $(RTL_H) langhooks.h $(C_COMMON_H) $(C_PRAGMA_H) \
+    vec.h $(TARGET_H) $(CGRAPH_H) $(PLUGIN_H) $(EXCEPT_H)
+
+srcextra: gcc.srcextra lang.srcextra
+
+gcc.srcextra: gengtype-lex.c
+	-cp -p $^ $(srcdir)
+
+incpath.o: incpath.c incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \
+		intl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \
+		$(MACHMODE_H)
+
+c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) $(FUNCTION_H) output.h \
+    $(EXPR_H) debug.h $(TOPLEV_H) intl.h $(TM_P_H) $(TREE_INLINE_H) $(TIMEVAR_H) \
+    opts.h $(C_PRAGMA_H) gt-c-decl.h $(CGRAPH_H) $(HASHTAB_H) libfuncs.h \
+    $(EXCEPT_H) $(LANGHOOKS_DEF_H) $(TREE_DUMP_H) $(C_COMMON_H) $(CPPLIB_H) \
+    $(DIAGNOSTIC_H) $(INPUT_H) langhooks.h $(GIMPLE_H) tree-mudflap.h  \
+    pointer-set.h $(BASIC_BLOCK_H) $(GIMPLE_H) tree-iterator.h c-lang.h $(PLUGIN_H)
+c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(TREE_H) $(C_TREE_H) $(TARGET_H) $(FLAGS_H) intl.h output.h $(EXPR_H) \
+    $(RTL_H) $(TOPLEV_H) $(TM_P_H) langhooks.h $(GGC_H) $(TREE_FLOW_H) \
+    $(GIMPLE_H) tree-iterator.h c-lang.h
+c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(DIAGNOSTIC_H) \
+    $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h \
+    c-objc-common.h $(C_PRAGMA_H) c-common.def $(TREE_INLINE_H)
+stub-objc.o : stub-objc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+    $(C_COMMON_H)
+c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(RTL_H) debug.h $(C_TREE_H) $(C_COMMON_H) $(REAL_H) $(SPLAY_TREE_H) \
+    $(C_PRAGMA_H) $(INPUT_H) intl.h $(FLAGS_H) $(TOPLEV_H) output.h \
+    $(CPPLIB_H) $(TARGET_H) $(TIMEVAR_H) $(TM_P_H)
+c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(C_COMMON_H) $(TREE_H) $(CPPLIB_H) $(CPP_INTERNAL_H) $(C_PRAGMA_H)
+c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+    $(TM_H) $(TREE_H) $(C_TREE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \
+    $(FUNCTION_H) $(FLAGS_H) $(TOPLEV_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(VARRAY_H) \
+    langhooks.h $(GGC_H) $(TARGET_H) $(C_PRETTY_PRINT_H) c-objc-common.h \
+    tree-mudflap.h intl.h
+c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+    $(C_TREE_H) $(FLAGS_H) $(TOPLEV_H)
+c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(TREE_H) $(FLAGS_H) $(TOPLEV_H) $(C_COMMON_H) convert.h $(C_TREE_H) \
+    langhooks.h $(TARGET_H)
+c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+    $(TREE_H) $(FUNCTION_H) $(C_PRAGMA_H) $(TOPLEV_H) output.h $(GGC_H) $(TM_P_H) \
+    $(C_COMMON_H) $(TARGET_H) gt-c-pragma.h $(CPPLIB_H) $(FLAGS_H) $(DIAGNOSTIC_H) \
+    opts.h $(PLUGINS_H)
+graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) $(FLAGS_H) output.h \
+    $(RTL_H) $(FUNCTION_H) hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(OBSTACK_H) \
+    $(CONFIG_H)
+sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+    $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H)
+ebitmap.o: ebitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(EBITMAP_H) $(RTL_H) $(FLAGS_H) $(OBSTACK_H)
+sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)
+
+COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o intl.o version.o
+COLLECT2_LIBS = @COLLECT2_LIBS@
+collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
+# Don't try modifying collect2 (aka ld) in place--it might be linking this.
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o T$@ \
+		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS)
+	mv -f T$@ $@
+
+collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h \
+	$(OBSTACK_H) $(DEMANGLE_H) collect2.h collect2-aix.h version.h
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS)  \
+	-DTARGET_MACHINE=\"$(target_noncanonical)\" \
+	-c $(srcdir)/collect2.c $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@
+
+collect2-aix.o : collect2-aix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    collect2-aix.h
+
+tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(OBSTACK_H) collect2.h intl.h
+
+lto-wrapper$(exeext): lto-wrapper.o intl.o $(LIBDEPS)
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ lto-wrapper.o intl.o $(LIBS)
+	mv -f T$@ $@
+
+lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h
+
+# A file used by all variants of C.
+
+c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(OBSTACK_H) $(C_COMMON_H) $(FLAGS_H) $(TOPLEV_H) output.h $(C_PRAGMA_H) \
+	$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \
+	$(DIAGNOSTIC_H) gt-c-common.h langhooks.h $(VARRAY_H) $(RTL_H) \
+	$(TARGET_H) $(C_TREE_H) tree-iterator.h langhooks.h tree-mudflap.h \
+	intl.h opts.h $(REAL_H) $(CPPLIB_H) $(TREE_INLINE_H) $(HASHTAB_H) \
+	$(BUILTINS_DEF) $(CGRAPH_H) $(BASIC_BLOCK_H) $(TARGET_DEF_H) \
+	$(GIMPLE_H) libfuncs.h
+
+c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \
+	$(C_TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(REAL_H) \
+	$(DIAGNOSTIC_H) tree-iterator.h fixed-value.h intl.h
+
+c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)		\
+        $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) $(TOPLEV_H) langhooks.h		\
+        $(TREE_INLINE_H) $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)	\
+        opts.h options.h $(MKDEPS_H) incpath.h cppdefault.h $(TARGET_H) \
+	$(TM_P_H) $(VARRAY_H) $(C_TREE_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+		$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@
+
+c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) version.h $(C_COMMON_H) $(C_PRAGMA_H) $(FLAGS_H) \
+	$(TOPLEV_H) output.h $(EXCEPT_H) $(REAL_H) $(TARGET_H) $(TM_P_H) \
+	$(BASEVER) debug.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+		-DBASEVER=$(BASEVER_s) $< $(OUTPUT_OPTION)
+
+# A file used by all variants of C and some other languages.
+
+attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(FLAGS_H) $(TOPLEV_H) output.h $(RTL_H) $(GGC_H) $(TM_P_H) \
+	$(TARGET_H) langhooks.h $(CPPLIB_H) $(PLUGIN_H)
+
+c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) langhooks.h \
+	$(C_COMMON_H) $(FLAGS_H) $(TOPLEV_H) intl.h $(DIAGNOSTIC_H) alloc-pool.h \
+	c-format.h
+
+c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) $(FLAGS_H) $(TOPLEV_H) output.h $(RTL_H) $(GGC_H) \
+	$(PREDICT_H) $(TREE_INLINE_H) $(C_COMMON_H) $(EXCEPT_H) $(FUNCTION_H) \
+	langhooks.h $(SPLAY_TREE_H) $(TIMEVAR_H) $(GIMPLE_H) \
+	$(VARRAY_H) tree-iterator.h
+
+c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(C_TREE_H) $(TREE_DUMP_H)
+
+c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \
+	$(C_COMMON_H) output.h $(TOPLEV_H) $(C_PRAGMA_H) $(GGC_H) debug.h \
+	langhooks.h $(FLAGS_H) hosthooks.h version.h $(TARGET_H) opts.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	  -DHOST_MACHINE=\"$(host)\" -DTARGET_MACHINE=\"$(target)\" \
+	  $< $(OUTPUT_OPTION)
+
+c-omp.o : c-omp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+	$(FUNCTION_H) $(C_COMMON_H) $(TOPLEV_H) $(GIMPLE_H) $(BITMAP_H) \
+	langhooks.h
+
+# Language-independent files.
+
+DRIVER_DEFINES = \
+  -DSTANDARD_STARTFILE_PREFIX=\"$(unlibsubdir)/\" \
+  -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc/\" \
+  -DSTANDARD_LIBEXEC_PREFIX=\"$(libexecdir)/gcc/\" \
+  -DDEFAULT_TARGET_VERSION=\"$(version)\" \
+  -DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\" \
+  -DSTANDARD_BINDIR_PREFIX=\"$(bindir)/\" \
+  -DTOOLDIR_BASE_PREFIX=\"$(libsubdir_to_prefix)$(prefix_to_exec_prefix)\" \
+  @TARGET_SYSTEM_ROOT_DEFINE@ \
+  $(VALGRIND_DRIVER_DEFINES) \
+  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"` \
+  -DCONFIGURE_SPECS="\"@CONFIGURE_SPECS@\""
+
+gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \
+    Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H) $(FLAGS_H) \
+    configargs.h $(OBSTACK_H) opts.h
+	(SHLIB_LINK='$(SHLIB_LINK)'; \
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+  $(DRIVER_DEFINES) \
+  -c $(srcdir)/gcc.c $(OUTPUT_OPTION))
+
+gccspec.o: gccspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H)
+	(SHLIB_LINK='$(SHLIB_LINK)'; \
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+  $(DRIVER_DEFINES) \
+  -c $(srcdir)/gccspec.c $(OUTPUT_OPTION))
+
+cppspec.o: cppspec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H)
+
+specs.h : s-specs ; @true
+s-specs : Makefile
+	lsf="$(lang_specs_files)"; for f in $$lsf; do \
+	    echo "#include \"$$f\""; \
+	done | sed 's|$(srcdir)/||' > tmp-specs.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-specs.h specs.h
+	$(STAMP) s-specs
+
+optionlist: s-options ; @true
+s-options: $(ALL_OPT_FILES) Makefile $(srcdir)/opt-gather.awk
+	$(AWK) -f $(srcdir)/opt-gather.awk $(ALL_OPT_FILES) > tmp-optionlist
+	$(SHELL) $(srcdir)/../move-if-change tmp-optionlist optionlist
+	$(STAMP) s-options
+
+options.c: optionlist $(srcdir)/opt-functions.awk $(srcdir)/optc-gen.awk
+	$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/optc-gen.awk \
+	       -v header_name="config.h system.h coretypes.h tm.h" < $< > $@
+
+options.h: s-options-h ; @true
+s-options-h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opth-gen.awk
+	$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/opth-gen.awk \
+	       < $< > tmp-options.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-options.h options.h
+	$(STAMP) $@
+
+options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) $(FLAGS_H) \
+	$(TM_H) opts.h intl.h
+
+gcc-options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) opts.h intl.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(OUTPUT_OPTION) \
+		-DGCC_DRIVER options.c
+
+dumpvers: dumpvers.c
+
+ifdef REVISION_c
+version.o: version.c version.h $(REVISION) $(DATESTAMP) $(BASEVER) $(DEVPHASE)
+else
+version.o: version.c version.h $(DATESTAMP) $(BASEVER) $(DEVPHASE)
+endif
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	-DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \
+	-DREVISION=$(REVISION_s) \
+	-DDEVPHASE=$(DEVPHASE_s) -DPKGVERSION=$(PKGVERSION_s) \
+	-DBUGURL=$(BUGURL_s) -c $(srcdir)/version.c $(OUTPUT_OPTION)
+
+gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) $(OBSTACK_H) $(BITMAP_H) \
+	$(INPUT_H) $(TREE_H) $(RTL_H) $(FUNCTION_H) insn-config.h $(EXPR_H) \
+	hard-reg-set.h $(BASIC_BLOCK_H) cselib.h $(INSN_ADDR_H) $(OPTABS_H) \
+	libfuncs.h debug.h $(GGC_H) $(CGRAPH_H) $(TREE_FLOW_H) reload.h \
+	$(CPP_ID_DATA_H) tree-chrec.h $(CFGLAYOUT_H) $(EXCEPT_H) output.h \
+	$(CFGLOOP_H) $(TARGET_H)
+
+ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h		\
+	$(GGC_H) $(HASHTAB_H) $(TOPLEV_H) $(PARAMS_H) hosthooks.h	\
+	$(HOSTHOOKS_DEF_H) vec.h $(PLUGIN_H)
+
+ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+	$(FLAGS_H) $(TOPLEV_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H) $(TREE_FLOW_H) $(PLUGIN_H)
+
+ggc-zone.o: ggc-zone.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+	$(TREE_H) $(FLAGS_H) $(TOPLEV_H) $(GGC_H) $(TIMEVAR_H) $(TM_P_H) \
+	$(PARAMS_H) $(BITMAP_H) $(VARRAY_H) $(PLUGIN_H)
+
+ggc-none.o: ggc-none.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \
+	$(BCONFIG_H)
+
+stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	$(TREE_H) $(GGC_H) gt-stringpool.h $(CPPLIB_H) $(SYMTAB_H)
+
+prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) prefix.h \
+	Makefile $(BASEVER)
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	-DPREFIX=\"$(prefix)\" -DBASEVER=$(BASEVER_s) \
+	  -c $(srcdir)/prefix.c $(OUTPUT_OPTION)
+
+convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(FLAGS_H) convert.h $(TOPLEV_H) langhooks.h $(REAL_H) fixed-value.h
+
+double-int.o: double-int.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)
+
+# lto-compress.o needs $(ZLIBINC) added to the include flags.
+lto-compress.o: lto-compress.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+	$(TREE_H) langhooks.h $(LTO_HEADER_H) $(LTO_SECTION_H) \
+	lto-compress.h $(DIAGNOSTIC_H) errors.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(ZLIBINC) $< $(OUTPUT_OPTION)
+
+lto-cgraph.o: lto-cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \
+   $(TM_H) $(TOPLEV_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \
+   $(VARRAY_H) $(HASHTAB_H) langhooks.h $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_H) \
+   except.h $(TIMEVAR_H) output.h pointer-set.h $(LTO_STREAMER_H) $(GCOV_IO_H)
+lto-streamer-in.o: lto-streamer-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TOPLEV_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h $(VARRAY_H) \
+   $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) $(CGRAPH_H) \
+   $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_H) libfuncs.h $(EXCEPT_H) debug.h \
+   $(TIMEVAR_H) output.h $(IPA_UTILS_H) $(LTO_STREAMER_H)
+lto-streamer-out.o : lto-streamer-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \
+   $(VARRAY_H) $(HASHTAB_H) $(BASIC_BLOCK_H) tree-iterator.h \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) \
+   $(DIAGNOSTIC_H) except.h $(LTO_STREAMER_H) errors.h
+lto-section-in.o: lto-section-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TOPLEV_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h $(VARRAY_H) \
+   $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) \
+   $(GGC_H) $(DIAGNOSTIC_H) except.h $(TIMEVAR_H) output.h \
+   $(LTO_STREAMER_H) lto-compress.h
+lto-section-out.o : lto-section-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(PARAMS_H) input.h \
+   $(VARRAY_H) $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) \
+   $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) except.h pointer-set.h \
+   $(BITMAP_H) langhooks.h $(LTO_STREAMER_H) lto-compress.h
+lto-symtab.o: lto-symtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   toplev.h $(TREE_H) $(GIMPLE_H) $(GGC_H) $(LAMBDA_H) $(HASHTAB_H) \
+   $(LTO_STREAMER_H) $(LINKER_PLUGIN_API_H) gt-lto-symtab.h
+lto-opts.o: lto-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+   $(HASHTAB_H) $(GGC_H) $(BITMAP_H) $(FLAGS_H) opts.h options.h \
+   $(TARGET_H) $(TOPLEV_H) $(LTO_STREAMER_H)
+lto-streamer.o: lto-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \
+   $(TM_H) $(TREE_H) $(GIMPLE_H) $(BITMAP_H) $(LTO_STREAMER_H) $(FLAGS_H) \
+   $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(LTO_SYMTAB_H) $(TOPLEV_H)
+lto-wpa-fixup.o: lto-wpa-fixup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \
+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(FLAGS_H) $(CGRAPH_H) \
+   $(FUNCTION_H) $(DIAGNOSTIC_H) $(BITMAP_H) $(TIMEVAR_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(LTO_STREAMER_H)
+langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(TOPLEV_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \
+   langhooks.h $(TARGET_H) $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) \
+   intl.h $(GIMPLE_H) $(CGRAPH_H) output.h
+tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \
+   $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) \
+   langhooks.h $(REAL_H) gt-tree.h $(TREE_INLINE_H) tree-iterator.h \
+   $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(OBSTACK_H) pointer-set.h fixed-value.h \
+   tree-pass.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) $(CGRAPH_H) $(TIMEVAR_H) \
+   $(EXCEPT_H) debug.h intl.h
+tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h $(TOPLEV_H) $(SPLAY_TREE_H) $(TREE_DUMP_H) \
+   tree-iterator.h $(TREE_PASS_H) $(DIAGNOSTIC_H) $(REAL_H) fixed-value.h
+tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) $(INPUT_H) insn-config.h \
+   $(HASHTAB_H) $(TOPLEV_H) langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) \
+   intl.h $(FUNCTION_H) $(GGC_H) $(GIMPLE_H) \
+   debug.h $(DIAGNOSTIC_H) $(EXCEPT_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \
+   $(IPA_PROP_H) value-prof.h $(TREE_PASS_H) $(TARGET_H) $(INTEGRATE_H)
+print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(GGC_H) langhooks.h $(REAL_H) tree-iterator.h fixed-value.h \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_PASS_H)
+stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(PARAMS_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) output.h $(RTL_H) \
+   $(GGC_H) $(TM_P_H) $(TARGET_H) langhooks.h $(REGS_H) gt-stor-layout.h \
+   $(TOPLEV_H) $(CGRAPH_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(GIMPLE_H)
+tree-ssa-structalias.o: tree-ssa-structalias.c \
+   $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \
+   $(FLAGS_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h \
+   $(DIAGNOSTIC_H) $(TOPLEV_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) varray.h \
+   $(GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) \
+   $(TREE_PASS_H) $(TIMEVAR_H) alloc-pool.h $(SPLAY_TREE_H) $(PARAMS_H) \
+   gt-tree-ssa-structalias.h $(CGRAPH_H) $(ALIAS_H) pointer-set.h
+tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \
+   $(TOPLEV_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) langhooks.h $(TREE_PASS_H) $(BASIC_BLOCK_H) $(BITMAP_H) \
+   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) pointer-set.h \
+   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) $(TARGET_H)
+tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \
+   $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   langhooks.h domwalk.h $(TREE_PASS_H) $(GGC_H) $(PARAMS_H) $(BASIC_BLOCK_H) \
+   $(BITMAP_H) $(CFGLOOP_H) $(FLAGS_H) hard-reg-set.h $(HASHTAB_H) \
+   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) vecprim.h
+tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_SSA_LIVE_H) $(BITMAP_H) $(FLAGS_H)
+tree-ssa-coalesce.o : tree-ssa-coalesce.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_SSA_LIVE_H) $(BITMAP_H) $(FLAGS_H) $(HASHTAB_H) $(TOPLEV_H)
+tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) $(BITMAP_H) $(GGC_H) \
+   $(TOPLEV_H) $(EXPR_H) $(SSAEXPAND_H)
+tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) domwalk.h $(FLAGS_H) \
+   $(DIAGNOSTIC_H) $(TIMEVAR_H) langhooks.h
+tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   langhooks.h $(FLAGS_H) $(GIMPLE_H)
+tree-ssa-phiprop.o : tree-ssa-phiprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   langhooks.h $(FLAGS_H)
+tree-ssa-ifcombine.o : tree-ssa-ifcombine.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H)
+tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \
+   $(DIAGNOSTIC_H) $(TIMEVAR_H) pointer-set.h domwalk.h
+tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(RTL_H) $(FUNCTION_H) $(BASIC_BLOCK_H) $(EXPR_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) $(TREE_PASS_H) \
+   langhooks.h
+tree-ssa-copy.o : tree-ssa-copy.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h tree-ssa-propagate.h \
+   $(FLAGS_H) $(CFGLOOP_H)
+tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h \
+   tree-ssa-propagate.h vec.h value-prof.h gt-tree-ssa-propagate.h $(FLAGS_H) \
+   $(VARRAY_H) $(GIMPLE_H)
+tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(BASIC_BLOCK_H) domwalk.h $(TREE_PASS_H) $(FLAGS_H) langhooks.h \
+   tree-ssa-propagate.h $(CFGLOOP_H) $(PARAMS_H) $(REAL_H)
+tree-ssa-uncprop.o : tree-ssa-uncprop.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) domwalk.h $(TREE_PASS_H) $(FLAGS_H) \
+   langhooks.h tree-ssa-propagate.h $(REAL_H)
+tree-ssa-threadedge.o : tree-ssa-threadedge.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(FLAGS_H) $(RTL_H) $(TM_P_H) $(GGC_H) \
+   $(BASIC_BLOCK_H) $(CFGLOOP_H) output.h $(EXPR_H) \
+   $(FUNCTION_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TREE_DUMP_H) $(TREE_FLOW_H) \
+   $(REAL_H) $(TREE_PASS_H) tree-ssa-propagate.h langhooks.h \
+   $(PARAMS_H)
+tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) $(FUNCTION_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(BASIC_BLOCK_H) $(FLAGS_H) $(TREE_PASS_H) $(CFGLOOP_H)
+tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) $(TREE_FLOW_H) $(TREE_PASS_H)
+tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \
+   gt-tree-phinodes.h $(RTL_H) $(TOPLEV_H)  $(GIMPLE_H)
+domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) domwalk.h $(GGC_H)
+tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_SSA_LIVE_H) $(BITMAP_H) $(TOPLEV_H) debug.h $(FLAGS_H)
+tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) \
+   $(TREE_PASS_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) \
+   $(BASIC_BLOCK_H) $(BITMAP_H) $(FLAGS_H) $(HASHTAB_H) langhooks.h \
+   $(GIMPLE_H) $(TREE_INLINE_H) $(GIMPLE_H)
+tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) langhooks.h \
+   $(CFGLOOP_H) alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) \
+   $(GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \
+   $(DBGCNT_H) tree-scalar-evolution.h
+tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) $(CFGLOOP_H) \
+   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) langhooks.h $(HASHTAB_H) $(GIMPLE_H) \
+   $(TREE_INLINE_H) tree-iterator.h tree-ssa-propagate.h tree-ssa-sccvn.h \
+   $(PARAMS_H)
+tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(GGC_H) \
+   $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \
+   $(CFGLOOP_H) $(SCEV_H) $(TIMEVAR_H) $(TOPLEV_H) intl.h
+tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \
+   $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(CFGLOOP_H) $(TREE_PASS_H) \
+   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(TOPLEV_H) \
+   value-prof.h tree-ssa-propagate.h $(TREE_INLINE_H)
+tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \
+   $(DIAGNOSTIC_H) $(TOPLEV_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(CFGLOOP_H) $(TREE_PASS_H) \
+   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) $(TOPLEV_H) \
+   tree-ssa-propagate.h $(SCEV_H)
+tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(FUNCTION_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(EXCEPT_H) $(TREE_PASS_H) $(FLAGS_H) langhooks.h \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(DBGCNT_H)
+tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) alloc-pool.h \
+   $(BASIC_BLOCK_H) $(BITMAP_H) $(CFGLOOP_H) $(FIBHEAP_H) $(HASHTAB_H) \
+   langhooks.h $(REAL_H) $(GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h
+tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \
+   $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(TREE_DUMP_H) $(TREE_INLINE_H) \
+   tree-iterator.h $(GIMPLE_H) $(CGRAPH_H) $(EXPR_H) langhooks.h \
+   $(GGC_H) gt-tree-nested.h coretypes.h $(TREE_FLOW_H) pointer-set.h
+tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(FLAGS_H) $(TIMEVAR_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \
+   $(CFGLOOP_H) $(RTL_H) $(TREE_DATA_REF_H) $(TREE_PASS_H) $(DIAGNOSTIC_H) \
+   $(TARGET_H) $(TREE_DUMP_H) $(VARRAY_H)
+tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   coretypes.h $(GGC_H) tree-iterator.h $(GIMPLE_H) gt-tree-iterator.h
+tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \
+   $(TREE_INLINE_H) $(HASHTAB_H) pointer-set.h $(FLAGS_H) $(FUNCTION_H) \
+   $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(PARAMS_H) $(CGRAPH_H) $(BASIC_BLOCK_H) hard-reg-set.h \
+   $(GIMPLE_H)
+tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \
+   $(FLAGS_H) $(FUNCTION_H) $(TM_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TOPLEV_H) \
+   coretypes.h langhooks.h $(IPA_REFERENCE_H)
+tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_H) $(FLAGS_H) $(FUNCTION_H) $(EXCEPT_H) langhooks.h \
+   $(GGC_H) $(TREE_PASS_H) coretypes.h $(TIMEVAR_H) $(TM_P_H) pointer-set.h \
+   $(TREE_DUMP_H) $(TREE_INLINE_H) tree-iterator.h $(TOPLEV_H)
+tree-ssa-loop.o : tree-ssa-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TREE_PASS_H) $(TIMEVAR_H) \
+   $(CFGLOOP_H) $(FLAGS_H) $(TREE_INLINE_H) $(SCEV_H) $(TOPLEV_H) $(TREE_VECTORIZER_H)
+tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) \
+   $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \
+   $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \
+   coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(BASIC_BLOCK_H) hard-reg-set.h \
+    $(TREE_INLINE_H)
+tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(FLAGS_H) $(TREE_INLINE_H) $(RECOG_H) insn-config.h \
+   $(EXPR_H) gt-tree-ssa-address.h $(GGC_H) tree-affine.h $(TARGET_H)
+tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \
+   $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TOPLEV_H) $(FLAGS_H) $(TREE_PASS_H) $(TREE_DATA_REF_H) \
+   $(BASIC_BLOCK_H) $(GGC_H) hard-reg-set.h intl.h
+tree-ssa-loop-ivcanon.o : tree-ssa-loop-ivcanon.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \
+   $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(FLAGS_H) $(TREE_PASS_H) $(SCEV_H) $(BASIC_BLOCK_H) $(GGC_H) \
+   hard-reg-set.h $(TARGET_H)
+tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(TREE_INLINE_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(FLAGS_H) $(BASIC_BLOCK_H) hard-reg-set.h
+tree-ssa-loop-prefetch.o: tree-ssa-loop-prefetch.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) \
+   $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \
+   $(TOPLEV_H) langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H) \
+   $(OPTABS_H)
+tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \
+   $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) \
+   $(PARAMS_H) $(DIAGNOSTIC_H) $(TREE_PASS_H) $(TM_H) coretypes.h \
+   tree-affine.h $(TREE_INLINE_H)
+tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \
+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \
+   $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \
+   $(VARRAY_H) tree-affine.h pointer-set.h $(TARGET_H)
+tree-affine.o : tree-affine.c tree-affine.h $(CONFIG_H) pointer-set.h \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) hard-reg-set.h $(GIMPLE_H) \
+   output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H)
+tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h \
+   $(BASIC_BLOCK_H) output.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
+   $(TIMEVAR_H) $(CFGLOOP_H) $(TREE_PASS_H) $(CFGLAYOUT_H) \
+   $(SCEV_H) $(PARAMS_H) $(TREE_INLINE_H) langhooks.h
+tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h \
+   $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) $(REAL_H) $(BASIC_BLOCK_H) \
+   hard-reg-set.h pointer-set.h tree-affine.h tree-ssa-propagate.h
+tree-ssa-math-opts.o : tree-ssa-math-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(FLAGS_H) $(TREE_H) $(TREE_FLOW_H) $(REAL_H) $(TIMEVAR_H) \
+   $(TREE_PASS_H) alloc-pool.h $(BASIC_BLOCK_H) $(TARGET_H) \
+   $(DIAGNOSTIC_H) $(RTL_H) $(EXPR_H) $(OPTABS_H)
+tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(TREE_INLINE_H) $(FLAGS_H) \
+   $(FUNCTION_H) $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \
+   $(TREE_DUMP_H) $(TREE_PASS_H) $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   hard-reg-set.h $(GIMPLE_H) vec.h \
+   $(IPA_TYPE_ESCAPE_H) vecprim.h pointer-set.h alloc-pool.h
+tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) \
+   tree-iterator.h $(REAL_H) $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_INLINE_H) \
+   vec.h langhooks.h alloc-pool.h pointer-set.h $(CFGLOOP_H)
+tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) hard-reg-set.h $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) $(BASIC_BLOCK_H) $(FLAGS_H) $(TIMEVAR_H) $(TM_H) \
+   coretypes.h $(TREE_DUMP_H) $(TOPLEV_H) $(FUNCTION_H) langhooks.h \
+   $(FLAGS_H) $(CGRAPH_H) $(PLUGIN_H) \
+   $(TREE_INLINE_H) tree-mudflap.h $(GGC_H) graph.h $(CGRAPH_H) \
+   $(TREE_PASS_H) $(CFGLOOP_H) $(EXCEPT_H)
+
+c-gimplify.o : c-gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   $(C_TREE_H) $(C_COMMON_H) $(DIAGNOSTIC_H) $(GIMPLE_H) $(VARRAY_H) \
+   $(FLAGS_H) langhooks.h $(TOPLEV_H) $(RTL_H) $(TREE_FLOW_H) $(LANGHOOKS_DEF_H) \
+   $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H) $(BASIC_BLOCK_H) \
+   hard-reg-set.h $(TREE_DUMP_H) $(TREE_INLINE_H)
+gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(GIMPLE_H) \
+   $(DIAGNOSTIC_H) $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \
+   $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \
+   coretypes.h $(EXCEPT_H) $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) output.h \
+   $(GGC_H) gt-gimplify.h $(HASHTAB_H) $(TARGET_H) $(TOPLEV_H) $(OPTABS_H) \
+   $(REAL_H) $(SPLAY_TREE_H) vec.h tree-iterator.h tree-pass.h
+gimple-iterator.o : gimple-iterator.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) value-prof.h
+gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+   $(DIAGNOSTIC_H) $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \
+   $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(EXCEPT_H) $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) $(TREE_PASS_H) \
+   $(HASHTAB_H) $(TOPLEV_H) tree-iterator.h
+omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) $(TOPLEV_H) \
+   $(TREE_PASS_H) $(GGC_H) $(EXCEPT_H) $(SPLAY_TREE_H) $(OPTABS_H) \
+   $(CFGLOOP_H) tree-iterator.h gt-omp-low.h
+tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \
+   $(TM_H) coretypes.h
+omega.o : omega.c omega.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(DIAGNOSTIC_H) varray.h $(TREE_PASS_H) $(PARAMS_H)
+tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(REAL_H) $(SCEV_H) $(TREE_PASS_H) $(PARAMS_H) \
+   $(DIAGNOSTIC_H) $(CFGLOOP_H) $(TREE_FLOW_H) $(FLAGS_H)
+tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(REAL_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
+   $(TIMEVAR_H) $(CFGLOOP_H) $(SCEV_H) $(TREE_PASS_H) $(FLAGS_H) \
+   gt-tree-scalar-evolution.h
+tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(FLAGS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(TREE_DATA_REF_H) $(TREE_PASS_H) langhooks.h
+sese.o: sese.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) tree-chrec.h \
+   $(TREE_DATA_REF_H) tree-scalar-evolution.h tree-pass.h domwalk.h value-prof.h \
+   pointer-set.h $(GIMPLE_H) sese.h
+graphite.o: graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \
+   $(PREDICT_H) $(TREE_DATA_REF_H) tree-pass.h graphite.h \
+   pointer-set.h value-prof.h graphite-ppl.h sese.h \
+   graphite-scop-detection.h graphite-clast-to-gimple.h \
+   graphite-poly.h graphite-sese-to-poly.h
+graphite-blocking.o: graphite-blocking.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) output.h $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h domwalk.h value-prof.h \
+   graphite.h graphite-poly.h graphite-ppl.h
+graphite-clast-to-gimple.o: graphite-clast-to-gimple.c $(CONFIG_H) \
+   $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \
+   $(TREE_DATA_REF_H) tree-pass.h domwalk.h graphite.h \
+   pointer-set.h value-prof.h graphite-ppl.h sese.h \
+   graphite-scop-detection.h graphite-clast-to-gimple.h graphite-poly.h \
+   graphite-dependences.h
+graphite-dependences.o: graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h domwalk.h \
+   graphite.h graphite-poly.h graphite-ppl.h graphite-dependences.h
+graphite-interchange.o: graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) output.h $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h domwalk.h value-prof.h \
+   graphite.h graphite-poly.h graphite-ppl.h
+graphite-poly.o: graphite-poly.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \
+   $(TREE_DATA_REF_H) tree-pass.h domwalk.h graphite.h graphite-dependences.h \
+   pointer-set.h value-prof.h graphite-ppl.h sese.h output.h graphite-poly.h
+graphite-ppl.o: graphite-ppl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) graphite-ppl.h
+graphite-scop-detection.o: graphite-scop-detection.c $(CONFIG_H) $(SYSTEM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \
+   $(TREE_DATA_REF_H) tree-pass.h domwalk.h graphite.h $(TM_H) \
+   value-prof.h graphite-ppl.h sese.h pointer-set.h coretypes.h \
+   graphite-scop-detection.h graphite-poly.h
+graphite-sese-to-poly.o: graphite-sese-to-poly.c $(CONFIG_H) \
+   $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \
+   $(TREE_DATA_REF_H) tree-pass.h domwalk.h graphite.h \
+   pointer-set.h value-prof.h graphite-ppl.h sese.h \
+   graphite-scop-detection.h graphite-sese-to-poly.h $(PARAMS_H) \
+   graphite-clast-to-gimple.h graphite-poly.h
+tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \
+   $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(EXPR_H) $(RECOG_H) $(OPTABS_H) \
+   $(TOPLEV_H) $(SCEV_H) $(TREE_VECTORIZER_H)
+tree-vect-loop-manip.o: tree-vect-loop-manip.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(EXPR_H) $(TOPLEV_H) \
+   $(SCEV_H) $(TREE_VECTORIZER_H) langhooks.h
+tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(EXPR_H) $(OPTABS_H) $(PARAMS_H) \
+   $(TREE_DATA_REF_H) $(TREE_VECTORIZER_H) $(RECOG_H) $(TOPLEV_H)
+tree-vect-slp.o: tree-vect-slp.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) \
+   $(EXPR_H) $(RECOG_H) $(OPTABS_H) $(TREE_VECTORIZER_H)
+tree-vect-stmts.o: tree-vect-stmts.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) \
+   $(EXPR_H) $(RECOG_H) $(OPTABS_H) $(TOPLEV_H) $(TREE_VECTORIZER_H) langhooks.h
+tree-vect-data-refs.o: tree-vect-data-refs.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) \
+   $(EXPR_H) $(OPTABS_H) $(SCEV_H) $(TREE_VECTORIZER_H) $(TOPLEV_H)
+tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(TREE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
+   $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) $(TIMEVAR_H)
+tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(TREE_PASS_H) $(TREE_DATA_REF_H) $(EXPR_H) $(LAMBDA_H) \
+   $(TARGET_H) $(OBSTACK_H)
+tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(TREE_PASS_H) $(TREE_DATA_REF_H) $(EXPR_H) \
+   $(TARGET_H) langhooks.h $(TREE_VECTORIZER_H)
+tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_FLOW_H) $(TREE_H) $(RTL_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(GGC_H) \
+   $(DIAGNOSTIC_H) $(TREE_PASS_H) langhooks.h gt-tree-parloops.h \
+   $(TREE_VECTORIZER_H)
+tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(FUNCTION_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_PASS_H) \
+   tree-stdarg.h $(TARGET_H) langhooks.h
+tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(TOPLEV_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \
+   $(TREE_PASS_H) tree-ssa-propagate.h
+gimple.o : gimple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+   $(GGC_H) $(GIMPLE_H) $(TOPLEV_H) $(DIAGNOSTIC_H) gt-gimple.h \
+   $(TREE_FLOW_H) value-prof.h $(FLAGS_H) $(DEMANGLE_H) \
+   $(TARGET_H) $(ALIAS_H)
+gimple-pretty-print.o : gimple-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \
+   $(TM_H) coretypes.h $(TREE_PASS_H) $(GIMPLE_H) value-prof.h
+tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \
+   $(GIMPLE_H) $(DIAGNOSTIC_H) $(DEMANGLE_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \
+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(CGRAPH_H) $(GGC_H) \
+   gt-tree-mudflap.h $(BASIC_BLOCK_H) $(FLAGS_H) $(FUNCTION_H) hard-reg-set.h \
+   $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(TOPLEV_H) $(GIMPLE_H) tree-iterator.h
+tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \
+   $(C_TREE_H) $(C_COMMON_H) $(GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \
+   output.h $(VARRAY_H) langhooks.h tree-mudflap.h $(TM_H) coretypes.h \
+   $(GGC_H) gt-tree-mudflap.h $(TREE_PASS_H) $(TOPLEV_H)
+tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \
+   $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \
+   $(TM_H) coretypes.h tree-iterator.h $(SCEV_H) langhooks.h \
+   $(TREE_PASS_H) value-prof.h fixed-value.h output.h
+fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(FLAGS_H) $(REAL_H) $(TOPLEV_H) $(HASHTAB_H) $(EXPR_H) $(RTL_H) \
+   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h fixed-value.h $(TARGET_H) \
+   $(GIMPLE_H)
+diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) $(INPUT_H) $(TOPLEV_H) intl.h \
+   $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h \
+   $(PLUGIN_H)
+opts.o : opts.c opts.h options.h $(TOPLEV_H) $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(EXPR_H) $(RTL_H) \
+   output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \
+   $(FLAGS_H) $(PARAMS_H) $(TREE_PASS_H) $(DBGCNT_H) debug.h varray.h \
+   $(PLUGIN_H) $(EXCEPT_H)
+opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h intl.h
+targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+   $(EXPR_H) $(TM_H) $(RTL_H) $(TM_P_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
+   $(MACHMODE_H) $(TARGET_DEF_H) $(TARGET_H) $(GGC_H) gt-targhooks.h \
+   $(OPTABS_H) $(RECOG_H) reload.h hard-reg-set.h
+
+bversion.h: s-bversion; @true
+s-bversion: BASE-VER
+	echo "#define BUILDING_GCC_MAJOR `echo $(BASEVER_c) | sed -e 's/^\([0-9]*\).*$$/\1/'`" > bversion.h
+	echo "#define BUILDING_GCC_MINOR `echo $(BASEVER_c) | sed -e 's/^[0-9]*\.\([0-9]*\).*$$/\1/'`" >> bversion.h
+	echo "#define BUILDING_GCC_PATCHLEVEL `echo $(BASEVER_c) | sed -e 's/^[0-9]*\.[0-9]*\.\([0-9]*\)$$/\1/'`" >> bversion.h
+	echo "#define BUILDING_GCC_VERSION (BUILDING_GCC_MAJOR * 1000 + BUILDING_GCC_MINOR)" >> bversion.h
+	$(STAMP) s-bversion
+
+toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   version.h $(RTL_H) $(FUNCTION_H) $(FLAGS_H) xcoffout.h $(INPUT_H) \
+   $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) debug.h insn-config.h intl.h \
+   $(RECOG_H) Makefile $(TOPLEV_H) dwarf2out.h sdbout.h dbxout.h $(EXPR_H) \
+   hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(EXCEPT_H) $(REGS_H) $(TIMEVAR_H) \
+   value-prof.h $(PARAMS_H) $(TM_P_H) reload.h ira.h dwarf2asm.h $(TARGET_H) \
+   langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \
+   $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \
+   opts.h params.def tree-mudflap.h $(REAL_H) $(TREE_PASS_H) $(GIMPLE_H) \
+   tree-ssa-alias.h $(PLUGIN_H)
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	  -DTARGET_NAME=\"$(target_noncanonical)\" \
+	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
+
+passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(FUNCTION_H) $(FLAGS_H) xcoffout.h $(INPUT_H) $(INSN_ATTR_H) output.h \
+   $(DIAGNOSTIC_H) debug.h insn-config.h intl.h $(RECOG_H) $(TOPLEV_H) \
+   dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \
+   graph.h $(EXCEPT_H) $(REGS_H) $(TIMEVAR_H) value-prof.h \
+   $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \
+   langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \
+   hosthooks.h $(CGRAPH_H) $(COVERAGE_H) $(TREE_PASS_H) $(TREE_DUMP_H) \
+   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \
+   gt-passes.h $(DF_H) $(PREDICT_H) $(LTO_HEADER_H) $(LTO_SECTION_OUT_H) \
+   $(PLUGIN_H)
+
+plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TOPLEV_H) $(TREE_H) $(TREE_PASS_H) intl.h $(PLUGIN_VERSION_H) $(GGC_H)
+
+main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H)
+
+host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   hosthooks.h $(HOSTHOOKS_DEF_H)
+
+rtl-error.o: rtl-error.c $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(INSN_ATTR_H) insn-config.h $(INPUT_H) $(TOPLEV_H) intl.h $(DIAGNOSTIC_H) \
+   $(CONFIG_H) varray.h
+
+rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+  $(GGC_H) $(BCONFIG_H) insn-notes.def reg-notes.def $(TOPLEV_H) $(REAL_H)
+
+print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+    $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) $(FLAGS_H) \
+    $(BCONFIG_H) $(REAL_H) $(DIAGNOSTIC_H) cselib.h $(TREE_PASS_H)
+rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \
+   $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \
+   $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H) \
+   $(DF_H)
+
+varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \
+   output.h $(TOPLEV_H) xcoffout.h debug.h $(GGC_H) $(TM_P_H) \
+   $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h $(BASIC_BLOCK_H) \
+   $(CFGLAYOUT_H) $(CGRAPH_H) targhooks.h tree-mudflap.h $(REAL_H) \
+   tree-iterator.h
+function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(CFGLAYOUT_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \
+   $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \
+   output.h $(TOPLEV_H) $(EXCEPT_H) $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \
+   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \
+   $(TREE_PASS_H) $(DF_H) $(TIMEVAR_H) vecprim.h
+statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TREE_PASS_H) $(TREE_DUMP_H) $(HASHTAB_H) statistics.h $(TM_H) $(FUNCTION_H)
+stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) insn-config.h hard-reg-set.h $(EXPR_H) \
+   libfuncs.h $(EXCEPT_H) $(RECOG_H) $(TOPLEV_H) output.h $(GGC_H) $(TM_P_H) \
+   langhooks.h $(PREDICT_H) $(OPTABS_H) $(TARGET_H) $(GIMPLE_H) $(MACHMODE_H) \
+   $(REGS_H) alloc-pool.h $(PRETTY_PRINT_H)
+except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) $(EXCEPT_H) $(FUNCTION_H) $(EXPR_H) libfuncs.h \
+   langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \
+   dwarf2asm.h dwarf2out.h $(TOPLEV_H) $(HASHTAB_H) intl.h $(GGC_H) \
+   gt-except.h $(CGRAPH_H) $(INTEGRATE_H) $(DIAGNOSTIC_H) $(DWARF2_H) \
+   $(TARGET_H) $(TM_P_H) $(TREE_PASS_H) $(TIMEVAR_H) $(TREE_FLOW_H)
+expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) $(EXPR_H) $(OPTABS_H) \
+   libfuncs.h $(INSN_ATTR_H) insn-config.h $(RECOG_H) output.h \
+   typeclass.h hard-reg-set.h $(TOPLEV_H) hard-reg-set.h $(EXCEPT_H) reload.h \
+   $(GGC_H) langhooks.h intl.h $(TM_P_H) $(REAL_H) $(TARGET_H) \
+   tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \
+   $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) vecprim.h $(SSAEXPAND_H)
+dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \
+   langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H) output.h
+builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(TARGET_H) $(FUNCTION_H) $(REGS_H) \
+   $(EXPR_H) $(OPTABS_H) insn-config.h $(RECOG_H) output.h typeclass.h \
+   hard-reg-set.h $(TOPLEV_H) hard-reg-set.h $(EXCEPT_H) $(TM_P_H) $(PREDICT_H) \
+   libfuncs.h $(REAL_H) langhooks.h $(BASIC_BLOCK_H) tree-mudflap.h \
+   $(BUILTINS_DEF) $(MACHMODE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) value-prof.h
+calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \
+   libfuncs.h $(REGS_H) $(TOPLEV_H) output.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_P_H) \
+   $(CGRAPH_H) $(EXCEPT_H) sbitmap.h $(DBGCNT_H) $(TREE_FLOW_H)
+expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(REAL_H) \
+   $(TOPLEV_H) $(TM_P_H) langhooks.h $(DF_H) $(TARGET_H)
+explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \
+   $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \
+   $(TOPLEV_H) $(EXCEPT_H) $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h \
+   $(TARGET_H) output.h
+optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \
+   $(RECOG_H) reload.h $(TOPLEV_H) $(GGC_H) $(REAL_H) $(TM_P_H) $(EXCEPT_H) \
+   gt-optabs.h $(BASIC_BLOCK_H) $(TARGET_H) $(FUNCTION_H)
+dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(FLAGS_H) $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) $(FUNCTION_H) \
+   langhooks.h insn-config.h reload.h $(GSTAB_H) xcoffout.h output.h dbxout.h \
+   $(TOPLEV_H) $(GGC_H) $(OBSTACK_H) $(EXPR_H) gt-dbxout.h
+debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
+sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) debug.h \
+   $(TREE_H) $(GGC_H) $(RTL_H) $(REGS_H) $(FLAGS_H) insn-config.h \
+   output.h $(TOPLEV_H) $(TM_P_H) gsyms.h langhooks.h $(TARGET_H) sdbout.h \
+   gt-sdbout.h reload.h $(VARRAY_H)
+dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) version.h $(RTL_H) $(DWARF2_H) debug.h $(FLAGS_H) insn-config.h \
+   output.h $(DIAGNOSTIC_H) $(REAL_H) hard-reg-set.h $(REGS_H) $(EXPR_H) \
+   libfuncs.h $(TOPLEV_H) dwarf2out.h reload.h $(GGC_H) $(EXCEPT_H) dwarf2asm.h \
+   $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) \
+   $(MD5_H) $(INPUT_H) $(FUNCTION_H) $(VARRAY_H) $(GIMPLE_H) $(TREE_PASS_H)
+dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \
+   gt-dwarf2asm.h $(DWARF2_H) $(SPLAY_TREE_H) $(TARGET_H)
+vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) version.h \
+   $(FLAGS_H) $(RTL_H) output.h vmsdbg.h debug.h langhooks.h $(FUNCTION_H) $(TARGET_H)
+xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) xcoffout.h $(FLAGS_H) $(TOPLEV_H) output.h dbxout.h \
+   $(GGC_H) $(TARGET_H) debug.h $(GSTAB_H) xcoff.h
+emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \
+   $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(TOPLEV_H) $(BASIC_BLOCK_H) \
+   $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h $(TREE_PASS_H) gt-emit-rtl.h \
+   $(REAL_H) $(DF_H) $(PARAMS_H) $(TARGET_H)
+real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(TOPLEV_H) $(TM_P_H) $(REAL_H) dfp.h
+dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)	$(TREE_H) \
+   $(TOPLEV_H) $(TM_P_H) $(REAL_H) $(DECNUM_H)
+fixed-value.o: fixed-value.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) fixed-value.h $(REAL_H) $(TOPLEV_H)
+integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \
+   $(EXPR_H) $(REAL_H) $(REGS_H) intl.h $(FUNCTION_H) output.h $(RECOG_H) \
+   $(EXCEPT_H) $(TOPLEV_H) $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h \
+   gt-integrate.h $(GGC_H) $(TREE_PASS_H) $(DF_H)
+jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) \
+   $(REAL_H) $(EXCEPT_H) $(FUNCTION_H) $(TREE_PASS_H) $(DIAGNOSTIC_H) \
+   $(TOPLEV_H) $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H) \
+   $(TIMEVAR_H) $(TARGET_H)
+simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h \
+   $(RECOG_H) $(EXPR_H) $(TOPLEV_H) output.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) \
+   $(TREE_H) $(TARGET_H)
+cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   langhooks.h $(TOPLEV_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \
+   gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \
+   $(TREE_INLINE_H) $(TREE_DUMP_H) $(TREE_FLOW_H) cif-code.def \
+   value-prof.h $(EXCEPT_H)
+cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h $(TREE_INLINE_H) $(TOPLEV_H) $(FLAGS_H) $(GGC_H) \
+   $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) \
+   $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) $(IPA_PROP_H) \
+   gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H)
+cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H)
+varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(CGRAPH_H) langhooks.h $(DIAGNOSTIC_H) $(HASHTAB_H) \
+   $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \
+   $(TREE_FLOW_H) gt-varpool.h
+ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \
+   $(TREE_PASS_H) $(TIMEVAR_H) $(GIMPLE_H) $(GGC_H)
+ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \
+   $(TREE_INLINE_H) $(TIMEVAR_H)
+ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \
+   $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \
+   $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \
+   $(TREE_INLINE_H) $(FIBHEAP_H) $(PARAMS_H)
+matrix-reorg.o : matrix-reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \
+   $(TM_H) $(TREE_H) $(RTL_H) $(TREE_INLINE_H) $(TREE_FLOW_H) \
+   tree-flow-inline.h langhooks.h $(HASHTAB_H) $(TOPLEV_H) $(FLAGS_H) $(GGC_H) \
+   debug.h $(TARGET_H) $(CGRAPH_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(PARAMS_H) \
+   $(FIBHEAP_H) intl.h $(FUNCTION_H) $(BASIC_BLOCK_H) $(CFGLOOP_H) \
+   tree-iterator.h $(TREE_PASS_H) opts.h $(TREE_DATA_REF_H) tree-ssa-sccvn.h
+ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \
+   $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \
+   $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H) $(EXCEPT_H)
+ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \
+   pointer-set.h $(GGC_H) $(GIMPLE_H) $(SPLAY_TREE_H) \
+   $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H)
+ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \
+   pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \
+   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \
+   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) gt-ipa-reference.h \
+   $(LTO_STREAMER_H)
+ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \
+   pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \
+   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) $(TIMEVAR_H) \
+   $(DIAGNOSTIC_H) $(CFGLOOP_H) $(SCEV_H) $(LTO_STREAMER_H)
+ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \
+   pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \
+   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \
+   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H)
+ipa-struct-reorg.o: ipa-struct-reorg.c ipa-struct-reorg.h $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(GIMPLE_H) tree-inline.h \
+   $(TREE_FLOW_H) langhooks.h pointer-set.h $(HASHTAB_H) $(TOPLEV_H) \
+   $(FLAGS_H) debug.h $(TARGET_H) $(CGRAPH_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \
+   $(PARAMS_H) $(FIBHEAP_H) intl.h $(FUNCTION_H) $(BASIC_BLOCK_H) tree-iterator.h \
+   $(TREE_PASS_H) opts.h $(IPA_TYPE_ESCAPE_H) $(TREE_DUMP_H) \
+   $(GIMPLE_H)
+
+coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \
+   $(FUNCTION_H) $(TOPLEV_H) $(GGC_H) langhooks.h $(COVERAGE_H) gt-coverage.h \
+   $(HASHTAB_H) tree-iterator.h $(CGRAPH_H) $(TREE_PASS_H) gcov-io.c $(TM_P_H)
+cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(RECOG_H) \
+   $(EMIT_RTL_H) $(TOPLEV_H) output.h $(FUNCTION_H) $(TREE_PASS_H) \
+   cselib.h gt-cselib.h $(GGC_H) $(TM_P_H) $(PARAMS_H) alloc-pool.h \
+   $(HASHTAB_H) $(TARGET_H)
+cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) $(EXPR_H) $(TOPLEV_H) \
+   output.h $(FUNCTION_H) $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \
+   $(EXCEPT_H) $(TARGET_H) $(PARAMS_H) rtlhooks-def.h $(TREE_PASS_H) \
+   $(REAL_H) $(DF_H) $(DBGCNT_H)
+dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(EXCEPT_H) $(DF_H) cselib.h \
+   $(DBGCNT_H) dce.h $(TIMEVAR_H) $(TREE_PASS_H) $(DBGCNT_H) $(TM_P_H)
+dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) $(TIMEVAR_H) \
+   $(TREE_PASS_H) alloc-pool.h $(ALIAS_H) dse.h $(OPTABS_H) $(TARGET_H)
+fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TOPLEV_H) insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \
+   output.h $(DF_H) alloc-pool.h $(TIMEVAR_H) $(TREE_PASS_H) $(TARGET_H) \
+   $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) domwalk.h
+web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
+   $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H)
+gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(GGC_H) \
+   $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
+   $(TM_P_H) $(PARAMS_H) cselib.h $(EXCEPT_H) gt-gcse.h $(TREE_H) $(TIMEVAR_H) \
+   intl.h $(OBSTACK_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H)
+store-motion.o : store-motion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(GGC_H) \
+   $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
+   $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(TIMEVAR_H) \
+   intl.h $(OBSTACK_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)
+resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) \
+   coretypes.h $(TM_H) $(REGS_H) $(FLAGS_H) output.h $(RESOURCE_H) $(DF_H) \
+   $(FUNCTION_H) $(TOPLEV_H) $(INSN_ATTR_H) $(EXCEPT_H) $(PARAMS_H) $(TM_P_H)
+lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \
+   hard-reg-set.h $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(RECOG_H) \
+   $(BASIC_BLOCK_H) $(TM_P_H) $(FUNCTION_H) output.h $(REAL_H)
+mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(INSN_ATTR_H) $(RECOG_H) $(BASIC_BLOCK_H) $(TM_P_H) $(FUNCTION_H) \
+   output.h $(TREE_PASS_H) $(TIMEVAR_H) $(REAL_H) $(DF_H)
+tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \
+    coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) $(BASIC_BLOCK_H) \
+    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(GIMPLE_H) $(CFGLOOP_H) $(SCEV_H)
+tree-call-cdce.o : tree-call-cdce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \
+    coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) $(BASIC_BLOCK_H) \
+    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(GIMPLE_H)
+tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \
+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \
+   $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \
+   $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h \
+   tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(TOPLEV_H) \
+   $(DBGCNT_H)
+tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \
+   $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) $(IPA_PROP_H) \
+   $(DIAGNOSTIC_H) statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) $(PARAMS_H) \
+   $(TARGET_H) $(FLAGS_H) $(EXPR_H)
+tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \
+    $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \
+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \
+    $(TREE_PASS_H) $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h \
+    $(GGC_H) $(OBSTACK_H) $(PARAMS_H) $(CPPLIB_H) $(PARAMS_H)
+tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+    $(TM_H) $(RTL_H) $(REAL_H) $(FLAGS_H) $(TREE_FLOW_H) $(GIMPLE_H) \
+    tree-iterator.h $(TREE_PASS_H) tree-ssa-propagate.h $(DIAGNOSTIC_H)
+tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
+    $(TM_H) $(TREE_FLOW_H) $(GIMPLE_H) tree-iterator.h $(TREE_PASS_H) \
+    $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \
+    langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \
+    coretypes.h insn-codes.h
+df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \
+   hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \
+   $(TM_P_H) $(FLAGS_H) output.h $(TREE_PASS_H) $(PARAMS_H)
+df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \
+   hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \
+   $(TM_P_H) $(FLAGS_H) output.h $(EXCEPT_H) dce.h vecprim.h
+df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \
+   hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \
+   $(TM_P_H) $(FLAGS_H) $(TARGET_H) $(TARGET_DEF_H) $(TREE_H) output.h \
+   $(TREE_PASS_H)
+df-byte-scan.o : df-byte-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TM_P_H) $(DF_H) output.h $(DBGCNT_H)
+regstat.o : regstat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TM_P_H) $(FLAGS_H) $(REGS_H) output.h $(EXCEPT_H) hard-reg-set.h \
+   $(BASIC_BLOCK_H) $(TIMEVAR_H) $(DF_H)
+var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \
+   $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \
+   $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \
+   cselib.h $(TARGET_H) $(TOPLEV_H) $(PARAMS_H) $(DIAGNOSTIC_H) pointer-set.h \
+   $(RECOG_H)
+profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \
+   $(TOPLEV_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \
+   $(CFGLOOP_H) $(TIMEVAR_H) $(TREE_PASS_H) profile.h
+mcf.o : mcf.c profile.h $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h \
+   $(BASIC_BLOCK_H) output.h langhooks.h $(GCOV_IO_H) $(TREE_H) 
+tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \
+   $(FUNCTION_H) $(TOPLEV_H) $(COVERAGE_H) $(TREE_H) value-prof.h $(TREE_DUMP_H) \
+   $(TREE_PASS_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(GGC_H) gt-tree-profile.h $(CGRAPH_H)
+value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \
+   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \
+   $(TREE_H) $(COVERAGE_H) $(RTL_H) $(GCOV_IO_H) $(TREE_FLOW_H) \
+   tree-flow-inline.h $(TIMEVAR_H) $(TREE_PASS_H) $(TOPLEV_H) pointer-set.h
+loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \
+   $(TOPLEV_H) $(CFGLOOP_H) output.h $(PARAMS_H) $(TARGET_H)
+alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)
+auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) insn-config.h \
+   $(REGS_H) $(FLAGS_H) output.h $(FUNCTION_H) $(EXCEPT_H) $(TOPLEV_H) $(RECOG_H) \
+   $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H)
+cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \
+   $(REGS_H) hard-reg-set.h output.h $(TOPLEV_H) $(FUNCTION_H) $(EXCEPT_H) $(GGC_H) \
+   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h \
+   $(HASHTAB_H) $(DF_H) $(CFGLOOP_H) $(TREE_FLOW_H) $(TREE_PASS_H)
+cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TOPLEV_H) $(CFGLOOP_H)
+cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) \
+   coretypes.h $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(TREE_PASS_H) $(RTL_H) \
+   $(DIAGNOSTIC_H) $(TOPLEV_H) $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H) \
+   value-prof.h $(TREE_INLINE_H) $(TARGET_H) $(SSAEXPAND_H)
+cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
+   output.h $(TOPLEV_H) $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) $(INSN_ATTR_H) \
+   insn-config.h $(EXPR_H) \
+   $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \
+   $(TREE_PASS_H) $(DF_H) $(GGC_H)
+cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(TM_P_H) \
+   $(TIMEVAR_H) $(OBSTACK_H) $(TOPLEV_H) vecprim.h
+cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h $(TOPLEV_H) \
+   $(FUNCTION_H) $(EXCEPT_H) $(TIMEVAR_H) $(TREE_H) $(EXPR_H)
+cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TIMEVAR_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \
+   $(TOPLEV_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \
+   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) $(TREE_PASS_H) $(CFGLOOP_H) $(EXPR_H) \
+   $(DF_H) $(DBGCNT_H) dce.h
+cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) $(FUNCTION_H) \
+   $(OBSTACK_H) $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_H) pointer-set.h output.h \
+   $(GGC_H)
+cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) \
+   $(OBSTACK_H) output.h graphds.h $(PARAMS_H)
+graphds.o : graphds.c graphds.h $(CONFIG_H) $(SYSTEM_H) $(BITMAP_H) $(OBSTACK_H) \
+   coretypes.h vec.h vecprim.h
+loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \
+   output.h intl.h $(TOPLEV_H) $(DF_H) $(HASHTAB_H)
+loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) \
+   coretypes.h $(TM_H) $(TM_P_H) $(FUNCTION_H) $(FLAGS_H) $(DF_H) \
+   $(OBSTACK_H) output.h $(HASHTAB_H) $(EXCEPT_H) $(PARAMS_H) $(REGS_H) ira.h
+cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) output.h \
+   coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H) $(TREE_FLOW_H)
+loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \
+   coretypes.h $(TM_H) $(OBSTACK_H) $(TREE_PASS_H) $(TIMEVAR_H) $(FLAGS_H) \
+   $(DF_H)
+loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \
+   output.h $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)
+loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \
+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \
+   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) \
+   $(OBSTACK_H)
+dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) $(TOPLEV_H) \
+   $(TIMEVAR_H) graphds.h vecprim.h pointer-set.h
+et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   et-forest.h alloc-pool.h $(BASIC_BLOCK_H)
+combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(FUNCTION_H) insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \
+   rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) $(REAL_H) hard-reg-set.h \
+   $(TOPLEV_H) $(TM_P_H) $(TREE_H) $(TARGET_H) output.h $(PARAMS_H) $(OPTABS_H) \
+   insn-codes.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) vecprim.h $(CGRAPH_H)
+reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) addresses.h $(REGS_H) insn-config.h \
+   $(RECOG_H) reload.h $(REAL_H) $(TOPLEV_H) $(FUNCTION_H) output.h $(GGC_H) \
+   $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-reginfo.h $(HASHTAB_H) \
+   $(TARGET_H) $(TREE_PASS_H) $(DF_H) ira.h
+bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(GGC_H) gt-bitmap.h $(BITMAP_H) $(OBSTACK_H) $(HASHTAB_H)
+varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \
+   $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) $(TOPLEV_H)
+vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \
+   $(TOPLEV_H) $(HASHTAB_H)
+reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) output.h $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) \
+   hard-reg-set.h insn-config.h $(REGS_H) $(FUNCTION_H) real.h $(TOPLEV_H) \
+   addresses.h $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H) $(DF_H) ira.h
+reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \
+   $(BASIC_BLOCK_H) $(RECOG_H) output.h $(FUNCTION_H) $(TOPLEV_H) $(TM_P_H) \
+   addresses.h $(EXCEPT_H) $(TREE_H) $(REAL_H) $(FLAGS_H) $(MACHMODE_H) \
+   $(OBSTACK_H) $(DF_H) $(TARGET_H) $(EMIT_RTL_H) ira.h
+rtlhooks.o :  rtlhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   rtlhooks-def.h $(EXPR_H) $(RECOG_H)
+postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(REAL_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \
+   hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \
+   $(FUNCTION_H) $(TOPLEV_H) cselib.h $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(MACHMODE_H) \
+   $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)
+postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
+   $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(TARGET_H) $(HASHTAB_H) intl.h $(OBSTACK_H) \
+   $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) $(REAL_H) $(DBGCNT_H)
+caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(FUNCTION_H) \
+   addresses.h $(RECOG_H) reload.h $(EXPR_H) $(TOPLEV_H) $(TM_P_H) $(DF_H) \
+   output.h gt-caller-save.h $(GGC_H)
+bt-load.o : bt-load.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(EXCEPT_H) \
+   $(RTL_H) hard-reg-set.h $(REGS_H) $(TM_P_H) $(FIBHEAP_H) output.h $(EXPR_H) \
+   $(TARGET_H) $(FLAGS_H) $(INSN_ATTR_H) $(FUNCTION_H) $(TREE_PASS_H) \
+   $(TOPLEV_H) $(DF_H) vecprim.h $(RECOG_H)
+reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   conditions.h hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h \
+   $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) $(FUNCTION_H) $(FLAGS_H) output.h \
+   $(EXPR_H) $(TOPLEV_H) $(PARAMS_H) $(TM_P_H) $(OBSTACK_H) $(RESOURCE_H) \
+   $(TIMEVAR_H) $(TARGET_H) $(TREE_PASS_H)
+alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) $(TOPLEV_H) output.h \
+   $(ALIAS_H) $(EMIT_RTL_H) $(GGC_H) $(FUNCTION_H) cselib.h $(TREE_H) $(TM_P_H) \
+   langhooks.h $(TARGET_H) gt-alias.h $(TIMEVAR_H) $(CGRAPH_H) \
+   $(SPLAY_TREE_H) $(VARRAY_H) $(IPA_TYPE_ESCAPE_H) $(DF_H) $(TREE_PASS_H) \
+   tree-ssa-alias.h pointer-set.h $(TREE_FLOW_H)
+stack-ptr-mod.o : stack-ptr-mod.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(RTL_H) $(REGS_H) $(EXPR_H) $(TREE_PASS_H) \
+   $(BASIC_BLOCK_H) $(FLAGS_H) output.h $(DF_H)
+init-regs.o : init-regs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(TREE_H) $(RTL_H) $(REGS_H) $(EXPR_H) $(TREE_PASS_H) \
+   $(BASIC_BLOCK_H) $(FLAGS_H) $(DF_H)
+ira-build.o: ira-build.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \
+   insn-config.h $(RECOG_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) \
+   $(PARAMS_H) $(DF_H) sparseset.h $(IRA_INT_H) output.h reload.h
+ira-costs.o: ira-costs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   hard-reg-set.h $(RTL_H) $(EXPR_H) $(TM_P_H) $(FLAGS_H) $(BASIC_BLOCK_H) \
+   $(REGS_H) addresses.h insn-config.h $(RECOG_H) $(TOPLEV_H) $(TARGET_H) \
+   $(PARAMS_H) $(IRA_INT_H)
+ira-conflicts.o: ira-conflicts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \
+   insn-config.h $(RECOG_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(PARAMS_H) \
+   $(DF_H) sparseset.h addresses.h $(IRA_INT_H)
+ira-color.o: ira-color.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \
+   $(EXPR_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) reload.h $(PARAMS_H) \
+   $(DF_H) $(SPLAY_TREE_H) $(IRA_INT_H)
+ira-emit.o: ira-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(REGS_H) $(RTL_H) $(TM_P_H) $(TARGET_H) $(FLAGS_H) hard-reg-set.h \
+   $(BASIC_BLOCK_H) $(EXPR_H) $(RECOG_H) $(PARAMS_H) $(TIMEVAR_H) \
+   $(TREE_PASS_H) output.h reload.h errors.h $(DF_H) $(IRA_INT_H)
+ira-lives.o: ira-lives.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TARGET_H) $(RTL_H) $(REGS_H) $(EXCEPT_H) hard-reg-set.h $(FLAGS_H) \
+   insn-config.h $(RECOG_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(PARAMS_H) \
+   $(DF_H) sparseset.h $(IRA_INT_H)
+ira.o: ira.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(REGS_H) $(RTL_H) $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(OBSTACK_H) \
+   $(BITMAP_H) hard-reg-set.h $(BASIC_BLOCK_H) \
+   $(EXPR_H) $(RECOG_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) output.h \
+   $(EXCEPT_H) reload.h errors.h $(INTEGRATE_H) $(DF_H) $(GGC_H) $(IRA_INT_H)
+regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   insn-config.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)\
+   $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \
+   $(EXPR_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(EXCEPT_H) ira.h reload.h
+combine-stack-adj.o : combine-stack-adj.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(RTL_H) insn-config.h $(TIMEVAR_H) $(TREE_PASS_H) \
+   $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \
+   $(EXPR_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(DF_H) $(EXCEPT_H) reload.h
+ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \
+   $(TOPLEV_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \
+   $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) \
+   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(BITMAP_H) \
+   hard-reg-set.h sbitmap.h $(TM_H)
+modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \
+   coretypes.h $(TARGET_H) $(TOPLEV_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \
+   $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) \
+   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \
+   cfghooks.h $(GCOV_IO_H) hard-reg-set.h $(TM_H) $(TIMEVAR_H) $(TREE_PASS_H) \
+   $(DF_H) $(DBGCNT_H)
+haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \
+   $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) $(TARGET_H) output.h \
+   $(PARAMS_H) $(DBGCNT_H) $(CFGLOOP_H) ira.h
+sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) cselib.h \
+   ira.h $(PARAMS_H) $(TM_P_H) ira.h $(TARGET_H)
+sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \
+   $(TM_P_H) sel-sched.h $(TARGET_H) $(CFGLAYOUT_H) $(TIMEVAR_H) $(TREE_PASS_H)  \
+   $(DBGCNT_H)
+sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) \
+   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H) output.h
+sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H) \
+   $(REAL_H) $(TREE_PASS_H) $(INSN_ATTR_H)
+sel-sched.o : sel-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \
+   $(TM_P_H) output.h $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H)  \
+   $(SCHED_INT_H) $(GGC_H) $(TREE_H) langhooks.h rtlhooks-def.h \
+   $(SEL_SCHED_IR_H) $(SEL_SCHED_DUMP_H) sel-sched.h $(DBGCNT_H)
+sel-sched-dump.o : sel-sched-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \
+   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H) $(TIMEVAR_H) $(TREE_PASS_H) \
+   $(SEL_SCHED_DUMP_H) $(GGC_H) $(TREE_H) $(LANGHOOKS_DEF_H) $(SEL_SCHED_IR_H) \
+   output.h $(BASIC_BLOCK_H) cselib.h
+sel-sched-ir.o : sel-sched-ir.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
+   $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \
+   $(TM_P_H) $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H) $(SCHED_INT_H) $(GGC_H) \
+   $(TREE_H) langhooks.h rtlhooks-def.h $(SEL_SCHED_IR_H) $(SEL_SCHED_DUMP_H)
+final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) intl.h $(REGS_H) $(RECOG_H) conditions.h \
+   insn-config.h $(INSN_ATTR_H) $(FUNCTION_H) output.h hard-reg-set.h \
+   $(EXCEPT_H) debug.h xcoffout.h $(TOPLEV_H) reload.h dwarf2out.h \
+   $(TREE_PASS_H) $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) \
+   $(CFGLAYOUT_H) dbxout.h $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) $(REAL_H) \
+   $(DF_H) vecprim.h $(GGC_H) $(CFGLOOP_H) $(PARAMS_H) $(TREE_FLOW_H)
+recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(FUNCTION_H) $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) \
+   $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(TOPLEV_H) output.h reload.h \
+   addresses.h $(TM_P_H) $(TIMEVAR_H) $(TREE_PASS_H) hard-reg-set.h $(REAL_H) \
+   $(DF_H) $(DBGCNT_H) $(TARGET_H)
+reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) $(RECOG_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \
+   insn-config.h $(TOPLEV_H) reload.h $(FUNCTION_H) $(TM_P_H) $(GGC_H) \
+   $(BASIC_BLOCK_H) $(CFGLAYOUT_H) output.h $(VARRAY_H) $(TIMEVAR_H) \
+   $(TREE_PASS_H) $(TARGET_H) vecprim.h $(DF_H)
+sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h
+predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) \
+   hard-reg-set.h output.h $(TOPLEV_H) $(RECOG_H) $(FUNCTION_H) $(EXCEPT_H) \
+   $(TM_P_H) $(PREDICT_H) sreal.h $(PARAMS_H) $(TARGET_H) $(CFGLOOP_H) \
+   $(COVERAGE_H) $(SCEV_H) $(GGC_H) predict.def $(TIMEVAR_H) $(TREE_DUMP_H) \
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(EXPR_H) pointer-set.h
+lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \
+   $(RTL_H) $(GGC_H) gt-lists.h
+bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(CFGLAYOUT_H) $(FIBHEAP_H) \
+   $(TARGET_H) $(FUNCTION_H) $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H) \
+   $(PARAMS_H) $(TOPLEV_H) $(TREE_PASS_H) $(DF_H)
+tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(TREE_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h $(CFGLAYOUT_H) \
+   $(FLAGS_H) $(TIMEVAR_H) $(PARAMS_H) $(COVERAGE_H) $(FIBHEAP_H) \
+   $(TREE_PASS_H) $(TREE_FLOW_H) $(TREE_INLINE_H)
+cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \
+   $(FUNCTION_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(TARGET_H) gt-cfglayout.h \
+   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H) $(TREE_PASS_H) vecprim.h \
+   $(DF_H)
+timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(TIMEVAR_H) $(FLAGS_H) intl.h $(TOPLEV_H) $(RTL_H) timevar.def
+regcprop.o : regcprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
+   output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \
+   addresses.h reload.h $(TOPLEV_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)
+regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
+   output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \
+   addresses.h reload.h $(TOPLEV_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)
+ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   $(REGS_H) $(TOPLEV_H) $(FLAGS_H) insn-config.h $(FUNCTION_H) $(RECOG_H) \
+   $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h $(EXCEPT_H) $(TM_P_H) \
+   $(REAL_H) $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h $(TIMEVAR_H) \
+   $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)
+lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \
+   $(TM_H) coretypes.h $(TREE_H) $(TREE_FLOW_H)
+lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \
+   $(TM_H) coretypes.h $(TARGET_H) $(TREE_H) $(TREE_FLOW_H)
+lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \
+   $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   $(TREE_DATA_REF_H) $(EXPR_H) coretypes.h $(TARGET_H) \
+   $(TREE_PASS_H) vec.h vecprim.h $(OBSTACK_H) pointer-set.h
+params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) \
+   $(TOPLEV_H)
+pointer-set.o: pointer-set.c pointer-set.h $(CONFIG_H) $(SYSTEM_H)
+hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)
+pretty-print.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h $(PRETTY_PRINT_H) \
+   $(TREE_H) $(GGC_H)
+errors.o : errors.c $(CONFIG_H) $(SYSTEM_H) errors.h $(BCONFIG_H)
+dbgcnt.o: dbgcnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h errors.h $(DBGCNT_H) \
+   $(TM_H) $(RTL_H) output.h
+lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(MACHMODE_H) $(TM_H) $(RTL_H) $(TM_P_H) $(TIMEVAR_H) $(FLAGS_H) \
+   insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) $(OBSTACK_H) $(BITMAP_H) \
+   $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H)
+
+$(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \
+   output.h $(INSN_ATTR_H) $(SYSTEM_H) $(TOPLEV_H) $(TARGET_H) libfuncs.h \
+   $(TARGET_DEF_H) $(FUNCTION_H) $(SCHED_INT_H) $(TM_P_H) $(EXPR_H) \
+   langhooks.h $(GGC_H) $(OPTABS_H) $(REAL_H) tm-constrs.h $(GIMPLE_H) $(DF_H) \
+   cselib.h
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+		$(out_file) $(OUTPUT_OPTION)
+
+# Build auxiliary files that support ecoff format.
+mips-tfile: mips-tfile.o version.o $(LIBDEPS)
+	$(LINKER) $(LINKERFLAGS) $(LDFLAGS) -o $@ \
+		mips-tfile.o version.o $(LIBS)
+
+mips-tfile.o : mips-tfile.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) version.h $(srcdir)/../include/getopt.h $(GSTAB_H) intl.h
+
+mips-tdump: mips-tdump.o version.o $(LIBDEPS)
+	$(LINKER) $(LINKERFLAGS) $(LDFLAGS) -o $@ \
+		mips-tdump.o version.o $(LIBS)
+
+mips-tdump.o : mips-tdump.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) version.h $(srcdir)/../include/getopt.h stab.def
+
+# FIXME: writing proper dependencies for this is a *LOT* of work.
+libbackend.o : $(OBJS-common:.o=.c) $(out_file) \
+  insn-config.h insn-flags.h insn-codes.h insn-constants.h \
+  insn-attr.h  $(DATESTAMP) $(BASEVER) $(DEVPHASE) gcov-iov.h
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	  -DTARGET_NAME=\"$(target_noncanonical)\" \
+	  -DLOCALEDIR=\"$(localedir)\" \
+	  -c $(filter %.c,$^) -o $@  \
+	  -DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \
+	  -DREVISION=$(REVISION_s) \
+	  -DDEVPHASE=$(DEVPHASE_s) -DPKGVERSION=$(PKGVERSION_s) \
+	  -DBUGURL=$(BUGURL_s) -combine
+
+#
+# Generate header and source files from the machine description,
+# and compile them.
+
+.PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \
+  insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \
+  insn-attr.h insn-attrtab.c insn-preds.c
+
+# Dependencies for the md file.  The first time through, we just assume
+# the md file itself and the generated dependency file (in order to get
+# it built).  The second time through we have the dependency file.
+-include mddeps.mk
+MD_DEPS = s-mddeps $(md_file) $(MD_INCLUDES)
+
+s-mddeps: $(md_file) $(MD_INCLUDES) build/genmddeps$(build_exeext)
+	$(RUN_GEN) build/genmddeps$(build_exeext) $(md_file) > tmp-mddeps
+	$(SHELL) $(srcdir)/../move-if-change tmp-mddeps mddeps.mk
+	$(STAMP) s-mddeps
+
+# Header dependencies for generated source files.
+genrtl.o : genrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)	$(RTL_H)\
+  $(GGC_H) $(OBSTACK_H)
+insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(TM_H) $(RTL_H) $(REGS_H) $(REAL_H) output.h $(INSN_ATTR_H)		\
+  insn-config.h $(TOPLEV_H) $(RECOG_H) $(TM_P_H) $(FLAGS_H)
+insn-automata.o : insn-automata.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(TM_H) $(RTL_H) $(REGS_H) $(REAL_H) output.h $(INSN_ATTR_H)		\
+  insn-config.h $(TOPLEV_H) $(RECOG_H) $(TM_P_H) $(FLAGS_H)
+insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)	\
+  $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(REAL_H)	\
+  dfp.h $(FLAGS_H) output.h insn-config.h hard-reg-set.h $(RECOG_H)	\
+  $(RESOURCE_H) reload.h $(TOPLEV_H) $(REGS_H) tm-constrs.h $(GGC_H)	\
+  $(BASIC_BLOCK_H) $(INTEGRATE_H)
+insn-extract.o : insn-extract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(TM_H) $(RTL_H) $(TOPLEV_H) insn-config.h $(RECOG_H)
+insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	$(TM_H) \
+  $(MACHMODE_H) $(REAL_H)
+insn-opinit.o : insn-opinit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(TM_H) $(RTL_H) $(TM_P_H) insn-config.h $(FLAGS_H) $(RECOG_H)	\
+  $(EXPR_H) $(OPTABS_H) reload.h
+insn-output.o : insn-output.c $(CONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(TM_H) $(RTL_H) $(GGC_H) $(REGS_H) $(REAL_H) conditions.h		\
+  hard-reg-set.h insn-config.h $(INSN_ATTR_H) $(EXPR_H) output.h	\
+  $(RECOG_H) $(FUNCTION_H) $(TOPLEV_H) $(FLAGS_H) insn-codes.h $(TM_P_H)	\
+  $(TARGET_H) tm-constrs.h
+insn-peep.o : insn-peep.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)	\
+  insn-config.h $(RTL_H) $(TM_P_H) $(REGS_H) output.h $(REAL_H)		\
+  $(RECOG_H) $(EXCEPT_H) $(FUNCTION_H) $(TOPLEV_H) $(FLAGS_H) tm-constrs.h
+insn-preds.o : insn-preds.c $(CONFIG_H) $(SYSTEM_H) coretypes.h		\
+  $(TM_H) $(RTL_H) $(TREE_H) insn-config.h $(RECOG_H) output.h		\
+  $(FLAGS_H) $(FUNCTION_H) hard-reg-set.h $(RESOURCE_H) $(TM_P_H)	\
+  $(TOPLEV_H) reload.h $(REGS_H) $(REAL_H) tm-constrs.h
+insn-recog.o : insn-recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h		\
+  $(TM_H) $(RTL_H) insn-config.h $(RECOG_H) output.h $(FLAGS_H)		\
+  $(FUNCTION_H) hard-reg-set.h $(RESOURCE_H) $(TM_P_H) $(TOPLEV_H)		\
+  reload.h $(REAL_H) $(REGS_H) tm-constrs.h
+
+# For each of the files generated by running a generator program over
+# the machine description, the following pair of static pattern rules
+# runs the generator program only if the machine description has changed,
+# but touches the target file only when its contents actually change.
+# The "; @true" construct forces Make to recheck the timestamp on the
+# target file.
+
+simple_generated_h = insn-attr.h insn-codes.h insn-config.h insn-flags.h
+
+simple_generated_c = insn-attrtab.c insn-automata.c insn-emit.c \
+		     insn-extract.c insn-opinit.c insn-output.c \
+		     insn-peep.c insn-recog.c
+
+$(simple_generated_h): insn-%.h: s-%; @true
+
+$(simple_generated_h:insn-%.h=s-%): s-%: build/gen%$(build_exeext) \
+  $(MD_DEPS) insn-conditions.md
+	$(RUN_GEN) build/gen$*$(build_exeext) $(md_file) \
+	  insn-conditions.md > tmp-$*.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-$*.h insn-$*.h
+	$(STAMP) s-$*
+
+$(simple_generated_c): insn-%.c: s-%; @true
+$(simple_generated_c:insn-%.c=s-%): s-%: build/gen%$(build_exeext) \
+  $(MD_DEPS) insn-conditions.md
+	$(RUN_GEN) build/gen$*$(build_exeext) $(md_file) \
+	  insn-conditions.md > tmp-$*.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-$*.c insn-$*.c
+	$(STAMP) s-$*
+
+generated_files = config.h tm.h $(TM_P_H) $(TM_H) multilib.h \
+       $(simple_generated_h) specs.h \
+       tree-check.h genrtl.h insn-modes.h tm-preds.h tm-constrs.h \
+       $(ALL_GTFILES_H) gtype-desc.c gtype-desc.h gcov-iov.h
+
+# In order for parallel make to really start compiling the expensive
+# objects from $(OBJS-common) as early as possible, build all their
+# prerequisites strictly before all objects.
+$(ALL_HOST_OBJS) : | $(generated_files)
+
+# genconstants needs to run before insn-conditions.md is available
+# (because the constants may be used in the conditions).
+insn-constants.h: s-constants; @true
+s-constants: build/genconstants$(build_exeext) $(MD_DEPS)
+	$(RUN_GEN) build/genconstants$(build_exeext) $(md_file) \
+	  > tmp-constants.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-constants.h insn-constants.h
+	$(STAMP) s-constants
+
+# gencheck doesn't read the machine description, and the file produced
+# doesn't use the insn-* convention.
+tree-check.h: s-check ; @true
+s-check : build/gencheck$(build_exeext)
+	$(RUN_GEN) build/gencheck$(build_exeext) > tmp-check.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h
+	$(STAMP) s-check
+
+# gencondmd doesn't use the standard naming convention.
+build/gencondmd.c: s-conditions; @true
+s-conditions: $(MD_DEPS) build/genconditions$(build_exeext)
+	$(RUN_GEN) build/genconditions$(build_exeext) $(md_file) > tmp-condmd.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-condmd.c build/gencondmd.c
+	$(STAMP) s-conditions
+
+insn-conditions.md: s-condmd; @true
+s-condmd: build/gencondmd$(build_exeext)
+	$(RUN_GEN) build/gencondmd$(build_exeext) > tmp-cond.md
+	$(SHELL) $(srcdir)/../move-if-change tmp-cond.md insn-conditions.md
+	$(STAMP) s-condmd
+
+
+# These files are generated by running the same generator more than
+# once with different options, so they have custom rules.  The
+# stampfile idiom is the same.
+genrtl.c: s-genrtl; @true
+genrtl.h: s-genrtl-h; @true
+
+s-genrtl: build/gengenrtl$(build_exeext)
+	$(RUN_GEN) build/gengenrtl$(build_exeext) > tmp-genrtl.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-genrtl.c genrtl.c
+	$(STAMP) s-genrtl
+
+s-genrtl-h: build/gengenrtl$(build_exeext)
+	$(RUN_GEN) build/gengenrtl$(build_exeext) -h > tmp-genrtl.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-genrtl.h genrtl.h
+	$(STAMP) s-genrtl-h
+
+insn-modes.c: s-modes; @true
+insn-modes.h: s-modes-h; @true
+min-insn-modes.c: s-modes-m; @true
+
+s-modes: build/genmodes$(build_exeext)
+	$(RUN_GEN) build/genmodes$(build_exeext) > tmp-modes.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes.c insn-modes.c
+	$(STAMP) s-modes
+
+s-modes-h: build/genmodes$(build_exeext)
+	$(RUN_GEN) build/genmodes$(build_exeext) -h > tmp-modes.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes.h insn-modes.h
+	$(STAMP) s-modes-h
+
+s-modes-m: build/genmodes$(build_exeext)
+	$(RUN_GEN) build/genmodes$(build_exeext) -m > tmp-min-modes.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-min-modes.c min-insn-modes.c
+	$(STAMP) s-modes-m
+
+insn-preds.c: s-preds; @true
+tm-preds.h: s-preds-h; @true
+tm-constrs.h: s-constrs-h; @true
+
+s-preds: $(MD_DEPS) build/genpreds$(build_exeext)
+	$(RUN_GEN) build/genpreds$(build_exeext) $(md_file) > tmp-preds.c
+	$(SHELL) $(srcdir)/../move-if-change tmp-preds.c insn-preds.c
+	$(STAMP) s-preds
+
+s-preds-h: $(MD_DEPS) build/genpreds$(build_exeext)
+	$(RUN_GEN) build/genpreds$(build_exeext) -h $(md_file) > tmp-preds.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-preds.h tm-preds.h
+	$(STAMP) s-preds-h
+
+s-constrs-h: $(MD_DEPS) build/genpreds$(build_exeext)
+	$(RUN_GEN) build/genpreds$(build_exeext) -c $(md_file) > tmp-constrs.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-constrs.h tm-constrs.h
+	$(STAMP) s-constrs-h
+
+GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \
+  $(host_xm_file_list) \
+  $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \
+  $(srcdir)/alias.h $(srcdir)/coverage.c $(srcdir)/rtl.h \
+  $(srcdir)/vecprim.h \
+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/varray.h $(srcdir)/libfuncs.h $(SYMTAB_H) \
+  $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \
+  $(srcdir)/fixed-value.h \
+  $(srcdir)/ipa-reference.h $(srcdir)/output.h $(srcdir)/cfgloop.h \
+  $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \
+  $(srcdir)/reload.h $(srcdir)/caller-save.c \
+  $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \
+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c $(srcdir)/matrix-reorg.c \
+  $(srcdir)/dbxout.c $(srcdir)/ipa-struct-reorg.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \
+  $(srcdir)/tree-vect-generic.c \
+  $(srcdir)/dojump.c \
+  $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \
+  $(srcdir)/expr.h \
+  $(srcdir)/function.c $(srcdir)/except.c \
+  $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \
+  $(srcdir)/profile.c $(srcdir)/reginfo.c $(srcdir)/mcf.c \
+  $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \
+  $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \
+  $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \
+  $(srcdir)/gimple.h $(srcdir)/gimple.c \
+  $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h \
+  $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \
+  $(srcdir)/tree-cfg.c \
+  $(srcdir)/tree-dfa.c \
+  $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \
+  $(srcdir)/tree-chrec.h \
+  $(srcdir)/tree-scalar-evolution.c \
+  $(srcdir)/tree-ssa-operands.h \
+  $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \
+  $(srcdir)/varpool.c \
+  $(srcdir)/tree-parloops.c \
+  $(srcdir)/omp-low.c \
+  $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \
+  $(srcdir)/tree-ssa-propagate.c \
+  $(srcdir)/tree-phinodes.c \
+  $(srcdir)/ipa-reference.c \
+  $(srcdir)/tree-ssa-structalias.c \
+  $(srcdir)/lto-symtab.c \
+  $(srcdir)/tree-ssa-alias.h \
+  $(srcdir)/ipa-prop.h \
+  @all_gtfiles@
+
+# Compute the list of GT header files from the corresponding C sources,
+# possibly nested within config or language subdirectories.  Match gengtype's
+# behavior in this respect: gt-LANG-file.h for "file" anywhere within a LANG
+# language subdir, gt-file.h otherwise (no subdir indication for config/
+# related sources).
+
+GTFILES_H = $(subst /,-, \
+	    $(shell echo $(patsubst $(srcdir)/%,gt-%, \
+			   $(patsubst %.c,%.h, \
+			     $(filter %.c, $(GTFILES)))) \
+			| sed -e "s|/[^ ]*/|/|g" -e "s|gt-config/|gt-|g"))
+
+GTFILES_LANG_H = $(patsubst [%], gtype-%.h, $(filter [%], $(GTFILES)))
+ALL_GTFILES_H := $(sort $(GTFILES_H) $(GTFILES_LANG_H))
+
+# $(GTFILES) may be too long to put on a command line, so we have to
+# write it out to a file (taking care not to do that in a way that
+# overflows a command line!) and then have gengtype read the file in.
+
+$(ALL_GTFILES_H) gtype-desc.c gtype-desc.h : s-gtype ; @true
+
+gtyp-input.list: s-gtyp-input ; @true
+s-gtyp-input: Makefile
+	@: $(call write_entries_to_file,$(GTFILES),tmp-gi.list)
+	$(SHELL) $(srcdir)/../move-if-change tmp-gi.list gtyp-input.list
+	$(STAMP) s-gtyp-input
+
+s-gtype: build/gengtype$(build_exeext) $(filter-out [%], $(GTFILES)) \
+	 gtyp-input.list
+	$(RUN_GEN) build/gengtype$(build_exeext) $(srcdir) gtyp-input.list
+	$(STAMP) s-gtype
+
+#
+# How to compile object files to run on the build machine.
+
+build/%.o :  # dependencies provided by explicit rule later
+	$(COMPILER_FOR_BUILD) -c $(BUILD_COMPILERFLAGS) $(BUILD_CPPFLAGS) \
+		-o $@ $<
+
+# Header dependencies for the programs that generate source code.
+# These are library modules...
+build/errors.o : errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h
+build/gensupport.o: gensupport.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) errors.h $(HASHTAB_H)		\
+  gensupport.h
+build/ggc-none.o : ggc-none.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h 	\
+  $(GGC_H)
+build/min-insn-modes.o : min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H)	\
+  $(MACHMODE_H)
+build/print-rtl.o: print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(GTM_H) $(RTL_BASE_H)
+build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) gensupport.h
+build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)	\
+  $(RTL_H) $(REAL_H) $(GGC_H) errors.h
+build/vec.o : vec.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h vec.h \
+   $(GGC_H) $(TOPLEV_H)
+build/gencondmd.o : build/gencondmd.c $(BCONFIG_H) $(SYSTEM_H)		\
+  coretypes.h $(GTM_H) insn-constants.h $(RTL_H) $(TM_P_H)		\
+  $(FUNCTION_H) $(REGS_H) $(RECOG_H) $(REAL_H) output.h $(FLAGS_H)	\
+  $(RESOURCE_H) $(TOPLEV_H) reload.h $(EXCEPT_H) tm-constrs.h
+# This pulls in tm-pred.h which contains inline functions wrapping up
+# predicates from the back-end so those functions must be discarded.
+# No big deal since gencondmd.c is a dummy file for non-GCC compilers.
+build/gencondmd.o : \
+  BUILD_CFLAGS := $(filter-out -fkeep-inline-functions, $(BUILD_CFLAGS))
+
+# ...these are the programs themselves.
+build/genattr.o : genattr.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)		\
+  $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)	\
+  gensupport.h
+build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)		\
+  $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h vec.h		\
+  $(HASHTAB_H) gensupport.h
+build/gencheck.o : gencheck.c all-tree.def $(BCONFIG_H) $(GTM_H)	\
+	$(SYSTEM_H) coretypes.h $(lang_tree_files) gimple.def
+build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)
+build/gencodes.o : gencodes.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+build/genconditions.o : genconditions.c $(RTL_BASE_H) $(BCONFIG_H)	\
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h
+build/genconfig.o : genconfig.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+build/genconstants.o : genconstants.c $(RTL_BASE_H) $(BCONFIG_H)	\
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h
+build/genemit.o : genemit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)		\
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h vecprim.h
+build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)	\
+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h
+build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def
+build/gengtype-lex.o : gengtype-lex.c gengtype.h $(BCONFIG_H) $(SYSTEM_H)
+build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)	\
+  $(SYSTEM_H)
+build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h 	\
+  rtl.def insn-notes.def errors.h double-int.h
+build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h	\
+  $(GTM_H) $(RTL_BASE_H) errors.h gensupport.h
+build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h		\
+  $(HASHTAB_H) machmode.def $(extra_modes_file)
+build/genopinit.o : genopinit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+build/genoutput.o : genoutput.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+build/genpeep.o : genpeep.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h $(TOPLEV_H)
+build/genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h $(OBSTACK_H)
+build/genrecog.o : genrecog.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)	\
+  coretypes.h $(GTM_H) errors.h gensupport.h
+
+# Compile the programs that generate insn-* from the machine description.
+# They are compiled with $(COMPILER_FOR_BUILD), and associated libraries,
+# since they need to run on this machine
+# even if GCC is being compiled to run on some other machine.
+
+# As a general rule...
+build/gen%$(build_exeext): build/gen%.o $(BUILD_LIBDEPS)
+	$(LINKER_FOR_BUILD) $(BUILD_LINKERFLAGS) $(BUILD_LDFLAGS) -o $@ \
+	    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)
+
+# All these programs use the MD reader ($(BUILD_RTL)).
+genprogmd = attr attrtab automata codes conditions config constants emit \
+	    extract flags mddeps opinit output peep preds recog
+$(genprogmd:%=build/gen%$(build_exeext)): $(BUILD_RTL) $(BUILD_ERRORS)
+
+# These programs need libs over and above what they get from the above list.
+build/genautomata$(build_exeext) : BUILD_LIBS += -lm
+
+# These programs are not linked with the MD reader.
+build/gengenrtl$(build_exeext) : $(BUILD_ERRORS)
+build/genmodes$(build_exeext) : $(BUILD_ERRORS)
+build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o \
+				$(BUILD_ERRORS)
+
+# Generated source files for gengtype.
+gengtype-lex.c : gengtype-lex.l
+	-$(FLEX) $(FLEXFLAGS) -o$@ $<
+
+#
+# Remake internationalization support.
+intl.o: intl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h Makefile
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	  -DLOCALEDIR=\"$(localedir)\" \
+	  -c $(srcdir)/intl.c $(OUTPUT_OPTION)
+
+#
+# Remake cpp.
+
+PREPROCESSOR_DEFINES = \
+  -DGCC_INCLUDE_DIR=\"$(libsubdir)/include\" \
+  -DFIXED_INCLUDE_DIR=\"$(libsubdir)/include-fixed\" \
+  -DGPLUSPLUS_INCLUDE_DIR=\"$(gcc_gxx_include_dir)\" \
+  -DGPLUSPLUS_TOOL_INCLUDE_DIR=\"$(gcc_gxx_include_dir)/$(target_noncanonical)\" \
+  -DGPLUSPLUS_BACKWARD_INCLUDE_DIR=\"$(gcc_gxx_include_dir)/backward\" \
+  -DLOCAL_INCLUDE_DIR=\"$(local_includedir)\" \
+  -DCROSS_INCLUDE_DIR=\"$(CROSS_SYSTEM_HEADER_DIR)\" \
+  -DTOOL_INCLUDE_DIR=\"$(gcc_tooldir)/include\" \
+  -DPREFIX=\"$(prefix)/\" \
+  -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc/\" \
+  @TARGET_SYSTEM_ROOT_DEFINE@
+
+cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+	cppdefault.h Makefile
+	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+	  $(PREPROCESSOR_DEFINES) \
+	  -c $(srcdir)/cppdefault.c $(OUTPUT_OPTION)
+
+# Note for the stamp targets, we run the program `true' instead of
+# having an empty command (nothing following the semicolon).
+
+# gcov-iov.c is run on the build machine to generate gcov-iov.h from version.c
+build/gcov-iov.o: gcov-iov.c $(BCONFIG_H) coretypes.h $(GTM_H) \
+  $(SYSTEM_H) coretypes.h $(TM_H)
+
+build/gcov-iov$(build_exeext): build/gcov-iov.o
+	$(LINKER_FOR_BUILD) $(BUILD_LINKERFLAGS) $(BUILD_LDFLAGS) \
+		build/gcov-iov.o -o $@
+
+gcov-iov.h: s-iov
+s-iov: build/gcov-iov$(build_exeext) $(BASEVER) $(DEVPHASE)
+	build/gcov-iov$(build_exeext) '$(BASEVER_c)' '$(DEVPHASE_c)' \
+	    > tmp-gcov-iov.h
+	$(SHELL) $(srcdir)/../move-if-change tmp-gcov-iov.h gcov-iov.h
+	$(STAMP) s-iov
+
+gcov.o: gcov.c gcov-io.c $(GCOV_IO_H) intl.h $(SYSTEM_H) coretypes.h $(TM_H) \
+   $(CONFIG_H) version.h
+gcov-dump.o: gcov-dump.c gcov-io.c $(GCOV_IO_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(CONFIG_H) version.h
+
+GCOV_OBJS = gcov.o intl.o version.o errors.o
+gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@
+GCOV_DUMP_OBJS = gcov-dump.o version.o errors.o
+gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
+	$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \
+		$(LIBS) -o $@
+#
+# Build the include directories.  The stamp files are stmp-* rather than
+# s-* so that mostlyclean does not force the include directory to
+# be rebuilt.
+
+# Build the include directories.
+stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) $(UNWIND_H) fixinc_list
+# Copy in the headers provided with gcc.
+# The sed command gets just the last file name component;
+# this is necessary because VPATH could add a dirname.
+# Using basename would be simpler, but some systems don't have it.
+# The touch command is here to workaround an AIX/Linux NFS bug.
+	-if [ -d include ] ; then true; else mkdir include; chmod a+rx include; fi
+	-if [ -d include-fixed ] ; then true; else mkdir include-fixed; chmod a+rx include-fixed; fi
+	for file in .. $(USER_H); do \
+	  if [ X$$file != X.. ]; then \
+	    realfile=`echo $$file | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(STAMP) include/$$realfile; \
+	    rm -f include/$$realfile; \
+	    cp $$file include; \
+	    chmod a+r include/$$realfile; \
+	  fi; \
+	done
+	rm -f include/unwind.h
+	cp $(UNWIND_H) include/unwind.h
+	chmod a+r include/unwind.h
+	rm -f include/stdint.h
+	if [ $(USE_GCC_STDINT) = wrap ]; then \
+	  rm -f include/stdint-gcc.h; \
+	  cp $(srcdir)/ginclude/stdint-gcc.h include/stdint-gcc.h; \
+	  chmod a+r include/stdint-gcc.h; \
+	  cp $(srcdir)/ginclude/stdint-wrap.h include/stdint.h; \
+	  chmod a+r include/stdint.h; \
+	elif [ $(USE_GCC_STDINT) = provide ]; then \
+	  cp $(srcdir)/ginclude/stdint-gcc.h include/stdint.h; \
+	  chmod a+r include/stdint.h; \
+	fi
+	set -e; for ml in `cat fixinc_list`; do \
+	  sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \
+	  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	  fix_dir=include-fixed$${multi_dir}; \
+	  if $(LIMITS_H_TEST) ; then \
+	    cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
+	  else \
+	    cat $(srcdir)/glimits.h > tmp-xlimits.h; \
+	  fi; \
+	  $(mkinstalldirs) $${fix_dir}; \
+	  chmod a+rx $${fix_dir} || true; \
+	  rm -f $${fix_dir}/limits.h; \
+	  mv tmp-xlimits.h $${fix_dir}/limits.h; \
+	  chmod a+r $${fix_dir}/limits.h; \
+	done
+# Install the README
+	rm -f include-fixed/README
+	cp $(srcdir)/../fixincludes/README-fixinc include-fixed/README
+	chmod a+r include-fixed/README
+	$(STAMP) $@
+
+.PHONY: install-gcc-tooldir
+install-gcc-tooldir:
+	$(mkinstalldirs) $(DESTDIR)$(gcc_tooldir)
+
+macro_list: s-macro_list; @true
+s-macro_list : $(GCC_PASSES)
+	echo | $(GCC_FOR_TARGET) -E -dM - | \
+	  sed -n -e 's/^#define \([^_][a-zA-Z0-9_]*\).*/\1/p' \
+		 -e 's/^#define \(_[^_A-Z][a-zA-Z0-9_]*\).*/\1/p' | \
+	  sort -u > tmp-macro_list
+	$(SHELL) $(srcdir)/../move-if-change tmp-macro_list macro_list
+	$(STAMP) s-macro_list
+
+fixinc_list: s-fixinc_list; @true
+s-fixinc_list : $(GCC_PASSES)
+# Build up a list of multilib directories and corresponding sysroot
+# suffixes, in form sysroot;multilib.
+	if $(GCC_FOR_TARGET) -print-sysroot-headers-suffix > /dev/null 2>&1; then \
+	  set -e; for ml in `$(GCC_FOR_TARGET) -print-multi-lib`; do \
+	    multi_dir=`echo $${ml} | sed -e 's/;.*$$//'`; \
+	    flags=`echo $${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`; \
+	    sfx=`$(GCC_FOR_TARGET) $${flags} -print-sysroot-headers-suffix`; \
+	    if [ "$${multi_dir}" = "." ]; \
+	      then multi_dir=""; \
+	    else \
+	      multi_dir=/$${multi_dir}; \
+	    fi; \
+	    echo "$${sfx};$${multi_dir}"; \
+	  done; \
+	else \
+	  echo ";"; \
+	fi > tmp-fixinc_list
+	$(SHELL) $(srcdir)/../move-if-change tmp-fixinc_list fixinc_list
+	$(STAMP) s-fixinc_list
+
+# The line below is supposed to avoid accidentally matching the
+# built-in suffix rule `.o:' to build fixincl out of fixincl.o.  You'd
+# expect fixincl to be newer than fixincl.o, such that this situation
+# would never come up.  As it turns out, if you use ccache with
+# CCACHE_HARDLINK enabled, the compiler doesn't embed the current
+# working directory in object files (-g absent, or -fno-working-dir
+# present), and build and host are the same, fixincl for the host will
+# build after fixincl for the build machine, getting a cache hit,
+# thereby updating the timestamp of fixincl.o in the host tree.
+# Because of CCACHE_HARDLINK, this will also update the timestamp in
+# the build tree, and so fixincl in the build tree will appear to be
+# out of date.  Yuck.
+../$(build_subdir)/fixincludes/fixincl: ; @ :
+
+# Build fixed copies of system files.
+# Abort if no system headers available, unless building a crosscompiler.
+# FIXME: abort unless building --without-headers would be more accurate and less ugly
+stmp-fixinc: gsyslimits.h macro_list fixinc_list \
+  $(build_objdir)/fixincludes/fixincl \
+  $(build_objdir)/fixincludes/fixinc.sh
+	rm -rf include-fixed; mkdir include-fixed
+	-chmod a+rx include-fixed
+	if [ -d ../prev-gcc ]; then \
+	  cd ../prev-gcc && \
+	  $(MAKE) real-$(INSTALL_HEADERS_DIR) DESTDIR=`pwd`/../gcc/ \
+	    libsubdir=. ; \
+	else \
+	  set -e; for ml in `cat fixinc_list`; do \
+	    sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \
+	    multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	    fix_dir=include-fixed$${multi_dir}; \
+	    if ! $(inhibit_libc) && test ! -d ${SYSTEM_HEADER_DIR}; then \
+	      echo The directory that should contain system headers does not exist: >&2 ; \
+	      echo "  ${SYSTEM_HEADER_DIR}" >&2 ; \
+	      tooldir_sysinc=`echo "${gcc_tooldir}/sys-include" | sed -e :a -e "s,[^/]*/\.\.\/,," -e ta`; \
+	      if test "x${SYSTEM_HEADER_DIR}" = "x$${tooldir_sysinc}"; \
+	      then sleep 1; else exit 1; fi; \
+	    fi; \
+	    $(mkinstalldirs) $${fix_dir}; \
+	    chmod a+rx $${fix_dir} || true; \
+	    (TARGET_MACHINE='$(target)'; srcdir=`cd $(srcdir); ${PWD_COMMAND}`; \
+	      SHELL='$(SHELL)'; MACRO_LIST=`${PWD_COMMAND}`/macro_list ; \
+	      gcc_dir=`${PWD_COMMAND}` ; \
+	      export TARGET_MACHINE srcdir SHELL MACRO_LIST && \
+	      cd $(build_objdir)/fixincludes && \
+	      $(SHELL) ./fixinc.sh "$${gcc_dir}/$${fix_dir}" \
+	        $(SYSTEM_HEADER_DIR) $(OTHER_FIXINCLUDES_DIRS) ); \
+	    rm -f $${fix_dir}/syslimits.h; \
+	    if [ -f $${fix_dir}/limits.h ]; then \
+	      mv $${fix_dir}/limits.h $${fix_dir}/syslimits.h; \
+	    else \
+	      cp $(srcdir)/gsyslimits.h $${fix_dir}/syslimits.h; \
+	    fi; \
+	    chmod a+r $${fix_dir}/syslimits.h; \
+	  done; \
+	fi
+	$(STAMP) stmp-fixinc
+#
+# Remake the info files.
+
+doc: $(BUILD_INFO) $(GENERATED_MANPAGES) gccbug
+
+INFOFILES = doc/cpp.info doc/gcc.info doc/gccint.info \
+            doc/gccinstall.info doc/cppinternals.info
+
+info: $(INFOFILES) lang.info @GENINSRC@ srcinfo lang.srcinfo
+
+srcinfo: $(INFOFILES)
+	-cp -p $^ $(srcdir)/doc
+
+TEXI_CPP_FILES = cpp.texi fdl.texi cppenv.texi cppopts.texi		\
+	 gcc-common.texi gcc-vers.texi
+
+TEXI_GCC_FILES = gcc.texi gcc-common.texi gcc-vers.texi frontends.texi	\
+	 standards.texi invoke.texi extend.texi md.texi objc.texi	\
+	 gcov.texi trouble.texi bugreport.texi service.texi		\
+	 contribute.texi compat.texi funding.texi gnu.texi gpl_v3.texi	\
+	 fdl.texi contrib.texi cppenv.texi cppopts.texi			\
+	 implement-c.texi implement-cxx.texi arm-neon-intrinsics.texi
+
+TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi		\
+	 contribute.texi makefile.texi configterms.texi options.texi	\
+	 portability.texi interface.texi passes.texi	\
+	 rtl.texi md.texi tm.texi hostconfig.texi fragments.texi	\
+	 configfiles.texi collect2.texi headerdirs.texi funding.texi	\
+	 gnu.texi gpl_v3.texi fdl.texi contrib.texi languages.texi	\
+	 sourcebuild.texi gty.texi libgcc.texi cfg.texi tree-ssa.texi	\
+	 loop.texi generic.texi gimple.texi plugins.texi
+
+TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi		\
+	 gcc-common.texi gcc-vers.texi
+
+TEXI_CPPINT_FILES = cppinternals.texi gcc-common.texi gcc-vers.texi
+
+# gcc-vers.texi is generated from the version files.
+gcc-vers.texi: $(BASEVER) $(DEVPHASE)
+	(echo "@set version-GCC $(BASEVER_c)"; \
+	 if [ "$(DEVPHASE_c)" = "experimental" ]; \
+	 then echo "@set DEVELOPMENT"; \
+	 else echo "@clear DEVELOPMENT"; \
+	 fi) > $@T
+	$(build_file_translate) echo @set srcdir $(abs_srcdir) >> $@T
+	if [ -n "$(PKGVERSION)" ]; then \
+	  echo "@set VERSION_PACKAGE $(PKGVERSION)" >> $@T; \
+	fi
+	echo "@set BUGURL $(BUGURL_TEXI)" >> $@T; \
+	mv -f $@T $@
+
+
+# The *.1, *.7, *.info, *.dvi, and *.pdf files are being generated from implicit
+# patterns.  To use them, put each of the specific targets with its
+# specific dependencies but no build commands.
+
+doc/cpp.info: $(TEXI_CPP_FILES)
+doc/gcc.info: $(TEXI_GCC_FILES)
+doc/gccint.info: $(TEXI_GCCINT_FILES)
+doc/cppinternals.info: $(TEXI_CPPINT_FILES)
+
+doc/%.info: %.texi
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) $(MAKEINFOFLAGS) -I . -I $(gcc_docdir) \
+			-I $(gcc_docdir)/include -o $@ $<; \
+	fi
+
+# Duplicate entry to handle renaming of gccinstall.info
+doc/gccinstall.info: $(TEXI_GCCINSTALL_FILES)
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \
+			-I $(gcc_docdir)/include -o $@ $<; \
+	fi
+
+doc/cpp.dvi: $(TEXI_CPP_FILES)
+doc/gcc.dvi: $(TEXI_GCC_FILES)
+doc/gccint.dvi: $(TEXI_GCCINT_FILES)
+doc/cppinternals.dvi: $(TEXI_CPPINT_FILES)
+
+doc/cpp.pdf: $(TEXI_CPP_FILES)
+doc/gcc.pdf: $(TEXI_GCC_FILES)
+doc/gccint.pdf: $(TEXI_GCCINT_FILES)
+doc/cppinternals.pdf: $(TEXI_CPPINT_FILES)
+
+$(build_htmldir)/cpp/index.html: $(TEXI_CPP_FILES)
+$(build_htmldir)/gcc/index.html: $(TEXI_GCC_FILES)
+$(build_htmldir)/gccint/index.html: $(TEXI_GCCINT_FILES)
+$(build_htmldir)/cppinternals/index.html: $(TEXI_CPPINT_FILES)
+
+dvi:: doc/gcc.dvi doc/gccint.dvi doc/gccinstall.dvi doc/cpp.dvi \
+      doc/cppinternals.dvi lang.dvi
+
+doc/%.dvi: %.texi
+	$(TEXI2DVI) -I . -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+# Duplicate entry to handle renaming of gccinstall.dvi
+doc/gccinstall.dvi: $(TEXI_GCCINSTALL_FILES)
+	$(TEXI2DVI) -I . -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+PDFFILES = doc/gcc.pdf doc/gccint.pdf doc/gccinstall.pdf doc/cpp.pdf \
+           doc/cppinternals.pdf
+
+pdf:: $(PDFFILES) lang.pdf
+
+doc/%.pdf: %.texi
+	$(TEXI2PDF) -I . -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+# Duplicate entry to handle renaming of gccinstall.pdf
+doc/gccinstall.pdf: $(TEXI_GCCINSTALL_FILES)
+	$(TEXI2PDF) -I . -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<
+
+# List the directories or single hmtl files which are installed by
+# install-html. The lang.html file triggers language fragments to build
+# html documentation.
+HTMLS_INSTALL=$(build_htmldir)/cpp $(build_htmldir)/gcc \
+       $(build_htmldir)/gccinstall $(build_htmldir)/gccint \
+       $(build_htmldir)/cppinternals
+
+# List the html file targets.
+HTMLS_BUILD=$(build_htmldir)/cpp/index.html $(build_htmldir)/gcc/index.html \
+       $(build_htmldir)/gccinstall/index.html $(build_htmldir)/gccint/index.html \
+       $(build_htmldir)/cppinternals/index.html lang.html
+
+html:: $(HTMLS_BUILD)
+
+$(build_htmldir)/%/index.html: %.texi
+	$(mkinstalldirs) $(@D)
+	rm -f $(@D)/*
+	$(TEXI2HTML) -I $(abs_docdir) -I $(abs_docdir)/include -o $(@D) $<
+
+# Duplicate entry to handle renaming of gccinstall
+$(build_htmldir)/gccinstall/index.html: $(TEXI_GCCINSTALL_FILES)
+	$(mkinstalldirs) $(@D)
+	echo rm -f $(@D)/*
+	SOURCEDIR=$(abs_docdir) \
+	DESTDIR=$(@D) \
+	$(SHELL) $(srcdir)/doc/install.texi2html
+
+MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 doc/fsf-funding.7
+
+generated-manpages: man
+
+man: $(MANFILES) lang.man @GENINSRC@ srcman lang.srcman
+
+srcman: $(MANFILES)
+	-cp -p $^ $(srcdir)/doc
+
+doc/%.1: %.pod
+	$(STAMP) $@
+	-($(POD2MAN) --section=1 $< > $(@).T$$$$ && \
+		mv -f $(@).T$$$$ $@) || \
+		(rm -f $(@).T$$$$ && exit 1)
+
+doc/%.7: %.pod
+	$(STAMP) $@
+	-($(POD2MAN) --section=7 $< > $(@).T$$$$ && \
+		mv -f $(@).T$$$$ $@) || \
+		(rm -f $(@).T$$$$ && exit 1)
+
+%.pod: %.texi
+	$(STAMP) $@
+	-$(TEXI2POD) -DBUGURL="$(BUGURL_TEXI)" $< > $@
+
+.INTERMEDIATE: cpp.pod gcc.pod gfdl.pod fsf-funding.pod
+cpp.pod: cpp.texi cppenv.texi cppopts.texi
+
+# These next rules exist because the output name is not the same as
+# the input name, so our implicit %.pod rule will not work.
+
+gcc.pod: invoke.texi cppenv.texi cppopts.texi gcc-vers.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+gfdl.pod: fdl.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+fsf-funding.pod: funding.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+gpl.pod: gpl_v3.texi
+	$(STAMP) $@
+	-$(TEXI2POD) $< > $@
+
+#
+# Deletion of files made during compilation.
+# There are four levels of this:
+#   `mostlyclean', `clean', `distclean' and `maintainer-clean'.
+# `mostlyclean' is useful while working on a particular type of machine.
+# It deletes most, but not all, of the files made by compilation.
+# It does not delete libgcc.a or its parts, so it won't have to be recompiled.
+# `clean' deletes everything made by running `make all'.
+# `distclean' also deletes the files made by config.
+# `maintainer-clean' also deletes everything that could be regenerated
+# automatically, except for `configure'.
+# We remove as much from the language subdirectories as we can
+# (less duplicated code).
+
+mostlyclean: lang.mostlyclean
+	-rm -f $(MOSTLYCLEANFILES)
+	-rm -f *$(objext)
+	-rm -f *$(coverageexts)
+# Delete build programs
+	-rm -f build/*
+	-rm -f mddeps.mk
+# Delete other built files.
+	-rm -f specs.h options.c options.h
+# Delete the stamp and temporary files.
+	-rm -f s-* tmp-* stamp-* stmp-*
+	-rm -f */stamp-* */tmp-*
+# Delete debugging dump files.
+	-rm -f *.[0-9][0-9].* */*.[0-9][0-9].*
+# Delete some files made during installation.
+	-rm -f specs $(SPECS)
+	-rm -f collect collect2 mips-tfile mips-tdump
+# Delete unwanted output files from TeX.
+	-rm -f *.toc *.log *.vr *.fn *.cp *.tp *.ky *.pg
+	-rm -f */*.toc */*.log */*.vr */*.fn */*.cp */*.tp */*.ky */*.pg
+# Delete sorted indices we don't actually use.
+	-rm -f gcc.vrs gcc.kys gcc.tps gcc.pgs gcc.fns
+# Delete core dumps.
+	-rm -f core */core
+# Delete file generated for gengtype
+	-rm -f gtyp-input.list
+# Delete files generated by gengtype.c
+	-rm -f gtype-*
+	-rm -f gt-*
+# Delete genchecksum outputs
+	-rm -f *-checksum.c
+
+# Delete all files made by compilation
+# that don't exist in the distribution.
+clean: mostlyclean lang.clean
+	-rm -f libgcc.a libgcc_eh.a libgcov.a
+	-rm -f libgcc_s*
+	-rm -f libunwind*
+	-rm -f config.h tconfig.h bconfig.h tm_p.h tm.h
+	-rm -f options.c options.h optionlist
+	-rm -f cs-*
+	-rm -f doc/*.dvi
+	-rm -f doc/*.pdf
+# Delete the include directories.
+	-rm -rf include include-fixed
+# Delete files used by the "multilib" facility (including libgcc subdirs).
+	-rm -f multilib.h tmpmultilib*
+	-if [ "x$(MULTILIB_DIRNAMES)" != x ] ; then \
+	  rm -rf $(MULTILIB_DIRNAMES); \
+	else if [ "x$(MULTILIB_OPTIONS)" != x ] ; then \
+	  rm -rf `echo $(MULTILIB_OPTIONS) | sed -e 's/\// /g'`; \
+	fi ; fi
+
+# Delete all files that users would normally create
+# while building and installing GCC.
+distclean: clean lang.distclean
+	-rm -f auto-host.h auto-build.h
+	-rm -f cstamp-h
+	-rm -f config.status config.run config.cache config.bak
+	-rm -f Make-lang Make-hooks Make-host Make-target
+	-rm -f Makefile *.oaux
+	-rm -f gthr-default.h
+	-rm -f TAGS */TAGS
+	-rm -f *.asm
+	-rm -f site.exp site.bak testsuite/site.exp testsuite/site.bak
+	-rm -f testsuite/*.log testsuite/*.sum
+	-cd testsuite && rm -f x *.x *.x? *.exe *.rpo *.o *.s *.S *.c
+	-cd testsuite && rm -f *.out *.gcov *$(coverageexts)
+	-rm -rf ${QMTEST_DIR} stamp-qmtest
+	-rm -f cxxmain.c
+	-rm -f gccbug .gdbinit configargs.h
+	-rm -f gcov.pod
+# Delete po/*.gmo only if we are not building in the source directory.
+	-if [ ! -f po/exgettext ]; then rm -f po/*.gmo; fi
+	-rmdir ada cp f java objc intl po testsuite 2>/dev/null
+
+# Get rid of every file that's generated from some other file, except for `configure'.
+# Most of these files ARE PRESENT in the GCC distribution.
+maintainer-clean:
+	@echo 'This command is intended for maintainers to use; it'
+	@echo 'deletes files that may need special tools to rebuild.'
+	$(MAKE) lang.maintainer-clean distclean
+	-rm -f cpp.??s cpp.*aux
+	-rm -f gcc.??s gcc.*aux
+	-rm -f $(gcc_docdir)/*.info $(gcc_docdir)/*.1 $(gcc_docdir)/*.7 $(gcc_docdir)/*.dvi $(gcc_docdir)/*.pdf
+#
+# Entry points `install' and `uninstall'.
+# Also use `install-collect2' to install collect2 when the config files don't.
+
+# Copy the compiler files into directories where they will be run.
+# Install the driver last so that the window when things are
+# broken is small.
+install: install-common $(INSTALL_HEADERS) \
+    install-cpp install-man install-info install-@POSUB@ \
+    install-driver install-lto-wrapper
+
+ifeq ($(enable_plugin),yes)
+install: install-plugin
+endif
+
+# Handle cpp installation.
+install-cpp: installdirs cpp$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-$(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-if [ x$(cpp_install_dir) != x ]; then \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	else true; fi
+
+# Create the installation directories.
+# $(libdir)/gcc/include isn't currently searched by cpp.
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libsubdir)
+	$(mkinstalldirs) $(DESTDIR)$(libexecsubdir)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	$(mkinstalldirs) $(DESTDIR)$(includedir)
+	$(mkinstalldirs) $(DESTDIR)$(infodir)
+	$(mkinstalldirs) $(DESTDIR)$(slibdir)
+	$(mkinstalldirs) $(DESTDIR)$(man1dir)
+	$(mkinstalldirs) $(DESTDIR)$(man7dir)
+
+PLUGIN_HEADERS = $(TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+  $(TOPLEV_H) $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_PASS_H) $(GCC_PLUGIN_H) \
+  $(GGC_H) $(TREE_DUMP_H) $(PRETTY_PRINT_H) opts.h $(PARAMS_H) plugin.def \
+  $(tm_file_list) $(tm_include_list) $(tm_p_file_list) $(tm_p_include_list) \
+  $(host_xm_file_list) $(host_xm_include_list) $(xm_include_list) \
+  intl.h $(PLUGIN_VERSION_H) $(DIAGNOSTIC_H) $(C_COMMON_H) $(C_PRETTY_PRINT_H) \
+  tree-iterator.h $(PLUGIN_H) $(TREE_FLOW_H) langhooks.h incpath.h debug.h \
+  except.h tree-ssa-sccvn.h real.h output.h $(IPA_UTILS_H) \
+  $(C_PRAGMA_H)  $(CPPLIB_H)  $(FUNCTION_H) \
+  cppdefault.h flags.h $(MD5_H) params.def params.h prefix.h tree-inline.h \
+  $(IPA_PROP_H) $(RTL_H) $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) version.h
+
+# generate the 'build fragment' b-header-vars
+s-header-vars: Makefile
+	rm -f tmp-header-vars
+	$(foreach header_var,$(shell sed < Makefile -e 's/^\([A-Z0-9_]*_H\)[      ]*=.*/\1/p' -e d),echo $(header_var)=$(shell echo $($(header_var):$(srcdir)/%=.../%) | sed -e 's~\.\.\./config/~config/~' -e 's~\.\.\..*/~~') >> tmp-header-vars;) \
+	$(SHELL) $(srcdir)/../move-if-change tmp-header-vars b-header-vars
+	$(STAMP) s-header-vars
+
+# Install the headers needed to build a plugin.
+install-plugin: installdirs lang.install-plugin s-header-vars
+# We keep the directory structure for files in config and .def files. All
+# other files are flattened to a single directory.
+	$(mkinstalldirs) $(DESTDIR)$(plugin_includedir)
+	headers=`echo $(PLUGIN_HEADERS) | tr ' ' '\012' | sort -u`; \
+	srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`; \
+	for file in $$headers; do \
+	  if [ -f $$file ] ; then \
+	    path=$$file; \
+	  elif [ -f $(srcdir)/$$file ]; then \
+	    path=$(srcdir)/$$file; \
+	  else continue; \
+	  fi; \
+	  case $$path in \
+	  "$(srcdir)"/config/* | "$(srcdir)"/*.def ) \
+	    base=`echo "$$path" | sed -e "s|$$srcdirstrip/||"`;; \
+	  *) base=`basename $$path` ;; \
+	  esac; \
+	  dest=$(plugin_includedir)/$$base; \
+	  echo $(INSTALL_DATA) $$path $(DESTDIR)$$dest; \
+	  dir=`dirname $$dest`; \
+	  $(mkinstalldirs) $(DESTDIR)$$dir; \
+	  $(INSTALL_DATA) $$path $(DESTDIR)$$dest; \
+	done
+	$(INSTALL_DATA) b-header-vars $(DESTDIR)$(plugin_includedir)/b-header-vars
+
+# Install the compiler executables built during cross compilation.
+install-common: native lang.install-common installdirs
+	for file in $(COMPILERS); do \
+	  if [ -f $$file ] ; then \
+	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	  else true; \
+	  fi; \
+	done
+	for file in $(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(COLLECT2) ..; do \
+	  if [ x"$$file" != x.. ]; then \
+	    rm -f $(DESTDIR)$(libexecsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libexecsubdir)/$$file; \
+	  else true; fi; \
+	done
+# We no longer install the specs file because its presence makes the
+# driver slower, and because people who need it can recreate it by
+# using -dumpspecs.  We remove any old version because it would
+# otherwise override the specs built into the driver.
+	rm -f $(DESTDIR)$(libsubdir)/specs
+# Install gcov if it was compiled.
+	-if [ -f gcov$(exeext) ]; \
+	then \
+	    rm -f $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) gcov$(exeext) $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	fi
+	$(INSTALL_SCRIPT) gccbug $(DESTDIR)$(bindir)/$(GCCBUG_INSTALL_NAME)
+
+# Install the driver program as $(target_noncanonical)-gcc,
+# $(target_noncanonical)-gcc-$(version)
+# and also as either gcc (if native) or $(gcc_tooldir)/bin/gcc.
+install-driver: installdirs xgcc$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)$(exeext)
+	-( cd $(DESTDIR)$(bindir) && \
+	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) )
+	-if [ -f gcc-cross$(exeext) ] ; then \
+	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
+	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	    $(INSTALL_PROGRAM) gcc-cross$(exeext) $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	  else true; fi; \
+	else \
+	  rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-tmp$(exeext); \
+	  ( cd $(DESTDIR)$(bindir) && \
+	    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-tmp$(exeext) && \
+	    mv -f $(target_noncanonical)-gcc-tmp$(exeext) $(GCC_TARGET_INSTALL_NAME)$(exeext) ); \
+	fi
+
+# Install the info files.
+# $(INSTALL_DATA) might be a relative pathname, so we can't cd into srcdir
+# to do the install.
+install-info:: doc installdirs \
+	$(DESTDIR)$(infodir)/cpp.info \
+	$(DESTDIR)$(infodir)/gcc.info \
+	$(DESTDIR)$(infodir)/cppinternals.info \
+	$(DESTDIR)$(infodir)/gccinstall.info \
+	$(DESTDIR)$(infodir)/gccint.info \
+	lang.install-info
+
+$(DESTDIR)$(infodir)/%.info: doc/%.info installdirs
+	rm -f $@
+	if [ -f $< ]; then \
+	  for f in $(<)*; do \
+	    realfile=`echo $$f | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(INSTALL_DATA) $$f $(DESTDIR)$(infodir)/$$realfile; \
+	    chmod a-x $(DESTDIR)$(infodir)/$$realfile; \
+	  done; \
+	else true; fi
+	-if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+	  if [ -f $@ ]; then \
+	    install-info --dir-file=$(DESTDIR)$(infodir)/dir $@; \
+	  else true; fi; \
+	else true; fi;
+
+pdf__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+
+install-pdf: $(PDFFILES) lang.install-pdf
+	@$(NORMAL_INSTALL)
+	test -z "$(pdfdir)/gcc" || $(mkinstalldirs) "$(DESTDIR)$(pdfdir)/gcc"
+	@list='$(PDFFILES)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(pdf__strip_dir) \
+	  echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'"; \
+	  $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(pdfdir)/gcc/$$f"; \
+	done
+
+html__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+
+install-html: $(HTMLS_BUILD) lang.install-html
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS_INSTALL)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
+
+# Install the man pages.
+install-man: lang.install-man \
+	$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext) \
+	$(DESTDIR)$(man7dir)/fsf-funding$(man7ext) \
+	$(DESTDIR)$(man7dir)/gfdl$(man7ext) \
+	$(DESTDIR)$(man7dir)/gpl$(man7ext)
+
+$(DESTDIR)$(man7dir)/%$(man7ext): doc/%.7 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext): doc/gcc.1 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext): doc/cpp.1 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext): doc/gcov.1 installdirs
+	-rm -f $@
+	-$(INSTALL_DATA) $< $@
+	-chmod a-x $@
+
+# Install all the header files built in the include subdirectory.
+install-headers: $(INSTALL_HEADERS_DIR)
+# Fix symlinks to absolute paths in the installed include directory to
+# point to the installed directory, not the build directory.
+# Don't need to use LN_S here since we really do need ln -s and no substitutes.
+	-files=`cd $(DESTDIR)$(libsubdir)/include-fixed; find . -type l -print 2>/dev/null`; \
+	if [ $$? -eq 0 ]; then \
+	  dir=`cd include-fixed; ${PWD_COMMAND}`; \
+	  for i in $$files; do \
+	    dest=`ls -ld $(DESTDIR)$(libsubdir)/include-fixed/$$i | sed -n 's/.*-> //p'`; \
+	    if expr "$$dest" : "$$dir.*" > /dev/null; then \
+	      rm -f $(DESTDIR)$(libsubdir)/include-fixed/$$i; \
+	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(DESTDIR)$(libsubdir)/include-fixed/$$i; \
+	    fi; \
+	  done; \
+	fi
+
+# Create or recreate the gcc private include file directory.
+install-include-dir: installdirs
+	$(mkinstalldirs) $(DESTDIR)$(libsubdir)/include
+	-rm -rf $(DESTDIR)$(libsubdir)/include-fixed
+	mkdir $(DESTDIR)$(libsubdir)/include-fixed
+	-chmod a+rx $(DESTDIR)$(libsubdir)/include-fixed
+
+# Create or recreate the install-tools include file directory.
+itoolsdir = $(libexecsubdir)/install-tools
+itoolsdatadir = $(libsubdir)/install-tools
+install-itoolsdirs: installdirs
+	$(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include
+	$(mkinstalldirs) $(DESTDIR)$(itoolsdir)
+
+# Install the include directory using tar.
+install-headers-tar: stmp-int-hdrs install-include-dir
+# We use `pwd`/include instead of just include to problems with CDPATH
+# Unless a full pathname is provided, some shells would print the new CWD,
+# found in CDPATH, corrupting the output.  We could just redirect the
+# output of `cd', but some shells lose on redirection within `()'s
+	(cd `${PWD_COMMAND}`/include ; \
+	 tar -cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include; tar xpf - )
+	(cd `${PWD_COMMAND}`/include-fixed ; \
+	 tar -cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include-fixed; tar xpf - )
+# /bin/sh on some systems returns the status of the first tar,
+# and that can lose with GNU tar which always writes a full block.
+# So use `exit 0' to ignore its exit status.
+
+# Install the include directory using cpio.
+install-headers-cpio: stmp-int-hdrs install-include-dir
+# See discussion about the use of `pwd` above
+	cd `${PWD_COMMAND}`/include ; \
+	find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include
+	cd `${PWD_COMMAND}`/include-fixed ; \
+	find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include-fixed
+
+# Install the include directory using cp.
+install-headers-cp: stmp-int-hdrs install-include-dir
+	cp -p -r include $(DESTDIR)$(libsubdir)
+	cp -p -r include-fixed $(DESTDIR)$(libsubdir)
+
+# Targets without dependencies, for use in prev-gcc during bootstrap.
+real-install-headers-tar:
+	(cd `${PWD_COMMAND}`/include-fixed ; \
+	 tar -cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include-fixed; tar xpf - )
+
+real-install-headers-cpio:
+	cd `${PWD_COMMAND}`/include-fixed ; \
+	find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include-fixed
+
+real-install-headers-cp:
+	cp -p -r include-fixed $(DESTDIR)$(libsubdir)
+
+# Install supporting files for fixincludes to be run later.
+install-mkheaders: stmp-int-hdrs install-itoolsdirs \
+  macro_list fixinc_list
+	$(INSTALL_DATA) $(srcdir)/gsyslimits.h \
+	  $(DESTDIR)$(itoolsdatadir)/gsyslimits.h
+	$(INSTALL_DATA) macro_list $(DESTDIR)$(itoolsdatadir)/macro_list
+	$(INSTALL_DATA) fixinc_list $(DESTDIR)$(itoolsdatadir)/fixinc_list
+	set -e; for ml in `cat fixinc_list`; do \
+	  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	  $(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}; \
+	  $(INSTALL_DATA) include-fixed$${multidir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \
+	done
+	$(INSTALL_SCRIPT) $(srcdir)/../mkinstalldirs \
+		$(DESTDIR)$(itoolsdir)/mkinstalldirs ; \
+	sysroot_headers_suffix='$${sysroot_headers_suffix}'; \
+		echo 'SYSTEM_HEADER_DIR="'"$(SYSTEM_HEADER_DIR)"'"' \
+		> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'OTHER_FIXINCLUDES_DIRS="$(OTHER_FIXINCLUDES_DIRS)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+	echo 'STMP_FIXINC="$(STMP_FIXINC)"' \
+		>> $(DESTDIR)$(itoolsdatadir)/mkheaders.conf
+
+# Use this target to install the program `collect2' under the name `collect2'.
+install-collect2: collect2 installdirs
+	$(INSTALL_PROGRAM) collect2$(exeext) $(DESTDIR)$(libexecsubdir)/collect2$(exeext)
+# Install the driver program as $(libsubdir)/gcc for collect2.
+	$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(libexecsubdir)/gcc$(exeext)
+
+# Install lto-wrapper.
+install-lto-wrapper: lto-wrapper$(exeext)
+	$(INSTALL_PROGRAM) lto-wrapper$(exeext) $(DESTDIR)$(libexecsubdir)/lto-wrapper$(exeext)
+
+# Cancel installation by deleting the installed files.
+uninstall: lang.uninstall
+	-rm -rf $(DESTDIR)$(libsubdir)
+	-rm -rf $(DESTDIR)$(libexecsubdir)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-if [ x$(cpp_install_dir) != x ]; then \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	else true; fi
+	-rm -rf $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext)
+	-rm -rf $(DESTDIR)$(man1dir)/cpp$(man1ext)
+	-rm -f $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
+	-rm -f $(DESTDIR)$(infodir)/cppinternals.info* $(DESTDIR)$(infodir)/gccint.info*
+#
+# These targets are for the dejagnu testsuites. The file site.exp
+# contains global variables that all the testsuites will use.
+
+target_subdir = @target_subdir@
+
+site.exp: ./config.status Makefile
+	@echo "Making a new config file..."
+	-@rm -f ./tmp?
+	@$(STAMP) site.exp
+	-@mv site.exp site.bak
+	@echo "## these variables are automatically generated by make ##" > ./tmp0
+	@echo "# Do not edit here. If you wish to override these values" >> ./tmp0
+	@echo "# add them to the last section" >> ./tmp0
+	@echo "set rootme \"`${PWD_COMMAND}`\"" >> ./tmp0
+	@echo "set srcdir \"`cd ${srcdir}; ${PWD_COMMAND}`\"" >> ./tmp0
+	@echo "set host_triplet $(host)" >> ./tmp0
+	@echo "set build_triplet $(build)" >> ./tmp0
+	@echo "set target_triplet $(target)" >> ./tmp0
+	@echo "set target_alias $(target_noncanonical)" >> ./tmp0
+	@echo "set libiconv \"$(LIBICONV)\"" >> ./tmp0
+# CFLAGS is set even though it's empty to show we reserve the right to set it.
+	@echo "set CFLAGS \"\"" >> ./tmp0
+	@echo "set CXXFLAGS \"\"" >> ./tmp0
+	@echo "set HOSTCC \"$(CC)\"" >> ./tmp0
+	@echo "set HOSTCFLAGS \"$(CFLAGS)\"" >> ./tmp0
+# When running the tests we set GCC_EXEC_PREFIX to the install tree so that
+# files that have already been installed there will be found.  The -B option
+# overrides it, so use of GCC_EXEC_PREFIX will not result in using GCC files
+# from the install tree.
+	@echo "set TEST_GCC_EXEC_PREFIX \"$(libdir)/gcc/\"" >> ./tmp0
+	@echo "set TESTING_IN_BUILD_TREE 1" >> ./tmp0
+	@echo "set HAVE_LIBSTDCXX_V3 1" >> ./tmp0
+	@if test "@enable_plugin@" = "yes" ; then \
+	  echo "set ENABLE_PLUGIN 1" >> ./tmp0; \
+	  echo "set PLUGINCC \"$(PLUGINCC)\"" >> ./tmp0; \
+	  echo "set PLUGINCFLAGS \"$(PLUGINCFLAGS)\"" >> ./tmp0; \
+	  echo "set GMPINC \"$(GMPINC)\"" >> ./tmp0; \
+	fi
+	@if test "@enable_lto@" = "yes" ; then \
+	  echo "set ENABLE_LTO 1" >> ./tmp0; \
+	fi
+# If newlib has been configured, we need to pass -B to gcc so it can find
+# newlib's crt0.o if it exists.  This will cause a "path prefix not used"
+# message if it doesn't, but the testsuite is supposed to ignore the message -
+# it's too difficult to tell when to and when not to pass -B (not all targets
+# have crt0's).  We could only add the -B if ../newlib/crt0.o exists, but that
+# seems like too selective a test.
+# ??? Another way to solve this might be to rely on linker scripts.  Then
+# theoretically the -B won't be needed.
+# We also need to pass -L ../ld so that the linker can find ldscripts.
+	@if [ -d $(objdir)/../$(target_subdir)/newlib ] \
+	    && [ "${host}" != "${target}" ]; then \
+	  echo "set newlib_cflags \"-I$(objdir)/../$(target_subdir)/newlib/targ-include -I\$$srcdir/../newlib/libc/include\"" >> ./tmp0; \
+	  echo "set newlib_ldflags \"-B$(objdir)/../$(target_subdir)/newlib/\"" >> ./tmp0; \
+	  echo "append CFLAGS \" \$$newlib_cflags\"" >> ./tmp0; \
+	  echo "append CXXFLAGS \" \$$newlib_cflags\"" >> ./tmp0; \
+	  echo "append LDFLAGS \" \$$newlib_ldflags\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ -d $(objdir)/../ld ] ; then \
+	  echo "append LDFLAGS \" -L$(objdir)/../ld\"" >> ./tmp0; \
+	else true; \
+	fi
+	echo "set tmpdir $(objdir)/testsuite" >> ./tmp0
+	@echo "set srcdir \"\$${srcdir}/testsuite\"" >> ./tmp0
+	@if [ "X$(ALT_CC_UNDER_TEST)" != "X" ] ; then \
+	  echo "set ALT_CC_UNDER_TEST \"$(ALT_CC_UNDER_TEST)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ "X$(ALT_CXX_UNDER_TEST)" != "X" ] ; then \
+	  echo "set ALT_CXX_UNDER_TEST \"$(ALT_CXX_UNDER_TEST)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@if [ "X$(COMPAT_OPTIONS)" != "X" ] ; then \
+	  echo "set COMPAT_OPTIONS \"$(COMPAT_OPTIONS)\"" >> ./tmp0; \
+	else true; \
+	fi
+	@echo "## All variables above are generated by configure. Do Not Edit ##" >> ./tmp0
+	@cat ./tmp0 > site.exp
+	@cat site.bak | sed \
+		-e '1,/^## All variables above are.*##/ d' >> site.exp
+	-@rm -f ./tmp?
+
+CHECK_TARGETS = check-gcc @check_languages@
+
+check: $(CHECK_TARGETS)
+
+check-subtargets: $(patsubst %,%-subtargets,$(CHECK_TARGETS))
+
+# The idea is to parallelize testing of multilibs, for example:
+#   make -j3 check-gcc//sh-hms-sim/{-m1,-m2,-m3,-m3e,-m4}/{,-nofpu}
+# will run 3 concurrent sessions of check-gcc, eventually testing
+# all 10 combinations.  GNU make is required, as is a shell that expands
+# alternations within braces.
+lang_checks_parallel = $(lang_checks:=//%)
+$(lang_checks_parallel): site.exp
+	target=`echo "$@" | sed 's,//.*,,'`; \
+	variant=`echo "$@" | sed 's,^[^/]*//,,'`; \
+	vardots=`echo "$$variant" | sed 's,/,.,g'`; \
+	$(MAKE) TESTSUITEDIR="testsuite.$$vardots" \
+	  RUNTESTFLAGS="--target_board=$$variant $(RUNTESTFLAGS)" \
+	  "$$target"
+
+TESTSUITEDIR = testsuite
+
+$(TESTSUITEDIR)/site.exp: site.exp
+	-test -d $(TESTSUITEDIR) || mkdir $(TESTSUITEDIR)
+	-rm -f $@
+	sed '/set tmpdir/ s|testsuite$$|$(TESTSUITEDIR)|' < site.exp > $@
+
+# This is only used for check-% targets that aren't parallelized.
+$(filter-out $(lang_checks_parallelized),$(lang_checks)): check-% : site.exp
+	-test -d $(TESTSUITEDIR) || mkdir $(TESTSUITEDIR)
+	test -d $(TESTSUITEDIR)/$* || mkdir $(TESTSUITEDIR)/$*
+	-(rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd $(TESTSUITEDIR)/$*; \
+	rm -f tmp-site.exp; \
+	sed '/set tmpdir/ s|testsuite$$|$(TESTSUITEDIR)/$*|' \
+		< ../../site.exp > tmp-site.exp; \
+	$(SHELL) $${srcdir}/../move-if-change tmp-site.exp site.exp; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd $${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	    export TCL_LIBRARY ; fi ; \
+	$(RUNTEST) --tool $* $(RUNTESTFLAGS))
+
+$(patsubst %,%-subtargets,$(filter-out $(lang_checks_parallelized),$(lang_checks))): check-%-subtargets:
+	@echo check-$*
+
+check_p_tool=$(firstword $(subst _, ,$*))
+check_p_vars=$(check_$(check_p_tool)_parallelize)
+check_p_subno=$(word 2,$(subst _, ,$*))
+check_p_comma=,
+check_p_subwork=$(subst $(check_p_comma), ,$(if $(check_p_subno),$(word $(check_p_subno),$(check_p_vars))))
+check_p_numbers=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
+check_p_subdir=$(subst _,,$*)
+check_p_subdirs=$(wordlist 1,$(words $(check_$*_parallelize)),$(check_p_numbers))
+
+# For parallelized check-% targets, this decides whether parallelization
+# is desirable (if -jN is used and RUNTESTFLAGS doesn't contain anything
+# but optionally --target_board argument).  If it is desirable,
+# recursive make is run with check-parallel-$lang{,1,2,3,4,5} etc. goals,
+# which can be executed in parallel, as they are run in separate directories.
+# check-parallel-$lang{1,2,3,4,5} etc. goals invoke runtest with the longest
+# running *.exp files from the testsuite, as determined by check_$lang_parallelize
+# variable.  The check-parallel-$lang goal in that case invokes runtest with
+# all the remaining *.exp files not handled by the separate goals.
+# Afterwards contrib/dg-extract-results.sh is used to merge the sum and log
+# files.  If parallelization isn't desirable, only one recursive make
+# is run with check-parallel-$lang goal and check_$lang_parallelize variable
+# cleared to say that no additional arguments beyond $(RUNTESTFLAGS)
+# should be passed to runtest.
+#
+# To parallelize some language check, add the corresponding check-$lang
+# to lang_checks_parallelized variable and define check_$lang_parallelize
+# variable (see above check_gcc_parallelize description).
+$(lang_checks_parallelized): check-% : site.exp
+	@if [ -z "$(filter-out --target_board=%, $(RUNTESTFLAGS))" ] \
+	    && [ "$(filter -j, $(MFLAGS))" = "-j" ]; then \
+	  $(MAKE) TESTSUITEDIR="$(TESTSUITEDIR)" RUNTESTFLAGS="$(RUNTESTFLAGS)" \
+	    check-parallel-$* \
+	    $(patsubst %,check-parallel-$*_%, $(check_p_subdirs)); \
+	  for file in $(TESTSUITEDIR)/$*/$* \
+		      $(patsubst %,$(TESTSUITEDIR)/$*%/$*,$(check_p_subdirs));\
+	  do \
+	    mv -f $$file.sum $$file.sum.sep; mv -f $$file.log $$file.log.sep; \
+	  done; \
+	  $(SHELL) $(srcdir)/../contrib/dg-extract-results.sh \
+	    $(TESTSUITEDIR)/$*/$*.sum.sep \
+	    $(patsubst %,$(TESTSUITEDIR)/$*%/$*.sum.sep,$(check_p_subdirs)) \
+	    > $(TESTSUITEDIR)/$*/$*.sum; \
+	  $(SHELL) $(srcdir)/../contrib/dg-extract-results.sh -L \
+	    $(TESTSUITEDIR)/$*/$*.log.sep \
+	    $(patsubst %,$(TESTSUITEDIR)/$*%/$*.log.sep,$(check_p_subdirs)) \
+	    > $(TESTSUITEDIR)/$*/$*.log; \
+	else \
+	  $(MAKE) TESTSUITEDIR="$(TESTSUITEDIR)" RUNTESTFLAGS="$(RUNTESTFLAGS)" \
+	    check_$*_parallelize= check-parallel-$*; \
+	fi
+
+# Just print the parallelized subtargets for those that want to split
+# the testing across machines.
+$(patsubst %,%-subtargets,$(lang_checks_parallelized)): check-%-subtargets:
+	@echo check-parallel-$* \
+	  $(patsubst %,check-parallel-$*_%, $(check_p_subdirs))
+
+# In the if [ -n "$(check_p_subno)" ] case runtest should be given the name of
+# the given *.exp file(s).  See comment above check_gcc_parallelize variable
+# for details on the content of these variables.
+#
+# In the elif [ -n "$(check_p_vars)" ] case runtest should be given
+# names of all the *.exp files for this tool that aren't already handled by
+# other goals.  First it finds all the *.exp files for this tool, then
+# prunes those already specified in check_$lang_parallelize or duplicates.
+#
+# Otherwise check-$lang isn't parallelized and runtest is invoked just with
+# the $(RUNTESTFLAGS) arguments.
+check-parallel-% : site.exp
+	-test -d $(TESTSUITEDIR) || mkdir $(TESTSUITEDIR)
+	test -d $(TESTSUITEDIR)/$(check_p_subdir) || mkdir $(TESTSUITEDIR)/$(check_p_subdir)
+	-(rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd $(TESTSUITEDIR)/$(check_p_subdir); \
+	rm -f tmp-site.exp; \
+	sed '/set tmpdir/ s|testsuite$$|$(TESTSUITEDIR)/$(check_p_subdir)|' \
+		< ../../site.exp > tmp-site.exp; \
+	$(SHELL) $${srcdir}/../move-if-change tmp-site.exp site.exp; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd $${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	    export TCL_LIBRARY ; fi ; \
+	runtestflags= ; \
+	if [ -n "$(check_p_subno)" ] ; then \
+	  runtestflags="$(check_p_subwork)"; \
+	elif [ -n "$(check_p_vars)" ] ; then \
+	  parts="`echo ' $(strip $(subst $(check_p_comma), ,$(check_p_vars))) ' \
+		  | sed 's/=[^ ]* / /g'`"; \
+	  for part in `find $$srcdir/testsuite/$(check_p_tool)* -name \*.exp` ; do \
+	    part=`basename $$part` ; \
+	    case " $$parts $$runtestflags " in \
+	      *" $$part "*) ;; \
+	      *) runtestflags="$$runtestflags $$part" ;; \
+	    esac ; \
+	  done ; \
+	fi ; \
+	$(RUNTEST) --tool $(check_p_tool) $(RUNTESTFLAGS) $$runtestflags)
+
+check-consistency: testsuite/site.exp
+	-rootme=`${PWD_COMMAND}`; export rootme; \
+	srcdir=`cd ${srcdir}; ${PWD_COMMAND}` ; export srcdir ; \
+	cd testsuite; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	if [ -f $${rootme}/../expect/expect ] ; then  \
+	   TCL_LIBRARY=`cd .. ; cd $${srcdir}/../tcl/library ; ${PWD_COMMAND}` ; \
+	   export TCL_LIBRARY ; fi ; \
+	$(RUNTEST) --tool consistency $(RUNTESTFLAGS)
+
+# QMTest targets
+
+# The path to qmtest.
+QMTEST_PATH=qmtest
+
+# The flags to pass to qmtest.
+QMTESTFLAGS=
+
+# The flags to pass to "qmtest run".
+QMTESTRUNFLAGS=-f none --result-stream dejagnu_stream.DejaGNUStream
+
+# The command to use to invoke qmtest.
+QMTEST=${QMTEST_PATH} ${QMTESTFLAGS}
+
+# The tests (or suites) to run.
+QMTEST_GPP_TESTS=g++
+
+# The subdirectory of the OBJDIR that will be used to store the QMTest
+# test database configuration and that will be used for temporary
+# scratch space during QMTest's execution.
+QMTEST_DIR=qmtestsuite
+
+# Create the QMTest database configuration.
+${QMTEST_DIR} stamp-qmtest:
+	${QMTEST} -D ${QMTEST_DIR} create-tdb \
+	    -c gcc_database.GCCDatabase \
+	    -a srcdir=`cd ${srcdir}/testsuite && ${PWD_COMMAND}` && \
+	    $(STAMP) stamp-qmtest
+
+# Create the QMTest context file.
+${QMTEST_DIR}/context: stamp-qmtest
+	rm -f $@
+	echo "CompilerTable.languages=c cplusplus" >> $@
+	echo "CompilerTable.c_kind=GCC" >> $@
+	echo "CompilerTable.c_path=${objdir}/xgcc" >> $@
+	echo "CompilerTable.c_options=-B${objdir}/" >> $@
+	echo "CompilerTable.cplusplus_kind=GCC" >> $@
+	echo "CompilerTable.cplusplus_path=${objdir}/g++" >> $@
+	echo "CompilerTable.cplusplus_options=-B${objdir}/" >> $@
+	echo "DejaGNUTest.target=${target_noncanonical}" >> $@
+
+# Run the G++ testsuite using QMTest.
+qmtest-g++: ${QMTEST_DIR}/context
+	cd ${QMTEST_DIR} && ${QMTEST} run ${QMTESTRUNFLAGS} -C context \
+	   -o g++.qmr ${QMTEST_GPP_TESTS}
+
+# Use the QMTest GUI.
+qmtest-gui: ${QMTEST_DIR}/context
+	cd ${QMTEST_DIR} && ${QMTEST} gui -C context
+
+.PHONY: qmtest-g++
+
+# Run Paranoia on real.c.
+
+paranoia.o: $(srcdir)/../contrib/paranoia.cc $(CONFIG_H) $(SYSTEM_H) \
+  $(REAL_H) $(TREE_H)
+	g++ -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
+
+paranoia: paranoia.o real.o $(LIBIBERTY)
+	g++ -o $@ paranoia.o real.o $(LIBIBERTY)
+
+# These exist for maintenance purposes.
+
+# Update the tags table.
+TAGS: lang.tags
+	(cd $(srcdir);					\
+	incs= ;						\
+	list='$(SUBDIRS)'; for dir in $$list; do	\
+	  if test -f $$dir/TAGS; then			\
+	    incs="$$incs --include $$dir/TAGS.sub";	\
+	  fi;						\
+	done;						\
+	etags -o TAGS.sub *.h *.c; \
+	etags --include TAGS.sub $$incs)
+
+# -----------------------------------------------------
+# Rules for generating translated message descriptions.
+# Disabled by autoconf if the tools are not available.
+# -----------------------------------------------------
+
+XGETTEXT = @XGETTEXT@
+GMSGFMT = @GMSGFMT@
+MSGMERGE = msgmerge
+CATALOGS = $(patsubst %,po/%,@CATALOGS@)
+
+.PHONY: build- install- build-po install-po update-po
+
+# Dummy rules to deal with dependencies produced by use of
+# "build-@POSUB@" and "install-@POSUB@" above, when NLS is disabled.
+build-: ; @true
+install-: ; @true
+
+build-po: $(CATALOGS)
+
+# This notation should be acceptable to all Make implementations used
+# by people who are interested in updating .po files.
+update-po: $(CATALOGS:.gmo=.pox)
+
+# N.B. We do not attempt to copy these into $(srcdir).  The snapshot
+# script does that.
+.po.gmo:
+	$(mkinstalldirs) po
+	$(GMSGFMT) --statistics -o $@ $<
+
+# The new .po has to be gone over by hand, so we deposit it into
+# build/po with a different extension.
+# If build/po/gcc.pot exists, use it (it was just created),
+# else use the one in srcdir.
+.po.pox:
+	$(mkinstalldirs) po
+	$(MSGMERGE) $< `if test -f po/gcc.pot; \
+			then echo po/gcc.pot; \
+			else echo $(srcdir)/po/gcc.pot; fi` -o $@
+
+# This rule has to look for .gmo modules in both srcdir and
+# the cwd, and has to check that we actually have a catalog
+# for each language, in case they weren't built or included
+# with the distribution.
+install-po:
+	$(mkinstalldirs) $(DESTDIR)$(datadir)
+	cats="$(CATALOGS)"; for cat in $$cats; do \
+	  lang=`basename $$cat | sed 's/\.gmo$$//'`; \
+	  if [ -f $$cat ]; then :; \
+	  elif [ -f $(srcdir)/$$cat ]; then cat=$(srcdir)/$$cat; \
+	  else continue; \
+	  fi; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  echo $(mkinstalldirs) $(DESTDIR)$$dir; \
+	  $(mkinstalldirs) $(DESTDIR)$$dir || exit 1; \
+	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc.mo; \
+	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc.mo; \
+	done
+
+# Rule for regenerating the message template (gcc.pot).
+# Instead of forcing everyone to edit POTFILES.in, which proved impractical,
+# this rule has no dependencies and always regenerates gcc.pot.  This is
+# relatively harmless since the .po files do not directly depend on it.
+# Note that exgettext has an awk script embedded in it which requires a
+# fairly modern (POSIX-compliant) awk.
+# The .pot file is left in the build directory.
+gcc.pot: po/gcc.pot
+po/gcc.pot: force
+	$(mkinstalldirs) po
+	$(MAKE) srcextra
+	AWK=$(AWK) $(SHELL) $(srcdir)/po/exgettext \
+		$(XGETTEXT) gcc $(srcdir)
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/passes.c /home/haosun/intchecker/gcc-4.5.0/gcc/passes.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/passes.c	2010-04-02 15:54:46.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/passes.c	2015-01-15 17:22:06.809740577 -0500
@@ -810,6 +810,17 @@
   NEXT_PASS (pass_ipa_type_escape);
   NEXT_PASS (pass_ipa_pta);
   NEXT_PASS (pass_ipa_struct_reorg);
+
+  /* added by intfns */
+  NEXT_PASS (pass_intfns_mark);
+  NEXT_PASS (pass_intfns_cst);
+  NEXT_PASS (pass_intfns_dep);
+  NEXT_PASS (pass_intfns_finish);
+  {
+  	struct opt_pass **p = &pass_intfns_finish.pass.sub;
+	NEXT_PASS (pass_intfns_insert);
+  }
+  
   *p = NULL;
 
   p = &all_lto_gen_passes;
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/timevar.def /home/haosun/intchecker/gcc-4.5.0/gcc/timevar.def
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/timevar.def	2009-11-27 07:43:08.000000000 -0500
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/timevar.def	2015-01-15 17:20:22.221221970 -0500
@@ -214,5 +214,12 @@
 DEFTIMEVAR (TV_PLUGIN_INIT           , "plugin initialization")
 DEFTIMEVAR (TV_PLUGIN_RUN            , "plugin execution")
 
+/* added by intfns */
+DEFTIMEVAR (TV_INTFNS_MARK		 	, "mark stmt")
+DEFTIMEVAR (TV_INTFNS_CST	 		, "propagate cst")
+DEFTIMEVAR (TV_INTFNS_DEP	 	    , "dependence analysis")
+DEFTIMEVAR (TV_INTFNS_FINISH	    , "finish work")
+DEFTIMEVAR (TV_INTFNS_INSERT	    , "insert ovf check")
+
 /* Everything else in rest_of_compilation not included above.  */
 DEFTIMEVAR (TV_REST_OF_COMPILATION   , "rest of compilation")
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/toplev.c /home/haosun/intchecker/gcc-4.5.0/gcc/toplev.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/toplev.c	2010-03-30 22:44:10.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/toplev.c	2015-07-23 13:00:07.321547235 -0400
@@ -87,6 +87,9 @@
 #include "tree-ssa-alias.h"
 #include "plugin.h"
 
+/* added by intfns */
+extern void intfns_insert_main (void);
+
 #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)
 #include "dwarf2out.h"
 #endif
@@ -1074,6 +1077,10 @@
   if (flag_mudflap)
     mudflap_finish_file ();
 
+   /* added by intfns */
+  if (flag_intfns)
+  	intfns_insert_main();
+
   /* Likewise for emulated thread-local storage.  */
   if (!targetm.have_tls)
     emutls_finish ();
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/tree.h /home/haosun/intchecker/gcc-4.5.0/gcc/tree.h
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/tree.h	2010-04-02 15:54:46.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/tree.h	2015-06-06 22:12:52.365135313 -0400
@@ -391,7 +391,14 @@
   unsigned packed_flag : 1;
   unsigned user_align : 1;
 
-  unsigned spare : 13;
+  /* added by intfns*/
+  unsigned intfns_cst_flag: 1;
+  unsigned intfns_tree_node_inlist_flag: 1;
+  unsigned intfns_tree_node_ssaid_flag: 4;
+  unsigned intfns_tree_node_isleft_flag: 1;
+  unsigned spare: 6;
+
+  /*unsigned spare : 13;*/
 
   /* This field is only used with type nodes; the only reason it is present
      in tree_base instead of tree_type is to save space.  The size of the
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/tree-pass.h /home/haosun/intchecker/gcc-4.5.0/gcc/tree-pass.h
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/tree-pass.h	2010-04-02 15:54:46.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/tree-pass.h	2015-01-15 17:21:03.237425356 -0500
@@ -434,6 +434,16 @@
 extern struct gimple_opt_pass pass_tracer;
 extern struct gimple_opt_pass pass_warn_unused_result;
 
+/*added by intfns*/
+//extern struct gimple_opt_pass pass_intfns_mark_stmt;
+extern struct ipa_opt_pass_d pass_intfns_mark;
+extern struct ipa_opt_pass_d pass_intfns_cst;
+extern struct ipa_opt_pass_d pass_intfns_dep;
+extern struct ipa_opt_pass_d pass_intfns_finish;
+extern struct gimple_opt_pass pass_intfns_insert;
+
+
+
 /* IPA Passes */
 extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
 extern struct simple_ipa_opt_pass pass_ipa_early_inline;
diff -urN /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/tree-vrp.c /home/haosun/intchecker/gcc-4.5.0/gcc/tree-vrp.c
--- /home/haosun/purdue/backup/gcc-4.5.0-src/gcc/tree-vrp.c	2010-04-02 15:54:46.000000000 -0400
+++ /home/haosun/intchecker/gcc-4.5.0/gcc/tree-vrp.c	2014-08-04 16:29:08.000000000 -0400
@@ -7322,7 +7322,6 @@
   int i;
   edge e;
   switch_update *su;
-
   loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);
   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);
   scev_initialize ();
@@ -7334,7 +7333,7 @@
   threadedge_initialize_values ();
 
   vrp_initialize ();
-  ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);
+  ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);    
   vrp_finalize ();
 
   /* ASSERT_EXPRs must be removed before finalizing jump threads
@@ -7351,6 +7350,8 @@
 
   finalize_jump_threads ();
 
+  
+
   /* Remove dead edges from SWITCH_EXPR optimization.  This leaves the
      CFG in a broken state and requires a cfg_cleanup run.  */
   for (i = 0; VEC_iterate (edge, to_remove_edges, i, e); ++i)
